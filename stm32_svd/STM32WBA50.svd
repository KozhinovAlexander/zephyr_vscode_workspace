<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!--
Copyright (c) 2025 STMicroelectronics.

 SPDX-License-Identifier: Apache-2.0

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->
<device xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" schemaVersion="1.1" xs:noNamespaceSchemaLocation="CMSIS-SVD_Schema_1_1.xsd">
  <name>STM32WBA50</name>
  <version>1.0</version>
  <description>STM32WBA50</description>
  <cpu>
    <name>CM33</name>
    <revision>r0p1</revision>
    <endian>little</endian>
    <mpuPresent>true</mpuPresent>
    <fpuPresent>true</fpuPresent>
    <nvicPrioBits>4</nvicPrioBits>
    <vendorSystickConfig>false</vendorSystickConfig>
  </cpu>
  <addressUnitBits>8</addressUnitBits>
  <width>32</width>
  <size>0x20</size>
  <resetValue>0x0</resetValue>
  <resetMask>0xFFFFFFFF</resetMask>
  <peripherals>
    <peripheral>
      <name>ADC4</name>
      <description>ADC register block</description>
      <groupName>ADC</groupName>
      <baseAddress>0x46021000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x400</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>ADC4</name>
        <description>ADC4 global interrupt</description>
        <value>65</value>
      </interrupt>
      <registers>
        <register>
          <name>ADC_ISR</name>
          <displayName>ADC_ISR</displayName>
          <description>ADC interrupt and status register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADRDY</name>
              <description>ADC ready 

This bit is set by hardware after the ADC has been enabled (ADEN = 1) and when the ADC reaches a state where it is ready to accept conversion requests.

It is cleared by software writing 1 to it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>ADC not yet ready to start conversion (or the flag event was already acknowledged and cleared by software)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>ADC is ready to start conversion</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EOSMP</name>
              <description>End of sampling flag

This bit is set by hardware during the conversion, at the end of the sampling phase.It is cleared by software by writing 1 to it.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Not at the end of the sampling phase (or the flag event was already acknowledged and cleared by software)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>End of sampling phase reached</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EOC</name>
              <description>End of conversion flag

This bit is set by hardware at the end of each conversion of a channel when a new data result is available in the ADC_DR register. It is cleared by software writing 1 to it or by reading the ADC_DR register.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Channel conversion not complete (or the flag event was already acknowledged and cleared by software)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Channel conversion complete</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EOS</name>
              <description>End of sequence flag

This bit is set by hardware at the end of the conversion of a sequence of channels selected by the CHSEL bits. It is cleared by software writing 1 to it.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Conversion sequence not complete (or the flag event was already acknowledged and cleared by software)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Conversion sequence complete</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OVR</name>
              <description>ADC overrun

This bit is set by hardware when an overrun occurs, meaning that a new conversion has complete while the EOC flag was already set. It is cleared by software writing 1 to it.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No overrun occurred (or the flag event was already acknowledged and cleared by software)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Overrun has occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AWD1</name>
              <description>Analog watchdog 1 flag

This bit is set by hardware when the converted voltage crosses the values programmed in ADC_TR1 and ADC_HR1 registers. It is cleared by software by writing 1 to it.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No analog watchdog event occurred (or the flag event was already acknowledged and cleared by software)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Analog watchdog event occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AWD2</name>
              <description>Analog watchdog 2 flag

This bit is set by hardware when the converted voltage crosses the values programmed in ADC_AWD2TR and ADC_AWD2TR registers. It is cleared by software writing 1 to it.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No analog watchdog event occurred (or the flag event was already acknowledged and cleared by software)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Analog watchdog event occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AWD3</name>
              <description>Analog watchdog 3 flag

This bit is set by hardware when the converted voltage crosses the values programmed in ADC_AWD3TR and ADC_AWD3TR registers. It is cleared by software by writing 1 to it.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No analog watchdog event occurred (or the flag event was already acknowledged and cleared by software)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Analog watchdog event occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EOCAL</name>
              <description>End of calibration flag

This bit is set by hardware when calibration is complete. It is cleared by software writing 1 to it.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Calibration is not complete</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Calibration is complete</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LDORDY</name>
              <description>LDO ready

This bit is set by hardware. It indicates that the ADC internal LDO output is ready. 

It is cleared by software by writing 1 to it.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>ADC voltage regulator disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>ADC voltage regulator enabled and stabilized</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_IER</name>
          <displayName>ADC_IER</displayName>
          <description>ADC interrupt enable register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADRDYIE</name>
              <description>ADC ready interrupt enable

This bit is set and cleared by software to enable/disable the ADC Ready interrupt.

Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 by writing ADSTP to 1 (this ensures that no conversion is ongoing).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>ADRDY interrupt disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>ADRDY interrupt enabled. An interrupt is generated when the ADRDY bit is set.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EOSMPIE</name>
              <description>End of sampling flag interrupt enable

This bit is set and cleared by software to enable/disable the end of the sampling phase interrupt.

Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 by writing ADSTP to 1 (this ensures that no conversion is ongoing).</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>EOSMP interrupt disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>EOSMP interrupt enabled. An interrupt is generated when the EOSMP bit is set.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EOCIE</name>
              <description>End of conversion interrupt enable

This bit is set and cleared by software to enable/disable the end of conversion interrupt.

Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 by writing ADSTP to 1 (this ensures that no conversion is ongoing).</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>EOC interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>EOC interrupt enabled. An interrupt is generated when the EOC bit is set.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EOSIE</name>
              <description>End of conversion sequence interrupt enable

This bit is set and cleared by software to enable/disable the end of sequence of conversions interrupt.

Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 by writing ADSTP to 1 (this ensures that no conversion is ongoing).</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>EOS interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>EOS interrupt enabled. An interrupt is generated when the EOS bit is set.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OVRIE</name>
              <description>Overrun interrupt enable

This bit is set and cleared by software to enable/disable the overrun interrupt.

Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 by writing ADSTP to 1 (this ensures that no conversion is ongoing).</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Overrun interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Overrun interrupt enabled. An interrupt is generated when the OVR bit is set.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AWD1IE</name>
              <description>Analog watchdog 1 interrupt enable

This bit is set and cleared by software to enable/disable the analog watchdog interrupt. 

Note: The Software is allowed to write this bit only when ADSTART bit is cleared to 0 by writing ADSTP to 1 (this ensures that no conversion is ongoing).</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Analog watchdog interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Analog watchdog interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AWD2IE</name>
              <description>Analog watchdog 2 interrupt enable

This bit is set and cleared by software to enable/disable the analog watchdog interrupt. 

Note: The Software is allowed to write this bit only when ADSTART bit is cleared to 0 by writing ADSTP to 1 (this ensures that no conversion is ongoing).</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Analog watchdog interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Analog watchdog interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AWD3IE</name>
              <description>Analog watchdog 3 interrupt enable

This bit is set and cleared by software to enable/disable the analog watchdog interrupt. 

Note: The Software is allowed to write this bit only when ADSTART bit is cleared to 0 by writing ADSTP to 1 (this ensures that no conversion is ongoing).</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Analog watchdog interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Analog watchdog interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EOCALIE</name>
              <description>End of calibration interrupt enable

This bit is set and cleared by software to enable/disable the end of calibration interrupt. 

Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 by writing ADSTP to 1 (this ensures that no conversion is ongoing).</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>End of calibration interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>End of calibration interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LDORDYIE</name>
              <description>LDO ready interrupt enable

This bit is set and cleared by software. It is used to enable/disable the LDORDY interrupt.

Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 by writing ADSTP to 1 (this ensure that no conversion is ongoing).</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>LDO ready interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>LDO ready interrupt enabled. An interrupt is generated when the LDO output is ready.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_CR</name>
          <displayName>ADC_CR</displayName>
          <description>ADC control register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADEN</name>
              <description>ADC enable command

This bit is set by software to enable the ADC. The ADC is effectively ready to operate once the ADRDY flag has been set.

It is cleared by hardware when the ADC is disabled, after the execution of the ADDIS command.

Note: The software is allowed to set ADEN only when all bits of ADC_CR registers are 0 (ADCAL = 0, ADSTP = 0, ADSTART = 0, ADDIS = 0 and ADEN = 0)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>ADC is disabled (OFF state)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write 1 to enable the ADC.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADDIS</name>
              <description>ADC disable command

This bit is set by software to disable the ADC (ADDIS command) and put it into power-down state (OFF state).

It is cleared by hardware once the ADC is effectively disabled (ADEN is also cleared by hardware at this time).

Note: Setting ADDIS to 1 is only effective when ADEN = 1 and ADSTART = 0 (which ensures that no conversion is ongoing)</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No ADDIS command ongoing</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write 1 to disable the ADC. Read 1 means that an ADDIS command is in progress.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADSTART</name>
              <description>ADC start conversion command

This bit is set by software to start ADC conversion. Depending on the EXTEN [1:0] configuration bits, a conversion either starts immediately (software trigger configuration) or once a hardware trigger event occurs (hardware trigger configuration).

It is cleared by hardware:

In single conversion mode (CONT = 0, DISCEN = 0), when software trigger is selected (EXTEN = 00): at the assertion of the end of Conversion Sequence (EOS) flag.

In discontinuous conversion mode(CONT=0, DISCEN = 1), when the software trigger is selected (EXTEN = 00): at the assertion of the end of Conversion (EOC) flag.

In all other cases: after the execution of the ADSTP command, at the same time as the ADSTP bit is cleared by hardware.

Note: The software is allowed to set ADSTART only when ADEN = 1 and ADDIS = 0 (ADC is enabled and there is no pending request to disable the ADC).</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No ADC conversion is ongoing.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write 1 to start the ADC. Read 1 means that the ADC is operating and may be converting.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADSTP</name>
              <description>ADC stop conversion command

This bit is set by software to stop and discard an ongoing conversion (ADSTP Command).

It is cleared by hardware when the conversion is effectively discarded and the ADC is ready to accept a new start conversion command.

Note: To clear the A/D converter state, ADSTP must be set to 1 even if ADSTART is cleared to 0 after the software trigger A/D conversion. It is recommended to set ADSTP to 1 whenever the configuration needs to be modified.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No ADC stop conversion command ongoing</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write 1 to stop the ADC. Read 1 means that an ADSTP command is in progress.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADVREGEN</name>
              <description>ADC voltage regulator enable

This bit is set by software, to enable the ADC internal voltage regulator. The voltage regulator output is available after tsubADCVREG_SETUP/sub.

It is cleared by software to disable the voltage regulator. It can be cleared only if ADEN is et to 0.

Note: The software is allowed to program this bit field only when the ADC is disabled (ADCAL = 0, ADSTART = 0, ADSTP = 0, ADDIS = 0 and ADEN = 0).</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>ADC voltage regulator disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>ADC voltage regulator enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADCAL</name>
              <description>ADC calibration

This bit is set by software to start the calibration of the ADC.

It is cleared by hardware after calibration is complete.

Note: The software is allowed to set ADCAL only when the ADC is disabled (ADCAL = 0, ADSTART = 0, ADSTP = 0, ADDIS = 0, AUTOFF = 0, and ADEN = 0).

Note: The software is allowed to update the calibration factor by writing ADC_CALFACT only when ADEN is set to 1 and ADSTART is cleared to 0 by writing ADSTP to 1 (ADC enabled and no conversion is ongoing).</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Calibration complete</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write 1 to calibrate the ADC. Read at 1 means that a calibration is in progress.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_CFGR1</name>
          <displayName>ADC_CFGR1</displayName>
          <description>ADC configuration register 1</description>
          <addressOffset>0x0C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMAEN</name>
              <description>Direct memory access enable

This bit is set and cleared by software to enable the generation of DMA requests. This allows the automatic management of the converted data by the DMA controller. For more details, refer to Section : Managing converted data using the DMA on page 632.

Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 by writing ADSTP to 1 (this ensures that no conversion is ongoing).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>DMA disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>DMA enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DMACFG</name>
              <description>Direct memory access configuration

This bit is set and cleared by software to select between two DMA modes of operation and is effective only when DMAEN = 1.

For more details, refer to Section : Managing converted data using the DMA on page 632

Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 by writing ADSTP to 1 (this ensures that no conversion is ongoing).</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>DMA one shot mode selected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>DMA circular mode selected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RES</name>
              <description>Data resolution

These bits are written by software to select the resolution of the conversion.

Note: The software is allowed to write these bits only when ADSTART bit is cleared to 0 by writing ADSTP to 1 (this ensures that no conversion is ongoing).</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>12 bits</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>10 bits</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>8 bits</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>6 bits</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SCANDIR</name>
              <description>Scan sequence direction

This bit is set and cleared by software to select the direction in which the channels is scanned in the sequence. It is effective only if CHSELRMOD bit is cleared to 0. 

Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 by writing ADSTP to 1 (this ensures that no conversion is ongoing).</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Upward scan (from CHSEL0 to CHSEL11)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Backward scan (from CHSEL11 to CHSEL0)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ALIGN</name>
              <description>Data alignment

This bit is set and cleared by software to select right or left alignment. Refer to Figure 78: Data alignment and resolution (oversampling disabled: OVSE = 0) on page 631

Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 by writing ADSTP to 1 (this ensures that no conversion is ongoing).</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Right alignment</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Left alignment</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EXTSEL</name>
              <description>External trigger selection

These bits select the external event used to trigger the start of conversion (refer to table ADC interconnection in Section 20.4.2: ADC pins and internal signals for details):

Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 by writing ADSTP to 1 (this ensures that no conversion is ongoing).</description>
              <bitOffset>6</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>adc_trg0</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>adc_trg1</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>adc_trg2</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>adc_trg3</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>adc_trg4</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>adc_trg5</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x6</name>
                  <description>adc_trg6</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7</name>
                  <description>adc_trg7</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EXTEN</name>
              <description>External trigger enable and polarity selection

These bits are set and cleared by software to select the external trigger polarity and enable the trigger.

Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 by writing ADSTP to 1 (this ensures that no conversion is ongoing).</description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Hardware trigger detection disabled (conversions can be started by software)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Hardware trigger detection on the rising edge</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>Hardware trigger detection on the falling edge</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>Hardware trigger detection on both the rising and falling edges</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OVRMOD</name>
              <description>Overrun management mode

This bit is set and cleared by software and configure the way data overruns are managed.

Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 by writing ADSTP to 1 (this ensures that no conversion is ongoing).</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>ADC_DR register is preserved with the old data when an overrun is detected.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>ADC_DR register is overwritten with the last conversion result when an overrun is detected.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CONT</name>
              <description>Single / continuous conversion mode

This bit is set and cleared by software. If it is set, conversion takes place continuously until it is cleared.

Note: It is not possible to have both discontinuous mode and continuous mode enabled: it is forbidden to set both bits DISCEN = 1 and CONT = 1.

Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 by writing ADSTP to 1 (this ensures that no conversion is ongoing).</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Single conversion mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Continuous conversion mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT</name>
              <description>Wait conversion mode

This bit is set and cleared by software to enable/disable wait conversion mode.sup./sup

Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 by writing ADSTP to 1 (this ensures that no conversion is ongoing).</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Wait conversion mode off</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Wait conversion mode on</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DISCEN</name>
              <description>Discontinuous mode

This bit is set and cleared by software to enable/disable discontinuous mode.

Note: It is not possible to have both discontinuous mode and continuous mode enabled: it is forbidden to set both bits DISCEN = 1 and CONT = 1.

Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 by writing ADSTP to 1 (this ensures that no conversion is ongoing).</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Discontinuous mode disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Discontinuous mode enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CHSELRMOD</name>
              <description>Mode selection of the ADC_CHSELR register

This bit is set and cleared by software to control the ADC_CHSELR feature:

Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 by writing ADSTP to 1 (this ensures that no conversion is ongoing).</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Each bit of the ADC_CHSELR register enables an input</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>ADC_CHSELR register is able to sequence up to 8 channels</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AWD1SGL</name>
              <description>Enable the watchdog on a single channel or on all channels

This bit is set and cleared by software to enable the analog watchdog on the channel identified by the AWDCH[4:0] bits or on all the channels

Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 by writing ADSTP to 1 (this ensures that no conversion is ongoing).</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Analog watchdog 1 enabled on all channels</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Analog watchdog 1 enabled on a single channel</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AWD1EN</name>
              <description>Analog watchdog enable

This bit is set and cleared by software.

Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 by writing ADSTP to 1 (this ensures that no conversion is ongoing).</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Analog watchdog 1 disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Analog watchdog 1 enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AWD1CH</name>
              <description>Analog watchdog channel selection

These bits are set and cleared by software. They select the input channel to be guarded by the analog watchdog.

.....

Others: Reserved

The channel selected by the AWDCH[4:0] bits must be also set into the CHSELR register.

Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 by writing ADSTP to 1 (this ensures that no conversion is ongoing).</description>
              <bitOffset>26</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>ADC analog input Channel 0 monitored by AWD</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>ADC analog input Channel 1 monitored by AWD</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xB</name>
                  <description>ADC analog input Channel 11 monitored by AWD</description>
                  <value>0xB</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_CFGR2</name>
          <displayName>ADC_CFGR2</displayName>
          <description>ADC configuration register 2</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OVSE</name>
              <description>Oversampler Enable

This bit is set and cleared by software.

Note: Software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Oversampler disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Oversampler enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OVSR</name>
              <description>Oversampling ratio

This bit filed defines the number of oversampling ratio.

Note: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>2</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>2x</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>4x</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>8x</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>16x</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>32x</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>64x</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x6</name>
                  <description>128x</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7</name>
                  <description>256x</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OVSS</name>
              <description>Oversampling shift

This bit is set and cleared by software.

Others: Reserved

Note: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1(which ensures that no conversion is ongoing).</description>
              <bitOffset>5</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No shift</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Shift 1-bit</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>Shift 2-bits</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>Shift 3-bits</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>Shift 4-bits</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>Shift 5-bits</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x6</name>
                  <description>Shift 6-bits</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7</name>
                  <description>Shift 7-bits</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x8</name>
                  <description>Shift 8-bits</description>
                  <value>0x8</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TOVS</name>
              <description>Triggered Oversampling

This bit is set and cleared by software.

Note: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>All oversampled conversions for a channel are done consecutively after a trigger</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Each oversampled conversion for a channel needs a trigger</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LFTRIG</name>
              <description>Low frequency trigger mode enable

This bit must be set by software.

Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 by writing ADSTP to 1 (this ensures that no conversion is ongoing).</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Low frequency trigger mode enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_SMPR</name>
          <displayName>ADC_SMPR</displayName>
          <description>ADC sampling time register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SMP1</name>
              <description>Sampling time selection 1

These bits are written by software to select the sampling time that applies to all channels.

Note: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>1.5 ADC clock cycles</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>3.5 ADC clock cycles</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>7.5 ADC clock cycles</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>12.5 ADC clock cycles</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>19.5 ADC clock cycles</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>39.5 ADC clock cycles</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x6</name>
                  <description>79.5 ADC clock cycles</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7</name>
                  <description>814.5 ADC clock cycles</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SMP2</name>
              <description>Sampling time selection 2

These bits are written by software to select the sampling time that applies to all channels.

Note: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>1.5 ADC clock cycles</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>3.5 ADC clock cycles</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>7.5 ADC clock cycles</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>12.5 ADC clock cycles</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>19.5 ADC clock cycles</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>39.5 ADC clock cycles</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x6</name>
                  <description>79.5 ADC clock cycles</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7</name>
                  <description>814.5 ADC clock cycles</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SMPSEL0</name>
              <description>Channel-x sampling time selection

These bits are written by software to define which sampling time is used.

Note: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Sampling time of CHANNELx use the setting of SMP1[2:0] register.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Sampling time of CHANNELx use the setting of SMP2[2:0] register.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SMPSEL1</name>
              <description>Channel-x sampling time selection

These bits are written by software to define which sampling time is used.

Note: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Sampling time of CHANNELx use the setting of SMP1[2:0] register.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Sampling time of CHANNELx use the setting of SMP2[2:0] register.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SMPSEL2</name>
              <description>Channel-x sampling time selection

These bits are written by software to define which sampling time is used.

Note: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Sampling time of CHANNELx use the setting of SMP1[2:0] register.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Sampling time of CHANNELx use the setting of SMP2[2:0] register.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SMPSEL3</name>
              <description>Channel-x sampling time selection

These bits are written by software to define which sampling time is used.

Note: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Sampling time of CHANNELx use the setting of SMP1[2:0] register.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Sampling time of CHANNELx use the setting of SMP2[2:0] register.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SMPSEL4</name>
              <description>Channel-x sampling time selection

These bits are written by software to define which sampling time is used.

Note: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Sampling time of CHANNELx use the setting of SMP1[2:0] register.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Sampling time of CHANNELx use the setting of SMP2[2:0] register.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SMPSEL5</name>
              <description>Channel-x sampling time selection

These bits are written by software to define which sampling time is used.

Note: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Sampling time of CHANNELx use the setting of SMP1[2:0] register.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Sampling time of CHANNELx use the setting of SMP2[2:0] register.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SMPSEL6</name>
              <description>Channel-x sampling time selection

These bits are written by software to define which sampling time is used.

Note: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Sampling time of CHANNELx use the setting of SMP1[2:0] register.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Sampling time of CHANNELx use the setting of SMP2[2:0] register.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SMPSEL7</name>
              <description>Channel-x sampling time selection

These bits are written by software to define which sampling time is used.

Note: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Sampling time of CHANNELx use the setting of SMP1[2:0] register.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Sampling time of CHANNELx use the setting of SMP2[2:0] register.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SMPSEL8</name>
              <description>Channel-x sampling time selection

These bits are written by software to define which sampling time is used.

Note: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Sampling time of CHANNELx use the setting of SMP1[2:0] register.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Sampling time of CHANNELx use the setting of SMP2[2:0] register.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SMPSEL9</name>
              <description>Channel-x sampling time selection

These bits are written by software to define which sampling time is used.

Note: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Sampling time of CHANNELx use the setting of SMP1[2:0] register.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Sampling time of CHANNELx use the setting of SMP2[2:0] register.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SMPSEL10</name>
              <description>Channel-x sampling time selection

These bits are written by software to define which sampling time is used.

Note: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Sampling time of CHANNELx use the setting of SMP1[2:0] register.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Sampling time of CHANNELx use the setting of SMP2[2:0] register.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SMPSEL11</name>
              <description>Channel-x sampling time selection

These bits are written by software to define which sampling time is used.

Note: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Sampling time of CHANNELx use the setting of SMP1[2:0] register.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Sampling time of CHANNELx use the setting of SMP2[2:0] register.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SMPSEL12</name>
              <description>Channel-x sampling time selection

These bits are written by software to define which sampling time is used.

Note: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Sampling time of CHANNELx use the setting of SMP1[2:0] register.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Sampling time of CHANNELx use the setting of SMP2[2:0] register.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SMPSEL13</name>
              <description>Channel-x sampling time selection

These bits are written by software to define which sampling time is used.

Note: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Sampling time of CHANNELx use the setting of SMP1[2:0] register.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Sampling time of CHANNELx use the setting of SMP2[2:0] register.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_AWD1TR</name>
          <displayName>ADC_AWD1TR</displayName>
          <description>ADC watchdog threshold register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0FFF0000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LT1</name>
              <description>Analog watchdog 1 lower threshold

These bits are written by software to define the lower threshold for the analog watchdog.

Refer to Section 20.4.25: Analog window watchdog on page 638.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HT1</name>
              <description>Analog watchdog 1 higher threshold

These bits are written by software to define the higher threshold for the analog watchdog.

Refer to Section 20.4.25: Analog window watchdog on page 638.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_AWD2TR</name>
          <displayName>ADC_AWD2TR</displayName>
          <description>ADC watchdog threshold register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0FFF0000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LT2</name>
              <description>Analog watchdog 2 lower threshold

These bits are written by software to define the lower threshold for the analog watchdog.

Refer to Section 20.4.25: Analog window watchdog on page 638.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HT2</name>
              <description>Analog watchdog 2 higher threshold

These bits are written by software to define the higher threshold for the analog watchdog.

Refer to Section 20.4.25: Analog window watchdog on page 638.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_CHSELR</name>
          <displayName>ADC_CHSELR</displayName>
          <description>ADC channel selection register [alternate]</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CHSEL0</name>
              <description>Channel x selection

These bits are written by software and define which channels are part of the sequence of channels to be converted.

Note: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Input Channel-x is not selected for conversion</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Input Channel-x is selected for conversion</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CHSEL1</name>
              <description>Channel x selection

These bits are written by software and define which channels are part of the sequence of channels to be converted.

Note: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Input Channel-x is not selected for conversion</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Input Channel-x is selected for conversion</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CHSEL2</name>
              <description>Channel x selection

These bits are written by software and define which channels are part of the sequence of channels to be converted.

Note: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Input Channel-x is not selected for conversion</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Input Channel-x is selected for conversion</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CHSEL3</name>
              <description>Channel x selection

These bits are written by software and define which channels are part of the sequence of channels to be converted.

Note: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Input Channel-x is not selected for conversion</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Input Channel-x is selected for conversion</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CHSEL4</name>
              <description>Channel x selection

These bits are written by software and define which channels are part of the sequence of channels to be converted.

Note: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Input Channel-x is not selected for conversion</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Input Channel-x is selected for conversion</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CHSEL5</name>
              <description>Channel x selection

These bits are written by software and define which channels are part of the sequence of channels to be converted.

Note: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Input Channel-x is not selected for conversion</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Input Channel-x is selected for conversion</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CHSEL6</name>
              <description>Channel x selection

These bits are written by software and define which channels are part of the sequence of channels to be converted.

Note: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Input Channel-x is not selected for conversion</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Input Channel-x is selected for conversion</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CHSEL7</name>
              <description>Channel x selection

These bits are written by software and define which channels are part of the sequence of channels to be converted.

Note: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Input Channel-x is not selected for conversion</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Input Channel-x is selected for conversion</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CHSEL8</name>
              <description>Channel x selection

These bits are written by software and define which channels are part of the sequence of channels to be converted.

Note: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Input Channel-x is not selected for conversion</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Input Channel-x is selected for conversion</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CHSEL9</name>
              <description>Channel x selection

These bits are written by software and define which channels are part of the sequence of channels to be converted.

Note: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Input Channel-x is not selected for conversion</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Input Channel-x is selected for conversion</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CHSEL10</name>
              <description>Channel x selection

These bits are written by software and define which channels are part of the sequence of channels to be converted.

Note: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Input Channel-x is not selected for conversion</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Input Channel-x is selected for conversion</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CHSEL11</name>
              <description>Channel x selection

These bits are written by software and define which channels are part of the sequence of channels to be converted.

Note: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Input Channel-x is not selected for conversion</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Input Channel-x is selected for conversion</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CHSEL12</name>
              <description>Channel x selection

These bits are written by software and define which channels are part of the sequence of channels to be converted.

Note: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Input Channel-x is not selected for conversion</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Input Channel-x is selected for conversion</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CHSEL13</name>
              <description>Channel x selection

These bits are written by software and define which channels are part of the sequence of channels to be converted.

Note: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Input Channel-x is not selected for conversion</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Input Channel-x is selected for conversion</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_CHSELR_ALTERNATE</name>
          <displayName>ADC_CHSELR_ALTERNATE</displayName>
          <description>ADC channel selection register [alternate]</description>
          <alternateRegister>ADC_CHSELR</alternateRegister>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SQ1</name>
              <description>1st conversion of the sequence

These bits are programmed by software with the channel number assigned to the 1st conversion of the sequence. 0b1111 indicates end of the sequence.

When 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored.

Refer to SQ8[3:0] for a definition of channel selection. 

Note: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SQ2</name>
              <description>2nd conversion of the sequence

These bits are programmed by software with the channel number assigned to the 2nd conversion of the sequence. 0b1111 indicates end of the sequence.

When 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored.

Refer to SQ8[3:0] for a definition of channel selection. 

Note: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SQ3</name>
              <description>3rd conversion of the sequence

These bits are programmed by software with the channel number assigned to the 3rd conversion of the sequence. 0b1111 indicates end of the sequence.

When 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored.

Refer to SQ8[3:0] for a definition of channel selection. 

Note: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SQ4</name>
              <description>4th conversion of the sequence

These bits are programmed by software with the channel number assigned to the 4th conversion of the sequence. 0b1111 indicates end of the sequence.

When 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored.

Refer to SQ8[3:0] for a definition of channel selection. 

Note: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1(which ensures that no conversion is ongoing).</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SQ5</name>
              <description>5th conversion of the sequence

These bits are programmed by software with the channel number assigned to the 5th conversion of the sequence. 0b1111 indicates end of the sequence.

When 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored.

Refer to SQ8[3:0] for a definition of channel selection. 

Note: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SQ6</name>
              <description>6th conversion of the sequence

These bits are programmed by software with the channel number assigned to the 6th conversion of the sequence. 0b1111 indicates end of the sequence.

When 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored.

Refer to SQ8[3:0] for a definition of channel selection. 

Note: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SQ7</name>
              <description>7th conversion of the sequence

These bits are programmed by software with the channel number assigned to the 7th conversion of the sequence. 0b1111 indicates end of the sequence.

When 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored.

Refer to SQ8[3:0] for a definition of channel selection. 

Note: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SQ8</name>
              <description>8th conversion of the sequence

These bits are programmed by software with the channel number assigned to the 8th conversion of the sequence. 0b1111 indicates the end of the sequence.

When 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored.

...

Note: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>CH0</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>CH1</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xA</name>
                  <description>CH10</description>
                  <value>0xA</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xB</name>
                  <description>CH11</description>
                  <value>0xB</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xC</name>
                  <description>CH12</description>
                  <value>0xC</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xD</name>
                  <description>CH13</description>
                  <value>0xD</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xF</name>
                  <description>No channel selected (End of sequence)</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_AWD3TR</name>
          <displayName>ADC_AWD3TR</displayName>
          <description>ADC watchdog threshold register</description>
          <addressOffset>0x2C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0FFF0000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LT3</name>
              <description>Analog watchdog 3lower threshold

These bits are written by software to define the lower threshold for the analog watchdog.

Refer to Section 20.4.25: Analog window watchdog on page 638.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HT3</name>
              <description>Analog watchdog 3 higher threshold

These bits are written by software to define the higher threshold for the analog watchdog.

Refer to Section 20.4.25: Analog window watchdog on page 638.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_DR</name>
          <displayName>ADC_DR</displayName>
          <description>ADC data register</description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Converted data 

These bits are read-only. They contain the conversion result from the last converted channel. The data are left- or right-aligned as shown in Figure 78: Data alignment and resolution (oversampling disabled: OVSE = 0) on page 631.

Just after a calibration is complete, DATA[6:0] contains the calibration factor.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_PWR</name>
          <displayName>ADC_PWR</displayName>
          <description>ADC data register</description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AUTOFF</name>
              <description>Auto-off mode bit 

This bit is set and cleared by software. it is used to enable/disable the Auto-off mode.

Note: The software is allowed to write this bit only when ADEN bit is cleared to 0 (this ensures that no conversion is ongoing).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Auto-off mode disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Auto-off mode enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DPD</name>
              <description>Deep-power-down mode bit 

This bit is set and cleared by software. It is used to enable/disable Deep-power-down mode in Autonomous mode when the ADC is not used. 

Note: The software is allowed to write this bit only when ADEN bit is cleared to 0 (this ensures that no conversion is ongoing).

Note: Setting DPD in Auto-off mode automatically disables the LDO.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Deep-power-down mode disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Deep-power-down mode enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_AWD2CR</name>
          <displayName>ADC_AWD2CR</displayName>
          <description>ADC Analog Watchdog 2 Configuration register</description>
          <addressOffset>0xA0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AWD2CH0</name>
              <description>Analog watchdog channel selection

These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).

Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>ADC analog channel-x is not monitored by AWD2</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>ADC analog channel-x is monitored by AWD2</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AWD2CH1</name>
              <description>Analog watchdog channel selection

These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).

Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>ADC analog channel-x is not monitored by AWD2</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>ADC analog channel-x is monitored by AWD2</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AWD2CH2</name>
              <description>Analog watchdog channel selection

These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).

Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>ADC analog channel-x is not monitored by AWD2</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>ADC analog channel-x is monitored by AWD2</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AWD2CH3</name>
              <description>Analog watchdog channel selection

These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).

Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>ADC analog channel-x is not monitored by AWD2</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>ADC analog channel-x is monitored by AWD2</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AWD2CH4</name>
              <description>Analog watchdog channel selection

These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).

Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>ADC analog channel-x is not monitored by AWD2</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>ADC analog channel-x is monitored by AWD2</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AWD2CH5</name>
              <description>Analog watchdog channel selection

These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).

Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>ADC analog channel-x is not monitored by AWD2</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>ADC analog channel-x is monitored by AWD2</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AWD2CH6</name>
              <description>Analog watchdog channel selection

These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).

Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>ADC analog channel-x is not monitored by AWD2</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>ADC analog channel-x is monitored by AWD2</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AWD2CH7</name>
              <description>Analog watchdog channel selection

These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).

Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>ADC analog channel-x is not monitored by AWD2</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>ADC analog channel-x is monitored by AWD2</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AWD2CH8</name>
              <description>Analog watchdog channel selection

These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).

Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>ADC analog channel-x is not monitored by AWD2</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>ADC analog channel-x is monitored by AWD2</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AWD2CH9</name>
              <description>Analog watchdog channel selection

These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).

Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>ADC analog channel-x is not monitored by AWD2</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>ADC analog channel-x is monitored by AWD2</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AWD2CH10</name>
              <description>Analog watchdog channel selection

These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).

Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>ADC analog channel-x is not monitored by AWD2</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>ADC analog channel-x is monitored by AWD2</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AWD2CH11</name>
              <description>Analog watchdog channel selection

These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).

Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>ADC analog channel-x is not monitored by AWD2</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>ADC analog channel-x is monitored by AWD2</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AWD2CH12</name>
              <description>Analog watchdog channel selection

These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).

Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>ADC analog channel-x is not monitored by AWD2</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>ADC analog channel-x is monitored by AWD2</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AWD2CH13</name>
              <description>Analog watchdog channel selection

These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).

Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>ADC analog channel-x is not monitored by AWD2</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>ADC analog channel-x is monitored by AWD2</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_AWD3CR</name>
          <displayName>ADC_AWD3CR</displayName>
          <description>ADC Analog Watchdog 3 Configuration register</description>
          <addressOffset>0xA4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AWD3CH0</name>
              <description>Analog watchdog channel selection

These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).

Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>ADC analog channel-x is not monitored by AWD3</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>ADC analog channel-x is monitored by AWD3</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AWD3CH1</name>
              <description>Analog watchdog channel selection

These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).

Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>ADC analog channel-x is not monitored by AWD3</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>ADC analog channel-x is monitored by AWD3</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AWD3CH2</name>
              <description>Analog watchdog channel selection

These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).

Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>ADC analog channel-x is not monitored by AWD3</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>ADC analog channel-x is monitored by AWD3</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AWD3CH3</name>
              <description>Analog watchdog channel selection

These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).

Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>ADC analog channel-x is not monitored by AWD3</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>ADC analog channel-x is monitored by AWD3</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AWD3CH4</name>
              <description>Analog watchdog channel selection

These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).

Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>ADC analog channel-x is not monitored by AWD3</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>ADC analog channel-x is monitored by AWD3</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AWD3CH5</name>
              <description>Analog watchdog channel selection

These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).

Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>ADC analog channel-x is not monitored by AWD3</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>ADC analog channel-x is monitored by AWD3</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AWD3CH6</name>
              <description>Analog watchdog channel selection

These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).

Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>ADC analog channel-x is not monitored by AWD3</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>ADC analog channel-x is monitored by AWD3</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AWD3CH7</name>
              <description>Analog watchdog channel selection

These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).

Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>ADC analog channel-x is not monitored by AWD3</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>ADC analog channel-x is monitored by AWD3</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AWD3CH8</name>
              <description>Analog watchdog channel selection

These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).

Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>ADC analog channel-x is not monitored by AWD3</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>ADC analog channel-x is monitored by AWD3</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AWD3CH9</name>
              <description>Analog watchdog channel selection

These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).

Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>ADC analog channel-x is not monitored by AWD3</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>ADC analog channel-x is monitored by AWD3</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AWD3CH10</name>
              <description>Analog watchdog channel selection

These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).

Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>ADC analog channel-x is not monitored by AWD3</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>ADC analog channel-x is monitored by AWD3</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AWD3CH11</name>
              <description>Analog watchdog channel selection

These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).

Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>ADC analog channel-x is not monitored by AWD3</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>ADC analog channel-x is monitored by AWD3</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AWD3CH12</name>
              <description>Analog watchdog channel selection

These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).

Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>ADC analog channel-x is not monitored by AWD3</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>ADC analog channel-x is monitored by AWD3</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AWD3CH13</name>
              <description>Analog watchdog channel selection

These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).

Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>ADC analog channel-x is not monitored by AWD3</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>ADC analog channel-x is monitored by AWD3</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_CALFACT</name>
          <displayName>ADC_CALFACT</displayName>
          <description>ADC Calibration factor</description>
          <addressOffset>0xC4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CALFACT</name>
              <description>Calibration factor

These bits are written by hardware or by software.

Once a calibration is complete, they are updated by hardware with the calibration factors.

Software can write these bits with a new calibration factor. If the new calibration factor is different from the current one stored into the analog ADC, it is then applied once a new calibration is launched.

Just after a calibration is complete, DATA[6:0] contains the calibration factor.

Note: Software can write these bits only when ADEN = 1 (ADC is enabled and no calibration is ongoing and no conversion is ongoing).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_CCR</name>
          <displayName>ADC_CCR</displayName>
          <description>ADC common configuration register</description>
          <addressOffset>0x308</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRESC</name>
              <description>ADC prescaler

Set and cleared by software to select the frequency of the clock to the ADC. 

Other: Reserved

Note: Software is allowed to write these bits only when the ADC is disabled (ADCAL = 0, ADSTART = 0, ADSTP = 0, ADDIS = 0 and ADEN = 0).</description>
              <bitOffset>18</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>input ADC clock not divided</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>input ADC clock divided by 2</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>input ADC clock divided by 4</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>input ADC clock divided by 6</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>input ADC clock divided by 8</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>input ADC clock divided by 10</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x6</name>
                  <description>input ADC clock divided by 12</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7</name>
                  <description>input ADC clock divided by 16</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x8</name>
                  <description>input ADC clock divided by 32</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x9</name>
                  <description>input ADC clock divided by 64</description>
                  <value>0x9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xA</name>
                  <description>input ADC clock divided by 128</description>
                  <value>0xA</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xB</name>
                  <description>input ADC clock divided by 256</description>
                  <value>0xB</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VREFEN</name>
              <description>VsubREFINT/sub enable

This bit is set and cleared by software to enable/disable the VsubREFINT/sub buffer.

Note: Software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>VsubREFINT/sub disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>VsubREFINT/sub enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VSENSESEL</name>
              <description>Temperature sensor selection

This bit is set and cleared by software to enable/disable the temperature sensor.

Note: Software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing).</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Temperature sensor disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Temperature sensor enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>AES</name>
      <description>Advanced encryption standard hardware accelerator</description>
      <groupName>AES</groupName>
      <baseAddress>0x420C0000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x400</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>AES</name>
        <description>AES global interrupt</description>
        <value>58</value>
      </interrupt>
      <registers>
        <register>
          <name>AES_CR</name>
          <displayName>AES_CR</displayName>
          <description>AES control register</description>
          <addressOffset>0x000</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>Enable
This bit enables/disables the AES peripheral.
At any moment, clearing then setting the bit re-initializes the AES peripheral.
This bit is automatically cleared by hardware upon the completion of the key preparation (MODE[1:0] at 01) and upon the completion of GCM/GMAC/CCM initialization phase.
The bit cannot be set as long as KEYVALID=0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DATATYPE</name>
              <description>Data type
This bitfield defines the format of data written in the AES_DINR register or read from the AES_DOUTR register, through selecting the mode of data swapping. This swapping is defined in Section23.4.17: AES data registers and data swapping.
Attempts to write the bitfield are ignored when BUSY is set, as well as when EN is set before the write access and it is not cleared by that write access.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No swapping (32-bit data).</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Half-word swapping (16-bit data)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>Byte swapping (8-bit data)</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>Bit-level swapping</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MODE</name>
              <description>Operating mode
This bitfield selects the AES operating mode:
Attempts to write the bitfield are ignored when BUSY is set, as well as when EN is set before the write access and it is not cleared by that write access.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Encryption</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Key derivation (or key preparation), for ECB/CBC decryption only</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>Decryption</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CHMOD</name>
              <description>CHMOD[1:0]: Chaining mode
This bitfield selects the AES chaining mode:
others: Reserved
Attempts to write the bitfield are ignored when BUSY is set, as well as when EN is set before the write access and it is not cleared by that write access.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Electronic codebook (ECB)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Cipher-block chaining (CBC)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>Counter mode (CTR)</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>Galois counter mode (GCM) and Galois message authentication code (GMAC)</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DMAINEN</name>
              <description>DMA input enable
When this bit is set, DMA requests are automatically generated by the peripheral during the input data phase.
Setting this bit is ignored when MODE[1:0] is at 01 (key derivation).</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>DMA for incoming data transfer is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>DMA for incoming data transfer is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DMAOUTEN</name>
              <description>DMA output enable
When this bit is set, DMA requests are automatically generated by the peripheral during the output data phase.
Setting this bit is ignored when MODE[1:0] is at 01 (key derivation).</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>DMA for outgoing data transfer is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>DMA for outgoing data transfer is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>GCMPH</name>
              <description>GCM or CCM phase selection
This bitfield selects the phase, applicable only with GCM, GMAC or CCM chaining modes. This bitfield has no effect if GCM, GMAC or CCM algorithm is not selected with CHMOD[2:0].</description>
              <bitOffset>13</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Initialization phase</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Header phase</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>Payload phase</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>Final phase</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CHMOD_1</name>
              <description>CHMOD[2]</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>KEYSIZE</name>
              <description>Key size selection
This bitfield defines the key length in bits of the key used by AES.
Attempts to write the bit are ignored when BUSY is set, as well as when the EN is set before the write access and it is not cleared by that write access.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>128-bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>256-bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NPBLB</name>
              <description>Number of padding bytes in last block
This padding information must be filled by software before processing the last block of GCM payload encryption or CCM payload decryption, otherwise authentication tag computation is incorrect.
...</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>All bytes are valid (no padding)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Padding for the last LSB byte</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xF</name>
                  <description>Padding for the 15 LSB bytes of last block.</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>KMOD</name>
              <description>Key mode selection
The bitfield defines how the AES key can be used by the application. KEYSIZE must be correctly initialized when setting KMOD[1:0] different from zero.
Others: Reserved
Attempts to write the bitfield are ignored when BUSY is set, as well as when EN is set before the write access and it is not cleared by that write access.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Normal key mode. Key registers are freely usable.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>Shared key mode. If shared key mode is properly initialized in SAES peripheral, the AES peripheral automatically loads its key registers with the data stored in the SAES key registers. The key value is available in AES key registers when BUSY bit is cleared and KEYVALID is set in the AES_SR register. Key error flag KEIF is set otherwise in the AES_ISR register.</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IPRST</name>
              <description>AES peripheral software reset
Setting the bit resets the AES peripheral, putting all registers to their default values, except the IPRST bit itself. Hence, any key-relative data are lost. For this reason, it is recommended to set the bit before handing over the AES to a less secure application.
The bit must be low while writing any configuration registers.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AES_SR</name>
          <displayName>AES_SR</displayName>
          <description>AES status register</description>
          <addressOffset>0x004</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDERRF</name>
              <description>Read error flag
This bit is set when an unexpected read to the AES_DOUTR register occurred. When set RDERRF bit has no impact on the AES operations.
This flag is cleared by setting the RWEIF bit in AES_ICR register.
If RWEIE bit is set in AES_IER register an interrupt is generated when RDERRF is set. It is cleared by setting the RWEIF bit of the AES_ICR register.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Unexpected read to AES_DOUTR register occurred during computation or data input phase.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WRERRF</name>
              <description>Write error flag
This bit is set when an unexpected write to the AES_DINR register occurred. When set WRERRF bit has no impact on the AES operations.
This flag is cleared by setting the RWEIF bit in AES_ICR register.
If RWEIE bit is set in AES_IER register an interrupt is generated when WRERRF is set. It is cleared by setting the RWEIF bit of the AES_ICR register.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Unexpected write to AES_DINR register occurred during computation or data output phase.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BUSY</name>
              <description>Busy
This flag indicates whether AES is idle or busy.
AES is flagged as idle when disabled or when the last processing is completed.
AES is flagged as busy when processing a block data, preparing a key (ECB or CBC decryption only), or transferring a shared key from SAES peripheral.
When GCM encryption is selected, this flag must be at zero before suspending current process to manage a higher-priority message.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Idle</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Busy</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>KEYVALID</name>
              <description>Key valid flag
This bit is set by hardware when the key of size defined by KEYSIZE is loaded in AES_KEYRx key registers.
The EN bit can only be set when KEYVALID is set.
In normal mode when KEYSEL[2:0] is at 000, the key must be written in the key registers in the correct sequence, otherwise the KEIF flag is set and KEYVALID remains cleared.
When KEYSEL[2:0] is different from zero, the BUSY flag is automatically set by AES. When the key is loaded successfully, BUSY is cleared and KEYVALID set. Upon an error, KEIF is set, BUSY cleared and KEYVALID remains cleared.
If set, KEIF must be cleared through the AES_ICR register, otherwise KEYVALID cannot be set. See the KEIF flag description for more details.
For further information on key loading, refer to Section23.4.18: AES key registers.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Key not valid</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Key valid</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>AES_DINR</name>
          <displayName>AES_DINR</displayName>
          <description>AES data input register</description>
          <addressOffset>0x008</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DIN</name>
              <description>Input data word
A four-fold sequential write to this bitfield during the Input phase results in writing a complete 16-bytes block of input data to the AES peripheral. From the first to the fourth write, the corresponding data weights are [127:96], [95:64], [63:32], and [31:0]. Upon each write, the data from the 32-bit input buffer are handled by the data swap block according to the DATATYPE[1:0] bitfield, then written into the AES core 16-bytes input buffer.
Reads return zero.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AES_DOUTR</name>
          <displayName>AES_DOUTR</displayName>
          <description>AES data output register</description>
          <addressOffset>0x00C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DOUT</name>
              <description>Output data word
This read-only bitfield fetches a 32-bit output buffer. A four-fold sequential read of this bitfield, upon
the computation completion (CCF flag set), virtually reads a complete 16-byte block of output data from
the AES peripheral. Before reaching the output buffer, the data produced by the AES core are
handled by the data swap block according to the DATATYPE[1:0] bitfield.
Data weights from the first to the fourth read operation are: [127:96], [95:64], [63:32], and [31:0].</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AES_KEYR0</name>
          <displayName>AES_KEYR0</displayName>
          <description>AES key register 0</description>
          <addressOffset>0x010</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>KEY</name>
              <description>Cryptographic key, bits [31:0]
This write-only bitfield contains the bits [31:0] of the AES encryption or decryption key, depending on the operating mode MODE[1:0] in AES_CR.
The AES_KEYRx registers may be written only when KEYSIZE value is correct and when the AES peripheral is disabled (EN bit of the AES_CR register cleared). A special writing sequence is also required, as described in KEYVALID bit of the AES_SR register. Note that, if KMOD[1:0] is at 10 (shared key), the key is directly loaded from SAES peripheral to AES_KEYRx registers (hence writes to key register is ignored and KEIF is set).
When KEYVALID is set a write to this register clears KEYVALID if AES is disabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AES_KEYR1</name>
          <displayName>AES_KEYR1</displayName>
          <description>AES key register 1</description>
          <addressOffset>0x014</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>KEY</name>
              <description>Cryptographic key, bits [63:32]
Refer to the AES_KEYR0 register for description of the KEY[255:0] bitfield.
When KEYVALID is set in AES_SR a write to this register clears KEYVALID if EN is cleared in AES_CR.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AES_KEYR2</name>
          <displayName>AES_KEYR2</displayName>
          <description>AES key register 2</description>
          <addressOffset>0x018</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>KEY</name>
              <description>Cryptographic key, bits [95:64]
Refer to the AES_KEYR0 register for description of the KEY[255:0] bitfield.
When KEYVALID is set in AES_SR a write to this register clears KEYVALID if EN is cleared in AES_CR.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AES_KEYR3</name>
          <displayName>AES_KEYR3</displayName>
          <description>AES key register 3</description>
          <addressOffset>0x01C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>KEY</name>
              <description>Cryptographic key, bits [127:96]
Refer to the AES_KEYR0 register for description of the KEY[255:0] bitfield.
When KEYVALID is set in AES_SR a write to this register clears KEYVALID if EN is cleared in AES_CR.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AES_IVR0</name>
          <displayName>AES_IVR0</displayName>
          <description>AES initialization vector register 0</description>
          <addressOffset>0x020</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IVI</name>
              <description>Initialization vector input, bits [31:0]
AES_IVRx registers store the 128-bit initialization vector or the nonce, depending on the chaining mode selected. This value is updated by the AES core after each computation round (when applicable).
Write to this register is ignored when EN bit is set in AES_SR register</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AES_IVR1</name>
          <displayName>AES_IVR1</displayName>
          <description>AES initialization vector register 1</description>
          <addressOffset>0x024</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IVI</name>
              <description>Initialization vector input, bits [63:32]
Refer to the AES_IVR0 register for description of the IVI[128:0] bitfield.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AES_IVR2</name>
          <displayName>AES_IVR2</displayName>
          <description>AES initialization vector register 2</description>
          <addressOffset>0x028</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IVI</name>
              <description>Initialization vector input, bits [95:64]
Refer to the AES_IVR0 register for description of the IVI[128:0] bitfield.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AES_IVR3</name>
          <displayName>AES_IVR3</displayName>
          <description>AES initialization vector register 3</description>
          <addressOffset>0x02C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IVI</name>
              <description>Initialization vector input, bits [127:96]
Refer to the AES_IVR0 register for description of the IVI[128:0] bitfield.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AES_KEYR4</name>
          <displayName>AES_KEYR4</displayName>
          <description>AES key register 4</description>
          <addressOffset>0x030</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>KEY</name>
              <description>Cryptographic key, bits [159:128]
Refer to the AES_KEYR0 register for description of the KEY[255:0] bitfield. 
Writing to this register has no effect when key size is 128-bit (KEYSIZE=0). When KEYVALID is set in AES_SR a write to this register clears KEYVALID if EN is cleared in AES_CR.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AES_KEYR5</name>
          <displayName>AES_KEYR5</displayName>
          <description>AES key register 5</description>
          <addressOffset>0x034</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>KEY</name>
              <description>Cryptographic key, bits [191:160]
Refer to the AES_KEYR0 register for description of the KEY[255:0] bitfield.
Writing to this register has no effect when key size is 128-bit (KEYSIZE=0). When KEYVALID is set in AES_SR a write to this register clears KEYVALID if EN is cleared in AES_CR.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AES_KEYR6</name>
          <displayName>AES_KEYR6</displayName>
          <description>AES key register 6</description>
          <addressOffset>0x038</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>KEY</name>
              <description>Cryptographic key, bits [223:192]
Refer to the AES_KEYR0 register for description of the KEY[255:0] bitfield.
Writing to this register has no effect when key size is 128-bit (KEYSIZE=0). When KEYVALID is set in AES_SR a write to this register clears KEYVALID if EN is cleared in AES_CR.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AES_KEYR7</name>
          <displayName>AES_KEYR7</displayName>
          <description>AES key register 7</description>
          <addressOffset>0x03C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>KEY</name>
              <description>Cryptographic key, bits [255:224]
Refer to the AES_KEYR0 register for description of the KEY[255:0] bitfield.
Writing to this register has no effect when key size is 128-bit (KEYSIZE=0). When KEYVALID is set in AES_SR a write to this register clears KEYVALID if EN is cleared in AES_CR.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AES_SUSPR0</name>
          <displayName>AES_SUSPR0</displayName>
          <description>AES suspend registers</description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SUSP</name>
              <description>Suspend data
AES_SUSPRx registers contain the complete internal register states of the AES when the GCM, GMAC or CCM processing of the current task is suspended to process a higher-priority task. Refer to Section23.4.8: AES suspend and resume operations for more details.
Read to this register returns zero when EN bit is cleared in AES_SR register.
AES_SUSPRx registers are not used in other chaining modes than GCM, GMAC or CCM.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AES_SUSPR1</name>
          <displayName>AES_SUSPR1</displayName>
          <description>AES suspend registers</description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SUSP</name>
              <description>Suspend data
AES_SUSPRx registers contain the complete internal register states of the AES when the GCM, GMAC or CCM processing of the current task is suspended to process a higher-priority task. Refer to Section23.4.8: AES suspend and resume operations for more details.
Read to this register returns zero when EN bit is cleared in AES_SR register.
AES_SUSPRx registers are not used in other chaining modes than GCM, GMAC or CCM.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AES_SUSPR2</name>
          <displayName>AES_SUSPR2</displayName>
          <description>AES suspend registers</description>
          <addressOffset>0x48</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SUSP</name>
              <description>Suspend data
AES_SUSPRx registers contain the complete internal register states of the AES when the GCM, GMAC or CCM processing of the current task is suspended to process a higher-priority task. Refer to Section23.4.8: AES suspend and resume operations for more details.
Read to this register returns zero when EN bit is cleared in AES_SR register.
AES_SUSPRx registers are not used in other chaining modes than GCM, GMAC or CCM.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AES_SUSPR3</name>
          <displayName>AES_SUSPR3</displayName>
          <description>AES suspend registers</description>
          <addressOffset>0x4C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SUSP</name>
              <description>Suspend data
AES_SUSPRx registers contain the complete internal register states of the AES when the GCM, GMAC or CCM processing of the current task is suspended to process a higher-priority task. Refer to Section23.4.8: AES suspend and resume operations for more details.
Read to this register returns zero when EN bit is cleared in AES_SR register.
AES_SUSPRx registers are not used in other chaining modes than GCM, GMAC or CCM.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AES_SUSPR4</name>
          <displayName>AES_SUSPR4</displayName>
          <description>AES suspend registers</description>
          <addressOffset>0x50</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SUSP</name>
              <description>Suspend data
AES_SUSPRx registers contain the complete internal register states of the AES when the GCM, GMAC or CCM processing of the current task is suspended to process a higher-priority task. Refer to Section23.4.8: AES suspend and resume operations for more details.
Read to this register returns zero when EN bit is cleared in AES_SR register.
AES_SUSPRx registers are not used in other chaining modes than GCM, GMAC or CCM.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AES_SUSPR5</name>
          <displayName>AES_SUSPR5</displayName>
          <description>AES suspend registers</description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SUSP</name>
              <description>Suspend data
AES_SUSPRx registers contain the complete internal register states of the AES when the GCM, GMAC or CCM processing of the current task is suspended to process a higher-priority task. Refer to Section23.4.8: AES suspend and resume operations for more details.
Read to this register returns zero when EN bit is cleared in AES_SR register.
AES_SUSPRx registers are not used in other chaining modes than GCM, GMAC or CCM.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AES_SUSPR6</name>
          <displayName>AES_SUSPR6</displayName>
          <description>AES suspend registers</description>
          <addressOffset>0x58</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SUSP</name>
              <description>Suspend data
AES_SUSPRx registers contain the complete internal register states of the AES when the GCM, GMAC or CCM processing of the current task is suspended to process a higher-priority task. Refer to Section23.4.8: AES suspend and resume operations for more details.
Read to this register returns zero when EN bit is cleared in AES_SR register.
AES_SUSPRx registers are not used in other chaining modes than GCM, GMAC or CCM.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AES_SUSPR7</name>
          <displayName>AES_SUSPR7</displayName>
          <description>AES suspend registers</description>
          <addressOffset>0x5C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SUSP</name>
              <description>Suspend data
AES_SUSPRx registers contain the complete internal register states of the AES when the GCM, GMAC or CCM processing of the current task is suspended to process a higher-priority task. Refer to Section23.4.8: AES suspend and resume operations for more details.
Read to this register returns zero when EN bit is cleared in AES_SR register.
AES_SUSPRx registers are not used in other chaining modes than GCM, GMAC or CCM.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AES_IER</name>
          <displayName>AES_IER</displayName>
          <description>AES interrupt enable register</description>
          <addressOffset>0x300</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CCFIE</name>
              <description>Computation complete flag interrupt enable
This bit enables or disables (masks) the AES interrupt generation when CCF (computation complete flag) is set.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Disabled (masked)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Enabled (not masked)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RWEIE</name>
              <description>Read or write error interrupt enable
This bit enables or disables (masks) the AES interrupt generation when RWEIF (read and/or write error flag) is set.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Disabled (masked)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Enabled (not masked)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>KEIE</name>
              <description>Key error interrupt enable
This bit enables or disables (masks) the AES interrupt generation when KEIF (key error flag) is set.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Disabled (masked)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Enabled (not masked)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>AES_ISR</name>
          <displayName>AES_ISR</displayName>
          <description>AES interrupt status register</description>
          <addressOffset>0x304</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CCF</name>
              <description>Computation complete flag
This flag indicates whether the computation is completed. It is significant only when the DMAOUTEN bit is cleared, and it may stay high when DMAOUTEN is set.
CCF bit is cleared when application sets the corresponding bit of AES_ICR register. An interrupt is generated if the CCFIE bit has been previously set in the AES_IER register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Not completed</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Completed</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RWEIF</name>
              <description>Read or write error interrupt flag
This read-only bit is set by hardware when a RDERRF or a WRERRF error flag is set in the AES_SR register.
RWEIF bit is cleared when application sets the corresponding bit of AES_ICR register. An interrupt is generated if the RWEIE bit has been previously set in the AES_IER register.
This flags has no meaning when key derivation mode is selected.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No read or write error detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Read or write error detected (see AES_SR register for details)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>KEIF</name>
              <description>Key error interrupt flag
This read-only bit is set by hardware when key information failed to load into key registers.
Setting the corresponding bit of the AES_ICR register clears the KEIF and generates interrupt if the KEIE bit of the AES_IER register is set.
KEIF is triggered upon any of the following errors:
AES_KEYRx register write does not respect the correct order. (For KEYSIZE=0, AES_KEYR0 then AES_KEYR1 then AES_KEYR2 then AES_KEYR3 register, or reverse. For KEYSIZE set, AES_KEYR0 then AES_KEYR1 then AES_KEYR2 then AES_KEYR3 then AES_KEYR4 then AES_KEYR5 then AES_KEYR6 then AES_KEYR7, or reverse).
KEIF must be cleared by the application software, otherwise KEYVALID cannot be set.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No key error detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Key information failed to load into key registers</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>AES_ICR</name>
          <displayName>AES_ICR</displayName>
          <description>AES interrupt clear register</description>
          <addressOffset>0x308</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CCF</name>
              <description>Computation complete flag clear
Setting this bit clears the CCF status bit of the AES_ISR register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>RWEIF</name>
              <description>Read or write error interrupt flag clear
Setting this bit clears the RWEIF status bit of the AES_ISR register, and clears both RDERRF and WRERRF flags in the AES_SR register.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>KEIF</name>
              <description>Key error interrupt flag clear
Setting this bit clears the KEIF status bit of the AES_ISR register.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CRC</name>
      <description>CRC register block</description>
      <groupName>CRC</groupName>
      <baseAddress>0x40023000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x18</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CRC_DR</name>
          <displayName>CRC_DR</displayName>
          <description>CRC data register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DR</name>
              <description>Data register bits
This register is used to write new data to the CRC calculator.
It holds the previous CRC calculation result when it is read.
If the data size is less than 32 bits, the least significant bits are used to write/read the correct value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_IDR</name>
          <displayName>CRC_IDR</displayName>
          <description>CRC independent data register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IDR</name>
              <description>General-purpose 32-bit data register bits
These bits can be used as a temporary storage location for four bytes.
This register is not affected by CRC resets generated by the RESET bit in the CRC_CR register</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_CR</name>
          <displayName>CRC_CR</displayName>
          <description>CRC control register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RESET</name>
              <description>RESET bit
This bit is set by software to reset the CRC calculation unit and set the data register to the value stored in the CRC_INIT register. This bit can only be set, it is automatically cleared by hardware</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>POLYSIZE</name>
              <description>Polynomial size
These bits control the size of the polynomial.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>32 bit polynomial</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>16 bit polynomial</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>8 bit polynomial</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>7 bit polynomial</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>REV_IN</name>
              <description>Reverse input data
These bits control the reversal of the bit order of the input data</description>
              <bitOffset>5</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Bit order not affected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Bit reversal done by byte</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>Bit reversal done by half-word</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>Bit reversal done by word</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>REV_OUT</name>
              <description>Reverse output data

This bit controls the reversal of the bit order of the output data.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Bit order not affected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Bit-reversed output format</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_INIT</name>
          <displayName>CRC_INIT</displayName>
          <description>CRC initial value</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CRC_INIT</name>
              <description>Programmable initial CRC value

This register is used to write the CRC initial value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_POL</name>
          <displayName>CRC_POL</displayName>
          <description>CRC polynomial</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x04C11DB7</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>POL</name>
              <description>Programmable polynomial 

This register is used to write the coefficients of the polynomial to be used for CRC calculation.

If the polynomial size is less than 32 bits, the least significant bits have to be used to program the correct value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>DBGMCU</name>
      <description>DBGMCU address block description</description>
      <groupName>DBGMCU</groupName>
      <baseAddress>0xE0044000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>DBGMCU_IDCODER</name>
          <displayName>DBGMCU_IDCODER</displayName>
          <description>DBGMCU identity code register</description>
          <addressOffset>0x000</addressOffset>
          <size>0x20</size>
          <access>read-only</access>
          <resetValue>0x00006492</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>DEV_ID</name>
              <description>Device ID</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x492</name>
                  <description>STM32WBA5xxx</description>
                  <value>0x492</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>REV_ID</name>
              <description>Revision ID</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x1000</name>
                  <description>Revision A</description>
                  <value>0x1000</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DBGMCU_SCR</name>
          <displayName>DBGMCU_SCR</displayName>
          <description>DBGMCU status and configuration register</description>
          <addressOffset>0x004</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DBG_STOP</name>
              <description>Allows debug in Stop mode

Write access can be protected by PWR_SECCFGR.LPMSEC.

The CPU debug and DBGMCU clocks remain active and the HSI16 oscillators is used as system clock during Stop debug mode, allowing CPU debug capability. On exit from Stop mode, the clock settings are set to the Stop mode exit state.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Normal Stop mode operation, all clocks are disabled automatically in Stop mode.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>CPU debug clock enabled in Stop mode, all other peripheral clocks are disabled automatically in Stop mode, except for DBGMCU.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DBG_STANDBY</name>
              <description>Allows debug in Standby mode

Write access can be protected by PWR_SECCFGR.LPMSEC.

The CPU debug and DBGMCU clocks remain active and the HSI16 oscillator is used as system clock, the supply and SRAM memory content is maintained during Standby debug mode, allowing CPU debug capability. On exit from Standby mode, a standby reset is performed.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Normal Standby mode operation, all clocks are disabled automatically in Stop mode and core is powered down.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Core power maintained and CPU debug clock enabled in Standby mode, all other are under reset in Stop mode, except for DBGMCU.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LPMS</name>
              <description>Device low power mode selected

10x: Standby mode

others reserved</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Stop 0 mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Stop 1 mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>STOPF</name>
              <description>Device Stop flag</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>device not in Stop mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>device in Stop mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SBF</name>
              <description>Device Standby flag</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Device not in Standby mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Device in Standby mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CS</name>
              <description>CPU Sleep</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>CPU not in Sleep</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>CPU in Sleep</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CDS</name>
              <description>CPU DeepSleep</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>CPU not in DeepSleep</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>CPU in DeepSleep</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DBGMCU_APB1LFZR</name>
          <displayName>DBGMCU_APB1LFZR</displayName>
          <description>DBGMCU APB1L peripheral freeze register</description>
          <addressOffset>0x008</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DBG_TIM2_STOP</name>
              <description>TIM2 stop in CPU debug

Write access can be protected by GTZC_TZSC.TIM2SEC.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Normal operation. TIM2 continues to operate while CPU is in debug mode.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Stop in debug. TIM2 is frozen while CPU is in debug mode.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DBG_TIM3_STOP</name>
              <description>TIM3 stop in CPU debug

Write access can be protected by GTZC_TZSC.TIM3SEC.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Normal operation. TIM3 continues to operate while CPU is in debug mode.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Stop in debug. TIM3 is frozen while CPU is in debug mode.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DBG_WWDG_STOP</name>
              <description>WWDG stop in CPU debug

Write access can be protected by GTZC_TZSC.WWDGSEC</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Normal operation. WWDG continues to operate while CPU is in debug mode.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Stop in debug. WWDG is frozen while CPU is in debug mode.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DBG_IWDG_STOP</name>
              <description>IWDG stop in CPU debug

Write access can be protected by GTZC_TZSC.IWDGSEC.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Normal operation. IWDG continues to operate while CPU is in debug mode.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Stop in debug. IWDG is frozen while CPU is in debug mode.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DBG_I2C1_STOP</name>
              <description>I2C1 SMBUS timeout stop in CPU debug

Write access can be protected by GTZC_TZSC.I2C1SEC.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Normal operation. I2C1 SMBUS timeout continues to operate while CPU is in debug mode.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Stop in debug. I2C1 SMBUS timeout is frozen while CPU is in debug mode.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DBGMCU_APB1HFZR</name>
          <displayName>DBGMCU_APB1HFZR</displayName>
          <description>DBGMCU APB1H peripheral freeze register</description>
          <addressOffset>0x00C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DBG_LPTIM2_STOP</name>
              <description>LPTIM2 stop in CPU debug

Write access can be protected by GTZC_TZSC.LPTIM2SEC.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Normal operation. LPTIM2 continues to operate while CPU is in debug mode.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Stop in debug. LPTIM2 is frozen while CPU is in debug mode.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DBGMCU_APB2FZR</name>
          <displayName>DBGMCU_APB2FZR</displayName>
          <description>DBGMCU APB2 peripheral freeze register</description>
          <addressOffset>0x010</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DBG_TIM1_STOP</name>
              <description>TIM1 stop in CPU debug

Write access can be protected by GTZC_TZSC.TIM1SEC.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Normal operation. TIM1 continues to operate while CPU is in debug mode.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Stop in debug. TIM1 is frozen while CPU is in debug mode.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DBG_TIM16_STOP</name>
              <description>TIM16 stop in CPU debug

Write access can be protected by GTZC_TZSC.TIM16SEC.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Normal operation. TIM16 continues to operate while CPU is in debug mode.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Stop in debug. TIM16 is frozen while CPU is in debug mode.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DBG_TIM17_STOP</name>
              <description>TIM17 stop in CPU debug

Write access can be protected by GTZC_TZSC.TIM17SEC.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Normal operation. TIM17 continues to operate while CPU is in debug mode.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Stop in debug. TIM17 is frozen while CPU is in debug mode.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DBGMCU_APB7FZR</name>
          <displayName>DBGMCU_APB7FZR</displayName>
          <description>DBGMCU APB7 peripheral freeze register</description>
          <addressOffset>0x024</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DBG_I2C3_STOP</name>
              <description>I2C3 stop in CPU debug

Access can be protected by GTZC_TZSC.I2C3SEC.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Normal operation. I2C3 continues to operate while CPU is in debug mode.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Stop in debug. I2C3 is frozen while CPU is in debug mode.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DBG_LPTIM1_STOP</name>
              <description>LPTIM1 stop in CPU debug

Access can be protected by GTZC_TZSC.LPTIM1SEC.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Normal operation. LPTIM1 continues to operate while CPU is in debug mode.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Stop in debug. LPTIM1 is frozen while CPU is in debug mode.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DBG_RTC_STOP</name>
              <description>RTC stop in CPU debug

Access can be protected by GTZC_TZSC.TIM17SEC.

Can only be accessed secure when one or more features in the RTC or TAMP is/are secure.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Normal operation. RTC continues to operate while CPU is in debug mode.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Stop in debug. RTC is frozen while CPU is in debug mode.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DBGMCU_AHB1FZR</name>
          <displayName>DBGMCU_AHB1FZR</displayName>
          <description>DBGMCU AHB1 peripheral freeze register</description>
          <addressOffset>0x028</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DBG_GPDMA1_CH0_STOP</name>
              <description>GPDMA 1 channel 0 stop in CPU debug

Write access can be protected by GPDMA_SECCFGR.SEC0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Normal operation. GPDMA 1 channel 0 continues to operate while CPU is in debug mode.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Stop in debug. GPDMA 1 channel 0 is frozen while CPU is in debug mode.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DBG_GPDMA1_CH1_STOP</name>
              <description>GPDMA 1 channel 1 stop in CPU debug

Write access can be protected by GPDMA_SECCFGR.SEC1.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Normal operation. GPDMA 1 channel 1 continues to operate while CPU is in debug mode.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Stop in debug. GPDMA 1 channel 1 is frozen while CPU is in debug mode.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DBG_GPDMA1_CH2_STOP</name>
              <description>GPDMA 1 channel 2 stop in CPU debug

Write access can be protected by GPDMA_SECCFGR.SEC2.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Normal operation. GPDMA 1 channel 2 continues to operate while CPU is in debug mode.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Stop in debug. GPDMA 1 channel 2 is frozen while CPU is in debug mode.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DBG_GPDMA1_CH3_STOP</name>
              <description>GPDMA 1 channel 3 stop in CPU debug

Write access can be protected by GPDMA_SECCFGR.SEC3.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Normal operation. GPDMA 1 channel 3 continues to operate while CPU is in debug mode.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Stop in debug. GPDMA 1 channel 3 is frozen while CPU is in debug mode.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DBG_GPDMA1_CH4_STOP</name>
              <description>GPDMA 1 channel 4 stop in CPU debug

Write access can be protected by GPDMA_SECCFGR.SEC4.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Normal operation. GPDMA 1 channel 4 continues to operate while CPU is in debug mode.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Stop in debug. GPDMA 1 channel 4 is frozen while CPU is in debug mode.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DBG_GPDMA1_CH5_STOP</name>
              <description>GPDMA 1 channel 5 stop in CPU debug

Write access can be protected by GPDMA_SECCFGR.SEC5.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Normal operation. GPDMA 1 channel 5 continues to operate while CPU is in debug mode.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Stop in debug. GPDMA 1 channel 5 is frozen while CPU is in debug mode.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DBG_GPDMA1_CH6_STOP</name>
              <description>GPDMA 1 channel 6 stop in CPU debug

Write access can be protected by GPDMA_SECCFGR.SEC6.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Normal operation. GPDMA 1 channel 6 continues to operate while CPU is in debug mode.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Stop in debug. GPDMA 1 channel 6 is frozen while CPU is in debug mode.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DBG_GPDMA1_CH7_STOP</name>
              <description>GPDMA 1 channel 7 stop in CPU debug

Write access can be protected by GPDMA_SECCFGR.SEC7.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Normal operation. GPDMA 1 channel 7 continues to operate while CPU is in debug mode.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Stop in debug. GPDMA 1 channel 7 is frozen while CPU is in debug mode.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DBGMCU_SR</name>
          <displayName>DBGMCU_SR</displayName>
          <description>DBGMCU status register</description>
          <addressOffset>0x0FC</addressOffset>
          <size>0x20</size>
          <access>read-only</access>
          <resetValue>0x00000003</resetValue>
          <resetMask>0xFFF0FFFF</resetMask>
          <fields>
            <field>
              <name>AP_PRESENT</name>
              <description>Bit n identifies whether access port APn is present in device 

Bit n = 0: APn absent 

Bit n = 1: APn present</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>AP_ENABLED</name>
              <description>Bit n identifies whether access port APn is open (can be accessed via the debug port) or locked (debug access to the APn is blocked, except for DBGMCU access) 

Bit n = 0: APn locked (except for access to DBGMCU)

Bit n = 1: APn enabled</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DBGMCU_DBG_AUTH_HOST</name>
          <displayName>DBGMCU_DBG_AUTH_HOST</displayName>
          <description>DBGMCU debug host authentication register</description>
          <addressOffset>0x100</addressOffset>
          <size>0x20</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>AUTH_KEY</name>
              <description>Device authentication key

The device specific 64-bit authentication key (OEMn key) must be written to this register (in two successive 32-bit writes, least significant word first) to permit RDP regression. Writing a wrong key locks access to the device and prevent code execution from the Flash memory.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DBGMCU_DBG_AUTH_DEVICE</name>
          <displayName>DBGMCU_DBG_AUTH_DEVICE</displayName>
          <description>DBGMCU debug device authentication register</description>
          <addressOffset>0x104</addressOffset>
          <size>0x20</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>AUTH_ID</name>
              <description>Device specific ID

Device specific ID used for RDP regression.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DBGMCU_PNCR</name>
          <displayName>DBGMCU_PNCR</displayName>
          <description>DBGMCU part number codification register</description>
          <addressOffset>0x7DC</addressOffset>
          <size>0x20</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>CODIFICATION</name>
              <description>Part number codification</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x00323541</name>
                  <description>STMicroelectronics STM32WBA52xx part number codification.</description>
                  <value>0x00323541</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DBGMCU_PIDR4</name>
          <displayName>DBGMCU_PIDR4</displayName>
          <description>DBGMCU CoreSight peripheral identity register 4</description>
          <addressOffset>0xFD0</addressOffset>
          <size>0x20</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>JEP106CON</name>
              <description>JEP106 continuation code</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>STMicroelectronics JEDEC code</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>F4KCOUNT</name>
              <description>Register file size</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>The register file occupies a single 4-Kbyte region</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DBGMCU_PIDR0</name>
          <displayName>DBGMCU_PIDR0</displayName>
          <description>DBGMCU CoreSight peripheral identity register 0</description>
          <addressOffset>0xFE0</addressOffset>
          <size>0x20</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PARTNUM</name>
              <description>Part number bits [7:0]</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x00</name>
                  <description>DBGMCU part number</description>
                  <value>0x00</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DBGMCU_PIDR1</name>
          <displayName>DBGMCU_PIDR1</displayName>
          <description>DBGMCU CoreSight peripheral identity register 1</description>
          <addressOffset>0xFE4</addressOffset>
          <size>0x20</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PARTNUM</name>
              <description>Part number bits [11:8]</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>DBGMCU part number</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>JEP106ID</name>
              <description>JEP106 identity code bits [3:0]</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>STMicroelectronics JEDEC code</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DBGMCU_PIDR2</name>
          <displayName>DBGMCU_PIDR2</displayName>
          <description>DBGMCU CoreSight peripheral identity register 2</description>
          <addressOffset>0xFE8</addressOffset>
          <size>0x20</size>
          <access>read-only</access>
          <resetValue>0x0000000A</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>JEP106ID</name>
              <description>JEP106 identity code bits [6:4]</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>STMicroelectronics JEDEC code</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>JEDEC</name>
              <description>JEDEC assigned value</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Designer identifier specified by JEDEC</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>REVISION</name>
              <description>Component revision number</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>r0p0</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DBGMCU_PIDR3</name>
          <displayName>DBGMCU_PIDR3</displayName>
          <description>DBGMCU CoreSight peripheral identity register 3</description>
          <addressOffset>0xFEC</addressOffset>
          <size>0x20</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMOD</name>
              <description>Customer modified</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No customer modifications</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>REVAND</name>
              <description>Metal fix version</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No metal fix</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DBGMCU_CIDR0</name>
          <displayName>DBGMCU_CIDR0</displayName>
          <description>DBGMCU CoreSight component identity register 0</description>
          <addressOffset>0xFF0</addressOffset>
          <size>0x20</size>
          <access>read-only</access>
          <resetValue>0x0000000D</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PREAMBLE</name>
              <description>Component ID bits [7:0]</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0D</name>
                  <description>Common ID value</description>
                  <value>0x0D</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DBGMCU_CIDR1</name>
          <displayName>DBGMCU_CIDR1</displayName>
          <description>DBGMCU CoreSight peripheral identity register 1</description>
          <addressOffset>0xFF4</addressOffset>
          <size>0x20</size>
          <access>read-only</access>
          <resetValue>0x000000F0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PREAMBLE</name>
              <description>Component ID bits [11:8]</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>common ID value</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLASS</name>
              <description>Component ID bits [15:12] - component class</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0xF</name>
                  <description>no CoreSight component</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DBGMCU_CIDR2</name>
          <displayName>DBGMCU_CIDR2</displayName>
          <description>DBGMCU CoreSight component identity register 2</description>
          <addressOffset>0xFF8</addressOffset>
          <size>0x20</size>
          <access>read-only</access>
          <resetValue>0x00000005</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PREAMBLE</name>
              <description>Component ID bits [23:16]</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x05</name>
                  <description>Common ID value</description>
                  <value>0x05</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DBGMCU_CIDR3</name>
          <displayName>DBGMCU_CIDR3</displayName>
          <description>DBGMCU CoreSight component identity register 3</description>
          <addressOffset>0xFFC</addressOffset>
          <size>0x20</size>
          <access>read-only</access>
          <resetValue>0x000000B1</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PREAMBLE</name>
              <description>Component ID bits [31:24]</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0xB1</name>
                  <description>Common ID value</description>
                  <value>0xB1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>EXTI</name>
      <description>External interrupt/event controller</description>
      <groupName>EXTI</groupName>
      <baseAddress>0x46022000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x400</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>PDV</name>
        <description>Power voltage monitor</description>
        <value>001</value>
      </interrupt>
      <interrupt>
        <name>EXTI0</name>
        <description>EXTI line0 interrupt</description>
        <value>011</value>
      </interrupt>
      <interrupt>
        <name>EXTI1</name>
        <description>EXTI line1 interrupt</description>
        <value>012</value>
      </interrupt>
      <interrupt>
        <name>EXTI2</name>
        <description>EXTI line2 interrupt</description>
        <value>013</value>
      </interrupt>
      <interrupt>
        <name>EXTI3</name>
        <description>EXTI line3 interrupt</description>
        <value>014</value>
      </interrupt>
      <interrupt>
        <name>EXTI4</name>
        <description>EXTI line4 interrupt</description>
        <value>015</value>
      </interrupt>
      <interrupt>
        <name>EXTI5</name>
        <description>EXTI line5 interrupt</description>
        <value>016</value>
      </interrupt>
      <interrupt>
        <name>EXTI6</name>
        <description>EXTI line6 interrupt</description>
        <value>017</value>
      </interrupt>
      <interrupt>
        <name>EXTI7</name>
        <description>EXTI line7 interrupt</description>
        <value>018</value>
      </interrupt>
      <interrupt>
        <name>EXTI8</name>
        <description>EXTI line8 interrupt</description>
        <value>019</value>
      </interrupt>
      <interrupt>
        <name>EXTI9</name>
        <description>EXTI line9 interrupt</description>
        <value>020</value>
      </interrupt>
      <interrupt>
        <name>EXTI10</name>
        <description>EXTI line10 interrupt</description>
        <value>021</value>
      </interrupt>
      <interrupt>
        <name>EXTI11</name>
        <description>EXTI line11 interrupt</description>
        <value>022</value>
      </interrupt>
      <interrupt>
        <name>EXTI12</name>
        <description>EXTI line12 interrupt</description>
        <value>023</value>
      </interrupt>
      <interrupt>
        <name>EXTI13</name>
        <description>EXTI line13 interrupt</description>
        <value>024</value>
      </interrupt>
      <interrupt>
        <name>EXTI14</name>
        <description>EXTI line14 interrupt</description>
        <value>025</value>
      </interrupt>
      <interrupt>
        <name>EXTI15</name>
        <description>EXTI line15 interrupt</description>
        <value>026</value>
      </interrupt>
      <registers>
        <register>
          <name>EXTI_RTSR1</name>
          <displayName>EXTI_RTSR1</displayName>
          <description>EXTI rising trigger selection register</description>
          <addressOffset>0x000</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RT0</name>
              <description>Rising trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Rising trigger disabled (for event and interrupt) for input line</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Rising trigger enabled (for event and interrupt) for input line</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RT1</name>
              <description>Rising trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Rising trigger disabled (for event and interrupt) for input line</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Rising trigger enabled (for event and interrupt) for input line</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RT2</name>
              <description>Rising trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Rising trigger disabled (for event and interrupt) for input line</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Rising trigger enabled (for event and interrupt) for input line</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RT3</name>
              <description>Rising trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Rising trigger disabled (for event and interrupt) for input line</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Rising trigger enabled (for event and interrupt) for input line</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RT4</name>
              <description>Rising trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Rising trigger disabled (for event and interrupt) for input line</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Rising trigger enabled (for event and interrupt) for input line</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RT5</name>
              <description>Rising trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Rising trigger disabled (for event and interrupt) for input line</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Rising trigger enabled (for event and interrupt) for input line</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RT6</name>
              <description>Rising trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Rising trigger disabled (for event and interrupt) for input line</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Rising trigger enabled (for event and interrupt) for input line</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RT7</name>
              <description>Rising trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Rising trigger disabled (for event and interrupt) for input line</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Rising trigger enabled (for event and interrupt) for input line</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RT8</name>
              <description>Rising trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Rising trigger disabled (for event and interrupt) for input line</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Rising trigger enabled (for event and interrupt) for input line</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RT9</name>
              <description>Rising trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Rising trigger disabled (for event and interrupt) for input line</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Rising trigger enabled (for event and interrupt) for input line</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RT10</name>
              <description>Rising trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Rising trigger disabled (for event and interrupt) for input line</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Rising trigger enabled (for event and interrupt) for input line</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RT11</name>
              <description>Rising trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Rising trigger disabled (for event and interrupt) for input line</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Rising trigger enabled (for event and interrupt) for input line</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RT12</name>
              <description>Rising trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Rising trigger disabled (for event and interrupt) for input line</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Rising trigger enabled (for event and interrupt) for input line</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RT13</name>
              <description>Rising trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Rising trigger disabled (for event and interrupt) for input line</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Rising trigger enabled (for event and interrupt) for input line</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RT14</name>
              <description>Rising trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Rising trigger disabled (for event and interrupt) for input line</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Rising trigger enabled (for event and interrupt) for input line</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RT15</name>
              <description>Rising trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Rising trigger disabled (for event and interrupt) for input line</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Rising trigger enabled (for event and interrupt) for input line</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RT16</name>
              <description>Rising trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Rising trigger disabled (for event and interrupt) for input line</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Rising trigger enabled (for event and interrupt) for input line</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>EXTI_FTSR1</name>
          <displayName>EXTI_FTSR1</displayName>
          <description>EXTI falling trigger selection register</description>
          <addressOffset>0x004</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FT0</name>
              <description>Falling trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Falling trigger disabled (for event and Interrupt) for input line</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Falling trigger enabled (for event and Interrupt) for input line.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FT1</name>
              <description>Falling trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Falling trigger disabled (for event and Interrupt) for input line</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Falling trigger enabled (for event and Interrupt) for input line.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FT2</name>
              <description>Falling trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Falling trigger disabled (for event and Interrupt) for input line</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Falling trigger enabled (for event and Interrupt) for input line.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FT3</name>
              <description>Falling trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Falling trigger disabled (for event and Interrupt) for input line</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Falling trigger enabled (for event and Interrupt) for input line.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FT4</name>
              <description>Falling trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Falling trigger disabled (for event and Interrupt) for input line</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Falling trigger enabled (for event and Interrupt) for input line.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FT5</name>
              <description>Falling trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Falling trigger disabled (for event and Interrupt) for input line</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Falling trigger enabled (for event and Interrupt) for input line.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FT6</name>
              <description>Falling trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Falling trigger disabled (for event and Interrupt) for input line</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Falling trigger enabled (for event and Interrupt) for input line.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FT7</name>
              <description>Falling trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Falling trigger disabled (for event and Interrupt) for input line</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Falling trigger enabled (for event and Interrupt) for input line.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FT8</name>
              <description>Falling trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Falling trigger disabled (for event and Interrupt) for input line</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Falling trigger enabled (for event and Interrupt) for input line.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FT9</name>
              <description>Falling trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Falling trigger disabled (for event and Interrupt) for input line</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Falling trigger enabled (for event and Interrupt) for input line.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FT10</name>
              <description>Falling trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Falling trigger disabled (for event and Interrupt) for input line</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Falling trigger enabled (for event and Interrupt) for input line.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FT11</name>
              <description>Falling trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Falling trigger disabled (for event and Interrupt) for input line</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Falling trigger enabled (for event and Interrupt) for input line.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FT12</name>
              <description>Falling trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Falling trigger disabled (for event and Interrupt) for input line</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Falling trigger enabled (for event and Interrupt) for input line.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FT13</name>
              <description>Falling trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Falling trigger disabled (for event and Interrupt) for input line</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Falling trigger enabled (for event and Interrupt) for input line.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FT14</name>
              <description>Falling trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Falling trigger disabled (for event and Interrupt) for input line</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Falling trigger enabled (for event and Interrupt) for input line.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FT15</name>
              <description>Falling trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Falling trigger disabled (for event and Interrupt) for input line</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Falling trigger enabled (for event and Interrupt) for input line.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FT16</name>
              <description>Falling trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Falling trigger disabled (for event and Interrupt) for input line</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Falling trigger enabled (for event and Interrupt) for input line.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>EXTI_SWIER1</name>
          <displayName>EXTI_SWIER1</displayName>
          <description>EXTI software interrupt event register</description>
          <addressOffset>0x008</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SWI0</name>
              <description>Software interrupt on event x
When EXTI_SECFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.
A software interrupt is generated independently from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Writing 0 has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Writing 1 triggers a rising edge event on event x. This bit is auto cleared by hardware.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SWI1</name>
              <description>Software interrupt on event x
When EXTI_SECFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.
A software interrupt is generated independently from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Writing 0 has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Writing 1 triggers a rising edge event on event x. This bit is auto cleared by hardware.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SWI2</name>
              <description>Software interrupt on event x
When EXTI_SECFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.
A software interrupt is generated independently from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Writing 0 has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Writing 1 triggers a rising edge event on event x. This bit is auto cleared by hardware.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SWI3</name>
              <description>Software interrupt on event x
When EXTI_SECFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.
A software interrupt is generated independently from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Writing 0 has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Writing 1 triggers a rising edge event on event x. This bit is auto cleared by hardware.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SWI4</name>
              <description>Software interrupt on event x
When EXTI_SECFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.
A software interrupt is generated independently from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Writing 0 has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Writing 1 triggers a rising edge event on event x. This bit is auto cleared by hardware.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SWI5</name>
              <description>Software interrupt on event x
When EXTI_SECFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.
A software interrupt is generated independently from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Writing 0 has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Writing 1 triggers a rising edge event on event x. This bit is auto cleared by hardware.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SWI6</name>
              <description>Software interrupt on event x
When EXTI_SECFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.
A software interrupt is generated independently from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Writing 0 has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Writing 1 triggers a rising edge event on event x. This bit is auto cleared by hardware.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SWI7</name>
              <description>Software interrupt on event x
When EXTI_SECFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.
A software interrupt is generated independently from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Writing 0 has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Writing 1 triggers a rising edge event on event x. This bit is auto cleared by hardware.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SWI8</name>
              <description>Software interrupt on event x
When EXTI_SECFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.
A software interrupt is generated independently from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Writing 0 has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Writing 1 triggers a rising edge event on event x. This bit is auto cleared by hardware.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SWI9</name>
              <description>Software interrupt on event x
When EXTI_SECFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.
A software interrupt is generated independently from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Writing 0 has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Writing 1 triggers a rising edge event on event x. This bit is auto cleared by hardware.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SWI10</name>
              <description>Software interrupt on event x
When EXTI_SECFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.
A software interrupt is generated independently from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Writing 0 has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Writing 1 triggers a rising edge event on event x. This bit is auto cleared by hardware.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SWI11</name>
              <description>Software interrupt on event x
When EXTI_SECFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.
A software interrupt is generated independently from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Writing 0 has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Writing 1 triggers a rising edge event on event x. This bit is auto cleared by hardware.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SWI12</name>
              <description>Software interrupt on event x
When EXTI_SECFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.
A software interrupt is generated independently from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Writing 0 has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Writing 1 triggers a rising edge event on event x. This bit is auto cleared by hardware.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SWI13</name>
              <description>Software interrupt on event x
When EXTI_SECFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.
A software interrupt is generated independently from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Writing 0 has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Writing 1 triggers a rising edge event on event x. This bit is auto cleared by hardware.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SWI14</name>
              <description>Software interrupt on event x
When EXTI_SECFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.
A software interrupt is generated independently from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Writing 0 has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Writing 1 triggers a rising edge event on event x. This bit is auto cleared by hardware.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SWI15</name>
              <description>Software interrupt on event x
When EXTI_SECFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.
A software interrupt is generated independently from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Writing 0 has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Writing 1 triggers a rising edge event on event x. This bit is auto cleared by hardware.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SWI16</name>
              <description>Software interrupt on event x
When EXTI_SECFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.
A software interrupt is generated independently from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Writing 0 has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Writing 1 triggers a rising edge event on event x. This bit is auto cleared by hardware.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>EXTI_RPR1</name>
          <displayName>EXTI_RPR1</displayName>
          <description>EXTI rising edge pending register</description>
          <addressOffset>0x00C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RPIF0</name>
              <description>configurable event inputs x rising edge pending bit
When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.
This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No rising edge trigger request occurred</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Rising edge trigger request occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RPIF1</name>
              <description>configurable event inputs x rising edge pending bit
When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.
This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No rising edge trigger request occurred</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Rising edge trigger request occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RPIF2</name>
              <description>configurable event inputs x rising edge pending bit
When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.
This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No rising edge trigger request occurred</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Rising edge trigger request occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RPIF3</name>
              <description>configurable event inputs x rising edge pending bit
When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.
This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No rising edge trigger request occurred</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Rising edge trigger request occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RPIF4</name>
              <description>configurable event inputs x rising edge pending bit
When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.
This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No rising edge trigger request occurred</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Rising edge trigger request occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RPIF5</name>
              <description>configurable event inputs x rising edge pending bit
When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.
This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No rising edge trigger request occurred</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Rising edge trigger request occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RPIF6</name>
              <description>configurable event inputs x rising edge pending bit
When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.
This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No rising edge trigger request occurred</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Rising edge trigger request occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RPIF7</name>
              <description>configurable event inputs x rising edge pending bit
When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.
This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No rising edge trigger request occurred</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Rising edge trigger request occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RPIF8</name>
              <description>configurable event inputs x rising edge pending bit
When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.
This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No rising edge trigger request occurred</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Rising edge trigger request occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RPIF9</name>
              <description>configurable event inputs x rising edge pending bit
When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.
This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No rising edge trigger request occurred</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Rising edge trigger request occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RPIF10</name>
              <description>configurable event inputs x rising edge pending bit
When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.
This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No rising edge trigger request occurred</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Rising edge trigger request occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RPIF11</name>
              <description>configurable event inputs x rising edge pending bit
When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.
This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No rising edge trigger request occurred</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Rising edge trigger request occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RPIF12</name>
              <description>configurable event inputs x rising edge pending bit
When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.
This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No rising edge trigger request occurred</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Rising edge trigger request occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RPIF13</name>
              <description>configurable event inputs x rising edge pending bit
When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.
This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No rising edge trigger request occurred</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Rising edge trigger request occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RPIF14</name>
              <description>configurable event inputs x rising edge pending bit
When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.
This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No rising edge trigger request occurred</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Rising edge trigger request occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RPIF15</name>
              <description>configurable event inputs x rising edge pending bit
When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.
This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No rising edge trigger request occurred</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Rising edge trigger request occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RPIF16</name>
              <description>configurable event inputs x rising edge pending bit
When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.
This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No rising edge trigger request occurred</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Rising edge trigger request occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>EXTI_FPR1</name>
          <displayName>EXTI_FPR1</displayName>
          <description>EXTI falling edge pending register</description>
          <addressOffset>0x010</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FPIF0</name>
              <description>configurable event inputs x falling edge pending bit
When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.
This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No falling edge trigger request occurred</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Falling edge trigger request occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FPIF1</name>
              <description>configurable event inputs x falling edge pending bit
When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.
This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No falling edge trigger request occurred</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Falling edge trigger request occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FPIF2</name>
              <description>configurable event inputs x falling edge pending bit
When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.
This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No falling edge trigger request occurred</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Falling edge trigger request occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FPIF3</name>
              <description>configurable event inputs x falling edge pending bit
When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.
This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No falling edge trigger request occurred</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Falling edge trigger request occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FPIF4</name>
              <description>configurable event inputs x falling edge pending bit
When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.
This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No falling edge trigger request occurred</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Falling edge trigger request occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FPIF5</name>
              <description>configurable event inputs x falling edge pending bit
When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.
This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No falling edge trigger request occurred</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Falling edge trigger request occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FPIF6</name>
              <description>configurable event inputs x falling edge pending bit
When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.
This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No falling edge trigger request occurred</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Falling edge trigger request occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FPIF7</name>
              <description>configurable event inputs x falling edge pending bit
When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.
This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No falling edge trigger request occurred</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Falling edge trigger request occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FPIF8</name>
              <description>configurable event inputs x falling edge pending bit
When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.
This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No falling edge trigger request occurred</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Falling edge trigger request occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FPIF9</name>
              <description>configurable event inputs x falling edge pending bit
When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.
This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No falling edge trigger request occurred</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Falling edge trigger request occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FPIF10</name>
              <description>configurable event inputs x falling edge pending bit
When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.
This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No falling edge trigger request occurred</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Falling edge trigger request occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FPIF11</name>
              <description>configurable event inputs x falling edge pending bit
When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.
This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No falling edge trigger request occurred</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Falling edge trigger request occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FPIF12</name>
              <description>configurable event inputs x falling edge pending bit
When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.
This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No falling edge trigger request occurred</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Falling edge trigger request occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FPIF13</name>
              <description>configurable event inputs x falling edge pending bit
When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.
This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No falling edge trigger request occurred</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Falling edge trigger request occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FPIF14</name>
              <description>configurable event inputs x falling edge pending bit
When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.
This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No falling edge trigger request occurred</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Falling edge trigger request occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FPIF15</name>
              <description>configurable event inputs x falling edge pending bit
When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.
This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No falling edge trigger request occurred</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Falling edge trigger request occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FPIF16</name>
              <description>configurable event inputs x falling edge pending bit
When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.
This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No falling edge trigger request occurred</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Falling edge trigger request occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>EXTI_SECCFGR1</name>
          <displayName>EXTI_SECCFGR1</displayName>
          <description>EXTI security configuration register</description>
          <addressOffset>0x014</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SEC0</name>
              <description>Security enable on event input x
When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Event security disabled (non-secure)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Event security enabled (secure)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEC1</name>
              <description>Security enable on event input x
When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Event security disabled (non-secure)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Event security enabled (secure)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEC2</name>
              <description>Security enable on event input x
When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Event security disabled (non-secure)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Event security enabled (secure)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEC3</name>
              <description>Security enable on event input x
When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Event security disabled (non-secure)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Event security enabled (secure)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEC4</name>
              <description>Security enable on event input x
When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Event security disabled (non-secure)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Event security enabled (secure)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEC5</name>
              <description>Security enable on event input x
When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Event security disabled (non-secure)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Event security enabled (secure)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEC6</name>
              <description>Security enable on event input x
When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Event security disabled (non-secure)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Event security enabled (secure)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEC7</name>
              <description>Security enable on event input x
When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Event security disabled (non-secure)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Event security enabled (secure)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEC8</name>
              <description>Security enable on event input x
When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Event security disabled (non-secure)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Event security enabled (secure)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEC9</name>
              <description>Security enable on event input x
When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Event security disabled (non-secure)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Event security enabled (secure)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEC10</name>
              <description>Security enable on event input x
When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Event security disabled (non-secure)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Event security enabled (secure)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEC11</name>
              <description>Security enable on event input x
When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Event security disabled (non-secure)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Event security enabled (secure)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEC12</name>
              <description>Security enable on event input x
When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Event security disabled (non-secure)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Event security enabled (secure)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEC13</name>
              <description>Security enable on event input x
When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Event security disabled (non-secure)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Event security enabled (secure)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEC14</name>
              <description>Security enable on event input x
When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Event security disabled (non-secure)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Event security enabled (secure)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEC15</name>
              <description>Security enable on event input x
When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Event security disabled (non-secure)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Event security enabled (secure)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEC16</name>
              <description>Security enable on event input x
When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Event security disabled (non-secure)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Event security enabled (secure)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>EXTI_PRIVCFGR1</name>
          <displayName>EXTI_PRIVCFGR1</displayName>
          <description>EXTI privilege configuration register</description>
          <addressOffset>0x018</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRIV0</name>
              <description>Security enable on event input x
When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access.
When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Event privilege disabled (unprivileged)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Event privilege enabled (privileged)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIV1</name>
              <description>Security enable on event input x
When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access.
When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Event privilege disabled (unprivileged)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Event privilege enabled (privileged)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIV2</name>
              <description>Security enable on event input x
When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access.
When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Event privilege disabled (unprivileged)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Event privilege enabled (privileged)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIV3</name>
              <description>Security enable on event input x
When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access.
When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Event privilege disabled (unprivileged)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Event privilege enabled (privileged)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIV4</name>
              <description>Security enable on event input x
When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access.
When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Event privilege disabled (unprivileged)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Event privilege enabled (privileged)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIV5</name>
              <description>Security enable on event input x
When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access.
When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Event privilege disabled (unprivileged)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Event privilege enabled (privileged)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIV6</name>
              <description>Security enable on event input x
When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access.
When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Event privilege disabled (unprivileged)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Event privilege enabled (privileged)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIV7</name>
              <description>Security enable on event input x
When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access.
When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Event privilege disabled (unprivileged)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Event privilege enabled (privileged)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIV8</name>
              <description>Security enable on event input x
When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access.
When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Event privilege disabled (unprivileged)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Event privilege enabled (privileged)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIV9</name>
              <description>Security enable on event input x
When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access.
When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Event privilege disabled (unprivileged)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Event privilege enabled (privileged)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIV10</name>
              <description>Security enable on event input x
When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access.
When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Event privilege disabled (unprivileged)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Event privilege enabled (privileged)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIV11</name>
              <description>Security enable on event input x
When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access.
When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Event privilege disabled (unprivileged)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Event privilege enabled (privileged)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIV12</name>
              <description>Security enable on event input x
When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access.
When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Event privilege disabled (unprivileged)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Event privilege enabled (privileged)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIV13</name>
              <description>Security enable on event input x
When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access.
When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Event privilege disabled (unprivileged)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Event privilege enabled (privileged)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIV14</name>
              <description>Security enable on event input x
When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access.
When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Event privilege disabled (unprivileged)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Event privilege enabled (privileged)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIV15</name>
              <description>Security enable on event input x
When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access.
When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Event privilege disabled (unprivileged)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Event privilege enabled (privileged)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIV16</name>
              <description>Security enable on event input x
When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access.
When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Event privilege disabled (unprivileged)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Event privilege enabled (privileged)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>EXTI_EXTICR1</name>
          <displayName>EXTI_EXTICR1</displayName>
          <description>EXTI external interrupt selection register</description>
          <addressOffset>0x060</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EXTI0</name>
              <description>EXTI0 GPIO port selection
These bits are written by software to select the source input for EXTI0 external interrupt.
When EXTI_SECCFGR.SEC0 is disabled, EXTI0 can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SEC0 is enabled, EXTI0 can only be accessed with secure access. Non-secure write is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIV0 is disabled, EXTI0 can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIV0 is enabled, EXTI0 can only be accessed with privileged access. Unprivileged write to this bit is discarded.
Others: reserved</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x00</name>
                  <description>PA0 pin</description>
                  <value>0x00</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x01</name>
                  <description>PB0 pin</description>
                  <value>0x01</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EXTI1</name>
              <description>EXTI1 GPIO port selection
These bits are written by software to select the source input for EXTI1 external interrupt.
When EXTI_SECCFGR.SEC1 is disabled, EXTI1 can be accessed with
non-secure and secure access.
When EXTI_SECCFGR.SEC1 is enabled, EXTI1 can only be accessed with secure access. Non-secure write is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIV1 is disabled, EXTI1 can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIV1 is enabled, EXTI1 can only be accessed with privileged access. Unprivileged write to this bit is discarded.
Others: reserved</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x00</name>
                  <description>PA1 pin</description>
                  <value>0x00</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x01</name>
                  <description>PB1 pin</description>
                  <value>0x01</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EXTI2</name>
              <description>EXTI2 GPIO port selection 
These bits are written by software to select the source input for EXTI2 external interrupt.
When EXTI_SECCFGR.SEC2 is disabled, EXTI2 can be accessed with
non-secure and secure access.
When EXTI_SECCFGR.SEC2 is enabled, EXTI2 can only be accessed with secure access. Non-secure write is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIV2 is disabled, EXTI2 can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIV2 is enabled, EXTI2 can only be accessed with privileged access. Unprivileged write to this bit is discarded.
Others: reserved</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x00</name>
                  <description>PA2 pin</description>
                  <value>0x00</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x01</name>
                  <description>PB2 pin</description>
                  <value>0x01</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EXTI3</name>
              <description>EXTI3 GPIO port selection
These bits are written by software to select the source input for EXTI3 external interrupt.
When EXTI_SECCFGR.SEC3 is disabled, EXTI3 can be accessed with 
non-secure and secure access.
When EXTI_SECCFGR.SEC3 is enabled, EXTI3 can only be accessed with secure access. Non-secure write is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIV3 is disabled, EXTI3 can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIV3 is enabled, EXTI3 can only be accessed with privileged access. Unprivileged write to this bit is discarded.
Others: reserved</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x00</name>
                  <description>PA3 pin</description>
                  <value>0x00</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x01</name>
                  <description>PB3 pin</description>
                  <value>0x01</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x07</name>
                  <description>PH3 pin</description>
                  <value>0x07</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>EXTI_EXTICR2</name>
          <displayName>EXTI_EXTICR2</displayName>
          <description>EXTI external interrupt selection register</description>
          <addressOffset>0x064</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EXTI4</name>
              <description>EXTI4 GPIO port selection
These bits are written by software to select the source input for EXTI4 external interrupt.
When EXTI_SECCFGR.SEC4 is disabled, EXTI4 can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SEC4 is enabled, EXTI4 can only be accessed with secure access. Non-secure write is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIV4 is disabled, EXTI4 can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIV4 is enabled, EXTI4 can only be accessed with privileged access. Unprivileged write to this bit is discarded.
Others: reserved</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x00</name>
                  <description>No port pin selected</description>
                  <value>0x00</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x01</name>
                  <description>PB4 pin</description>
                  <value>0x01</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EXTI5</name>
              <description>EXTI5 GPIO port selection
These bits are written by software to select the source input for EXTI5 external interrupt.
When EXTI_SECCFGR.SEC5 is disabled, EXTI5 can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SEC5 is enabled, EXTI5 can only be accessed with secure access. Non-secure write is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIV5 is disabled, EXTI5 can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIV5 is enabled, EXTI5 can only be accessed with privileged access. Unprivileged write to this bit is discarded.
Others: reserved</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x00</name>
                  <description>PA5 pin</description>
                  <value>0x00</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x01</name>
                  <description>PB5 pin</description>
                  <value>0x01</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EXTI6</name>
              <description>EXTI6 GPIO port selection 
These bits are written by software to select the source input for EXTI6 external interrupt.
When EXTI_SECCFGR.SEC6 is disabled, EXTI6 can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SEC6 is enabled, EXTI6 can only be accessed with secure access. Non-secure write is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIV6 is disabled, EXTI6 can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIV6 is enabled, EXTI6 can only be accessed with privileged access. Unprivileged write to this bit is discarded.
Others: reserved</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x00</name>
                  <description>PA6 pin</description>
                  <value>0x00</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x01</name>
                  <description>PB6 pin</description>
                  <value>0x01</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EXTI7</name>
              <description>EXTI7 GPIO port selection
These bits are written by software to select the source input for EXTI7 external interrupt.
When EXTI_SECCFGR.SEC7 is disabled, EXTI7 can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SEC7 is enabled, EXTI7 can only be accessed with secure access. Non-secure write is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIV7 is disabled, EXTI7 can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIV7 is enabled, EXTI7 can only be accessed with privileged access. Unprivileged write to this bit is discarded.
Others: reserved</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x00</name>
                  <description>PA7 pin</description>
                  <value>0x00</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x01</name>
                  <description>PB7 pin</description>
                  <value>0x01</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>EXTI_EXTICR3</name>
          <displayName>EXTI_EXTICR3</displayName>
          <description>EXTI external interrupt selection register</description>
          <addressOffset>0x068</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EXTI8</name>
              <description>EXTI8 GPIO port selection
These bits are written by software to select the source input for EXTI8 external interrupt.
When EXTI_SECCFGR.SEC8 is disabled, EXTI8 can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SEC8 is enabled, EXTI8 can only be accessed with secure access. Non-secure write is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIV8 is disabled, EXTI8 can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIV8 is enabled, EXTI8 can only be accessed with privileged access. Unprivileged write to this bit is discarded.
Others: reserved</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x00</name>
                  <description>PA8 pin</description>
                  <value>0x00</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x01</name>
                  <description>PB8 pin</description>
                  <value>0x01</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EXTI9</name>
              <description>EXTI9 GPIO port selection
These bits are written by software to select the source input for EXTI9 external interrupt.
When EXTI_SECCFGR.SEC9 is disabled, EXTI9 can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SEC9 is enabled, EXTI9 can only be accessed with secure access. Non-secure write is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIV9 is disabled, EXTI9 can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIV9 is enabled, EXTI9 can only be accessed with privileged access. Unprivileged write to this bit is discarded.
Others: reserved</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x00</name>
                  <description>PA9 pin</description>
                  <value>0x00</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x01</name>
                  <description>PB9 pin</description>
                  <value>0x01</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EXTI10</name>
              <description>EXTI10 GPIO port selection 
These bits are written by software to select the source input for EXTI10 external interrupt.
When EXTI_SECCFGR.SEC10 is disabled, EXTI10 can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SEC10 is enabled, EXTI10 can only be accessed with secure access. Non-secure write is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIV10 is disabled, EXTI10 can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIV10 is enabled, EXTI10 can only be accessed with privileged access. Unprivileged write to this bit is discarded.
Others: reserved</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x00</name>
                  <description>PA10 pin</description>
                  <value>0x00</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x01</name>
                  <description>PB10 pin (reserved on STM32WBA55xx devices)</description>
                  <value>0x01</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EXTI11</name>
              <description>EXTI11 GPIO port selection
These bits are written by software to select the source input for EXTI11 external interrupt.
When EXTI_SECCFGR.SEC11 is disabled, EXTI11 can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SEC11 is enabled, EXTI11 can only be accessed with secure access. Non-secure write is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIV11 is disabled, EXTI11 can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIV11 is enabled, EXTI11 can only be accessed with privileged access. Unprivileged write to this bit is discarded.
Others: reserved</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x00</name>
                  <description>PA11 pin</description>
                  <value>0x00</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x01</name>
                  <description>PB11 pin</description>
                  <value>0x01</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>EXTI_EXTICR4</name>
          <displayName>EXTI_EXTICR4</displayName>
          <description>EXTI external interrupt selection register</description>
          <addressOffset>0x06C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EXTI12</name>
              <description>EXTI0 GPIO port selection
These bits are written by software to select the source input for EXTI12 external interrupt.
When EXTI_SECCFGR.SEC12 is disabled, EXTI12 can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SEC12 is enabled, EXTI12 can only be accessed with secure access. Non-secure write is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIV12 is disabled, EXTI12 can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIV12 is enabled, EXTI12 can only be accessed with privileged access. Unprivileged write to this bit is discarded.
Others: reserved</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x00</name>
                  <description>PA12 pin</description>
                  <value>0x00</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x01</name>
                  <description>PB12 pin</description>
                  <value>0x01</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EXTI13</name>
              <description>EXTI13 GPIO port selection
These bits are written by software to select the source input for EXTI13 external interrupt.
When EXTI_SECCFGR.SEC13 is disabled, EXTI13 can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SEC13 is enabled, EXTI13 can only be accessed with secure access. Non-secure write is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIV13 is disabled, EXTI13 can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIV13 is enabled, EXTI13 can only be accessed with privileged access. Unprivileged write to this bit is discarded.
Others: reserved</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x00</name>
                  <description>PA13 pin</description>
                  <value>0x00</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x01</name>
                  <description>PB13 pin</description>
                  <value>0x01</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x02</name>
                  <description>PC13 pin</description>
                  <value>0x02</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EXTI14</name>
              <description>EXTI14 GPIO port selection 
These bits are written by software to select the source input for EXTI14 external interrupt.
When EXTI_SECCFGR.SEC14 is disabled, EXTI14 can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SEC14 is enabled, EXTI14 can only be accessed with secure access. Non-secure write is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIV14 is disabled, EXTI14 can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIV14 is enabled, EXTI14 can only be accessed with privileged access. Unprivileged write to this bit is discarded.
Others: reserved</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x00</name>
                  <description>PA14 pin</description>
                  <value>0x00</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x01</name>
                  <description>PB14 pin</description>
                  <value>0x01</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x02</name>
                  <description>PC14 pin</description>
                  <value>0x02</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EXTI15</name>
              <description>EXTI15 GPIO port selection
These bits are written by software to select the source input for EXTI15 external interrupt.
When EXTI_SECCFGR.SEC15 is disabled, EXTI15 can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SEC15 is enabled, EXTI15 can only be accessed with secure access. Non-secure write is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIV15 is disabled, EXTI15 can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIV15 is enabled, EXTI15 can only be accessed with privileged access. Unprivileged write to this bit is discarded.
Others: reserved</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x00</name>
                  <description>PA15 pin</description>
                  <value>0x00</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x01</name>
                  <description>PB15 pin</description>
                  <value>0x01</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x02</name>
                  <description>PC15 pin</description>
                  <value>0x02</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>EXTI_LOCKR</name>
          <displayName>EXTI_LOCKR</displayName>
          <description>EXTI lock register</description>
          <addressOffset>0x070</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LOCK</name>
              <description>Global security and privilege configuration registers (EXTI_SECCFGR and EXTI_PRIVCFGR) lock 
This bit is written once after reset.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Security and privilege configuration open, can be modified.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Security and privilege configuration locked, can no longer be modified.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>EXTI_IMR1</name>
          <displayName>EXTI_IMR1</displayName>
          <description>EXTI CPU wakeup with interrupt mask register</description>
          <addressOffset>0x080</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IM0</name>
              <description>CPU wakeup with interrupt mask on event input x
When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Wakeup with interrupt request from input event x is masked.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Wakeup with interrupt request from input event x is unmasked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IM1</name>
              <description>CPU wakeup with interrupt mask on event input x
When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Wakeup with interrupt request from input event x is masked.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Wakeup with interrupt request from input event x is unmasked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IM2</name>
              <description>CPU wakeup with interrupt mask on event input x
When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Wakeup with interrupt request from input event x is masked.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Wakeup with interrupt request from input event x is unmasked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IM3</name>
              <description>CPU wakeup with interrupt mask on event input x
When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Wakeup with interrupt request from input event x is masked.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Wakeup with interrupt request from input event x is unmasked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IM4</name>
              <description>CPU wakeup with interrupt mask on event input x
When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Wakeup with interrupt request from input event x is masked.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Wakeup with interrupt request from input event x is unmasked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IM5</name>
              <description>CPU wakeup with interrupt mask on event input x
When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Wakeup with interrupt request from input event x is masked.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Wakeup with interrupt request from input event x is unmasked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IM6</name>
              <description>CPU wakeup with interrupt mask on event input x
When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Wakeup with interrupt request from input event x is masked.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Wakeup with interrupt request from input event x is unmasked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IM7</name>
              <description>CPU wakeup with interrupt mask on event input x
When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Wakeup with interrupt request from input event x is masked.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Wakeup with interrupt request from input event x is unmasked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IM8</name>
              <description>CPU wakeup with interrupt mask on event input x
When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Wakeup with interrupt request from input event x is masked.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Wakeup with interrupt request from input event x is unmasked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IM9</name>
              <description>CPU wakeup with interrupt mask on event input x
When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Wakeup with interrupt request from input event x is masked.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Wakeup with interrupt request from input event x is unmasked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IM10</name>
              <description>CPU wakeup with interrupt mask on event input x
When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Wakeup with interrupt request from input event x is masked.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Wakeup with interrupt request from input event x is unmasked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IM11</name>
              <description>CPU wakeup with interrupt mask on event input x
When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Wakeup with interrupt request from input event x is masked.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Wakeup with interrupt request from input event x is unmasked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IM12</name>
              <description>CPU wakeup with interrupt mask on event input x
When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Wakeup with interrupt request from input event x is masked.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Wakeup with interrupt request from input event x is unmasked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IM13</name>
              <description>CPU wakeup with interrupt mask on event input x
When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Wakeup with interrupt request from input event x is masked.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Wakeup with interrupt request from input event x is unmasked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IM14</name>
              <description>CPU wakeup with interrupt mask on event input x
When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Wakeup with interrupt request from input event x is masked.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Wakeup with interrupt request from input event x is unmasked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IM15</name>
              <description>CPU wakeup with interrupt mask on event input x
When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Wakeup with interrupt request from input event x is masked.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Wakeup with interrupt request from input event x is unmasked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IM16</name>
              <description>CPU wakeup with interrupt mask on event input x
When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Wakeup with interrupt request from input event x is masked.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Wakeup with interrupt request from input event x is unmasked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>EXTI_EMR1</name>
          <displayName>EXTI_EMR1</displayName>
          <description>EXTI CPU wakeup with event mask register</description>
          <addressOffset>0x084</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EM0</name>
              <description>CPU wakeup with event generation mask on event input x
When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Wakeup with event generation from Line x is masked.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Wakeup with event generation from Line x is unmasked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EM1</name>
              <description>CPU wakeup with event generation mask on event input x
When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Wakeup with event generation from Line x is masked.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Wakeup with event generation from Line x is unmasked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EM2</name>
              <description>CPU wakeup with event generation mask on event input x
When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Wakeup with event generation from Line x is masked.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Wakeup with event generation from Line x is unmasked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EM3</name>
              <description>CPU wakeup with event generation mask on event input x
When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Wakeup with event generation from Line x is masked.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Wakeup with event generation from Line x is unmasked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EM4</name>
              <description>CPU wakeup with event generation mask on event input x
When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Wakeup with event generation from Line x is masked.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Wakeup with event generation from Line x is unmasked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EM5</name>
              <description>CPU wakeup with event generation mask on event input x
When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Wakeup with event generation from Line x is masked.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Wakeup with event generation from Line x is unmasked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EM6</name>
              <description>CPU wakeup with event generation mask on event input x
When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Wakeup with event generation from Line x is masked.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Wakeup with event generation from Line x is unmasked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EM7</name>
              <description>CPU wakeup with event generation mask on event input x
When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Wakeup with event generation from Line x is masked.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Wakeup with event generation from Line x is unmasked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EM8</name>
              <description>CPU wakeup with event generation mask on event input x
When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Wakeup with event generation from Line x is masked.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Wakeup with event generation from Line x is unmasked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EM9</name>
              <description>CPU wakeup with event generation mask on event input x
When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Wakeup with event generation from Line x is masked.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Wakeup with event generation from Line x is unmasked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EM10</name>
              <description>CPU wakeup with event generation mask on event input x
When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Wakeup with event generation from Line x is masked.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Wakeup with event generation from Line x is unmasked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EM11</name>
              <description>CPU wakeup with event generation mask on event input x
When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Wakeup with event generation from Line x is masked.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Wakeup with event generation from Line x is unmasked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EM12</name>
              <description>CPU wakeup with event generation mask on event input x
When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Wakeup with event generation from Line x is masked.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Wakeup with event generation from Line x is unmasked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EM13</name>
              <description>CPU wakeup with event generation mask on event input x
When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Wakeup with event generation from Line x is masked.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Wakeup with event generation from Line x is unmasked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EM14</name>
              <description>CPU wakeup with event generation mask on event input x
When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Wakeup with event generation from Line x is masked.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Wakeup with event generation from Line x is unmasked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EM15</name>
              <description>CPU wakeup with event generation mask on event input x
When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Wakeup with event generation from Line x is masked.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Wakeup with event generation from Line x is unmasked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EM16</name>
              <description>CPU wakeup with event generation mask on event input x
When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Wakeup with event generation from Line x is masked.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Wakeup with event generation from Line x is unmasked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>FLASH</name>
      <description>Embedded Flash memory</description>
      <groupName>Flash</groupName>
      <baseAddress>0x40022000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x400</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>FLASH</name>
        <description>Flash interface non-secure global interrupt,Flash ECC single error correction interrupt</description>
        <value>006</value>
      </interrupt>
      <registers>
        <register>
          <name>FLASH_ACR</name>
          <displayName>FLASH_ACR</displayName>
          <description>FLASH access control register</description>
          <addressOffset>0x000</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LATENCY</name>
              <description>Latency
These bits represent the ratio between the AHB hclk1 clock period and the Flash memory access time.
Access to the bit can be secured by RCC SYSCLKSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with FLASH SPRIV or when non-secure with FLASH NSPRIV.
...
Note: Before entering Stop 1 mode software must set FLASH wait state latency to at least 1.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Zero wait state</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>One wait state</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>Two wait states</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xF</name>
                  <description>Fifteen wait states</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRFTEN</name>
              <description>Prefetch enable
This bit enables the prefetch buffer in the embedded Flash memory.
This bit can be protected against unprivileged access by FLASH NSPRIV.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Prefetch disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Prefetch enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LPM</name>
              <description>Low-power read mode
This bit puts the Flash memory in low-power read mode.
Access to the bit can be secured by PWR LPMSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with FLASH SPRIV or when non-secure with FLASH NSPRIV.
This bit can't be written when a Flash program or erase operation is busy (BSY = 1) or when the write buffer is not empty (WDW = 1). Changing this bit while a Flash program or erase operation is busy (BSY = 1) is rejected.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Flash not in low-power read mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Flash in low-power read mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PDREQ</name>
              <description>Flash power-down mode request
This bit requests Flash to enter power-down mode. When Flash enters power-down mode, this bit is cleared by hardware and the PDKEYR is locked.
This bit is write-protected with FLASH_PDKEYR. 
Access to the bit can be secured by PWR LPMSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with FLASH SPRIV or when non-secure with FLASH NSPRIV.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No request for Flash to enter power-down mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Flash requested to enter power-down mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEEP_PD</name>
              <description>Flash memory power-down mode during Sleep mode
This bit determines whether the Flash memory is in power-down mode or Idle mode when the device is in Sleep mode.
Access to the bit can be secured by PWR LPMSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with FLASH SPRIV or when non-secure with FLASH NSPRIV.
The Flash must not be put in power-down while a program or an erase operation is ongoing.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Flash in Idle mode during Sleep mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Flash in power-down mode during Sleep mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASH_NSKEYR</name>
          <displayName>FLASH_NSKEYR</displayName>
          <description>FLASH key register</description>
          <addressOffset>0x008</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NSKEY</name>
              <description>Flash memory non-secure key
The following values must be written consecutively to unlock the FLASH_NSCR1 register, allowing the Flash memory non-secure programming/erasing operations:
KEY1: 0x45670123
KEY2: 0xCDEF89AB</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASH_SECKEYR</name>
          <displayName>FLASH_SECKEYR</displayName>
          <description>FLASH secure key register</description>
          <addressOffset>0x00C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SECKEY</name>
              <description>Flash memory secure key
The following values must be written consecutively to unlock the FLASH_SECCR1 register, allowing the Flash memory secure programming/erasing operations:
KEY1: 0x45670123
KEY2: 0xCDEF89AB</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASH_OPTKEYR</name>
          <displayName>FLASH_OPTKEYR</displayName>
          <description>FLASH option key register</description>
          <addressOffset>0x010</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OPTKEY</name>
              <description>Option byte key
The LOCK bit in the FLASH_NSCR1 must be cleared before doing the unlock sequence for OPTLOCK bit. The following values must be written consecutively to unlock the FLASH_NSCR1.OPTSTRT and OBL_LAUNCH register bits concerning user option operations:
KEY1: 0x08192A3B
KEY2: 0x4C5D6E7F</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASH_PDKEYR</name>
          <displayName>FLASH_PDKEYR</displayName>
          <description>FLASH power-down key register</description>
          <addressOffset>0x018</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDKEY1</name>
              <description>Flash power-down key
The following values must be written consecutively to unlock the PDREQ bit in FLASH_ACR:
PDKEY_1: 0x04152637
PDKEY_2: 0xFAFBFCFD</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASH_NSSR</name>
          <displayName>FLASH_NSSR</displayName>
          <description>FLASH status register</description>
          <addressOffset>0x020</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFF0FFFF</resetMask>
          <fields>
            <field>
              <name>EOP</name>
              <description>Non-secure end of operation
This bit is set by hardware when one or more Flash memory non-secure operation (program/erase) has been completed successfully. This bit is set only if the non-secure end of operation interrupts are enabled (EOPIE = 1 in FLASH_NSCR1). This bit is cleared by writing1.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OPERR</name>
              <description>Non-secure operation error
This bit is set by hardware when a Flash memory non-secure operation (program/erase) completes unsuccessfully. This bit is set only if non-secure error interrupts are enabled (NSERRIE = 1). This bit is cleared by writing 1.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PROGERR</name>
              <description>Non-secure programming error
This bit is set by hardware when a non-secure quad-word address to be programmed contains a value different from all 1 before programming, except if the data to write is all 0. This bit is cleared by writing 1.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WRPERR</name>
              <description>Non-secure write protection error
This bit is set by hardware when a non-secure address to be erased/programmed belongs to a write-protected part (by WRP or HDP) of the Flash memory. This bit is cleared by writing 1.
Refer to Section7.3.10: Flash memory errors flags for full conditions of error flag setting.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PGAERR</name>
              <description>Non-secure programming alignment error
This bit is set by hardware when the first word to be programmed is not aligned with a quad-word address, or the second, third or forth word does not belong to the same quad-word address. This bit is cleared by writing 1.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SIZERR</name>
              <description>Non-secure size error
This bit is set by hardware when the size of the access is a byte or half-word during a non-secure program sequence. Only quad-word programming is allowed by means of successive word accesses. This bit is cleared by writing 1.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PGSERR</name>
              <description>Non-secure programming sequence error
This bit is set by hardware when programming sequence is not correct. It is cleared by writing 1.
Refer to Section7.3.10: Flash memory errors flags for full conditions of error flag setting.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OPTWERR</name>
              <description>Option write error 
This bit is set by hardware when the options bytes are written with an invalid configuration or when modifying options in RDP level 2.. It is cleared by writing 1.
Refer to Section7.3.10: Flash memory errors flags for full conditions of error flag setting.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BSY</name>
              <description>Non-secure busy
This indicates that a Flash memory secure or non-secure operation is in progress. This bit is set at the beginning of a Flash operation and reset when the operation finishes or when an error occurs.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WDW</name>
              <description>Non-secure wait data to write
This bit indicates that the Flash memory write buffer has been written by a secure or non-secure operation. It is set when the first data is stored in the buffer and cleared when the write is performed in the Flash memory.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>OEM1LOCK</name>
              <description>OEM1 key RDP lock
This bit indicates that the OEM1 key read during the OBL is not virgin. When set, the OEM1 key RDP lock mechanism is active.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>OEM2LOCK</name>
              <description>OEM2 key RDP lock
This bit indicates that the OEM2 key read during the OBL is not virgin. When set, the OEM2 key RDP lock mechanism is active.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PD</name>
              <description>Flash in power-down mode
This bit indicates that the Flash memory is in power-down state. It is reset when Flash is in normal mode or being awaken.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASH_SECSR</name>
          <displayName>FLASH_SECSR</displayName>
          <description>FLASH secure status register</description>
          <addressOffset>0x024</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EOP</name>
              <description>Secure end of operation
This bit is set by hardware when one or more Flash memory secure operation (program/erase) has been completed successfully. This bit is set only if the secure end of operation interrupts are enabled (EOPIE = 1 in FLASH_SECCR1). This bit is cleared by writing1.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OPERR</name>
              <description>Secure operation error
This bit is set by hardware when a Flash memory secure operation (program/erase) completes unsuccessfully. This bit is set only if secure error interrupts are enabled (SECERRIE = 1). This bit is cleared by writing 1.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PROGERR</name>
              <description>Secure programming error
This bit is set by hardware when a secure quad-word address to be programmed contains a value different from all 1 before programming, except if the data to write is all 0. This bit is cleared by writing 1.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WRPERR</name>
              <description>Secure write protection error
This bit is set by hardware when an secure address to be erased/programmed belongs to a write-protected part (by WRP or HDP) of the Flash memory. This bit is cleared by writing 1.
Refer to Section7.3.10: Flash memory errors flags for full conditions of error flag setting.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PGAERR</name>
              <description>Secure programming alignment error
This bit is set by hardware when the first word to be programmed is not aligned with a quad-word address, or the second, third or forth word does not belong to the same quad-word address.This bit is cleared by writing 1.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SIZERR</name>
              <description>Secure size error
This bit is set by hardware when the size of the access is a byte or half-word during a secure program sequence. Only quad-word programming is allowed by means of successive word accesses.This bit is cleared by writing 1.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PGSERR</name>
              <description>Secure programming sequence error
This bit is set by hardware when programming sequence is not correct. It is cleared by writing 1.
Refer to Section7.3.10: Flash memory errors flags for full conditions of error flag setting.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BSY</name>
              <description>Secure busy
This bit indicates that a Flash memory secure or non-secure operation is in progress. This is set on the beginning of a Flash operation and reset when the operation finishes or when an error occurs.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WDW</name>
              <description>Secure wait data to write
This bit indicates that the Flash memory write buffer has been written by a secure or non-secure operation. It is set when the first data is stored in the buffer and cleared when the write is performed in the Flash memory.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASH_NSCR1</name>
          <displayName>FLASH_NSCR1</displayName>
          <description>FLASH control register</description>
          <addressOffset>0x028</addressOffset>
          <size>0x20</size>
          <resetValue>0xC0000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PG</name>
              <description>Non-secure programming</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Non-secure Flash programming disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Non-secure Flash programming enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PER</name>
              <description>Non-secure page erase</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Non-secure page erase disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Non-secure page erase enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MER</name>
              <description>Non-secure Flash mass erase
This bit triggers the Flash non-secure mass erase (all Flash user pages) when set.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PNB</name>
              <description>Non-secure page number selection
These bits select the page to erase.
...
Note that bit 9 is reserved on STM32WBA5xEx devices.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>page 0</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>page 1</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7F</name>
                  <description>page 127</description>
                  <value>0x7F</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BWR</name>
              <description>Non-secure burst write programming mode
When set, this bit selects the burst write programming mode.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STRT</name>
              <description>Non-secure operation start 
This bit triggers a non-secure erase operation when set. If MER and PER bits are reset and the STRT bit is set, the PGSERR bit in FLASH_NSSR is set (this condition is forbidden).
This bit is set only by software and is cleared when the BSY bit is cleared in FLASH_NSSR.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OPTSTRT</name>
              <description>Options modification start
This bit triggers an option bytes erase and program operation when set. This bit is write-protected with OPTLOCK.. This bit is set only by software, and is cleared when the BSY bit is cleared in FLASH_NSSR.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EOPIE</name>
              <description>Non-secure end of operation interrupt enable
This bit enables the interrupt generation when the EOP bit in the FLASH_NSSR is set to 1.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Non-secure EOP Interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Non-secure EOP Interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ERRIE</name>
              <description>Non-secure error interrupt enable
This bit enables the interrupt generation when the OPERR bit in the FLASH_NSSR is set to 1.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Non-secure OPERR error interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Non-secure OPERR error interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OBL_LAUNCH</name>
              <description>Force the option byte loading
When set to 1, this bit forces the option byte reloading. This bit is cleared only when the option byte loading is complete. This bit is write-protected with OPTLOCK.
Note: The LSE oscillator must be disabled, LSEON = 0 and LSERDY = 0, before starting OBL_LAUNCH.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Option byte loading complete</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Option byte loading requested</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OPTLOCK</name>
              <description>Option lock
This bit is set only. When set, the FLASH_NSCR1.OPTSRT and OBL_LAUNCH bits concerning user options write access is locked. This bit is cleared by hardware after detecting the unlock sequence in FLASH_OPTKEYR. The FLASH_NSCR1.LOCK bit must be cleared before doing the FLASH_OPTKEYR unlock sequence.
In case of an unsuccessful unlock operation, this bit remains set until the next reset.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCK</name>
              <description>Non-secure lock
This bit is set only.
When set, the FLASH_NSCR1 register write access is locked. This bit is cleared by hardware after detecting the unlock sequence in FLASH_NSKEYR.
In case of an unsuccessful unlock operation, this bit remains set until the next system reset.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASH_SECCR1</name>
          <displayName>FLASH_SECCR1</displayName>
          <description>FLASH secure control register</description>
          <addressOffset>0x02C</addressOffset>
          <size>0x20</size>
          <resetValue>0x80000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PG</name>
              <description>Secure programming</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Secure Flash programming disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Secure Flash programming enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PER</name>
              <description>Secure page erase</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Secure page erase disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Secure page erase enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MER</name>
              <description>Secure Flash mass erase
This bit triggers the Flash secure mass erase (all Flash user pages) when set.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PNB</name>
              <description>Secure page number selection
These bits select the page to erase:
...
Note that bit 9 is reserved on STM32WBA5xEx devices.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>page 0</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>page 1</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7F</name>
                  <description>page 127</description>
                  <value>0x7F</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BWR</name>
              <description>Secure burst write programming mode
When set, this bit selects the burst write programming mode.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STRT</name>
              <description>Secure start 
This bit triggers a secure erase operation when set. If MER and PER bits are reset and the STRT bit is set, the PGSERR in the FLASH_SECSR is set (this condition is forbidden).
This bit is set only by software and is cleared when the BSY bit is cleared in FLASH_SECSR.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EOPIE</name>
              <description>Secure End of operation interrupt enable
This bit enables the interrupt generation when the EOP bit in FLASH_SECSR is set to 1.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Secure EOP Interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Secure EOP Interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ERRIE</name>
              <description>Secure error interrupt enable
This bit enables the interrupt generation when the OPERR bit in FLASH_SECSR is set to 1.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Secure OPERR error interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Secure OPERR error interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV</name>
              <description>Flash memory security state invert
This bit inverts the Flash memory security state.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCK</name>
              <description>Secure lock
This bit is set only. When set, the FLASH_SECCR1 register is locked. It is cleared by hardware after detecting the unlock sequence in FLASH_SECKEYR register.
In case of an unsuccessful unlock operation, this bit remains set until the next system reset.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASH_ECCR</name>
          <displayName>FLASH_ECCR</displayName>
          <description>FLASH ECC register</description>
          <addressOffset>0x030</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR_ECC</name>
              <description>ECC fail address
This field indicates which address is concerned by the ECC error correction or by the double ECC error detection. The address is given relative to Flash base address, from offset 0x00000 to 0xFFFF0.
Note that bit 19 is reserved on STM32WBAxEx devices.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>20</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSF_ECC</name>
              <description>System Flash memory ECC fail
This bit indicates that the ECC error correction or double ECC error detection is located in the system Flash memory.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ECCIE</name>
              <description>ECC correction interrupt enable
This bit enables the interrupt generation when the ECCC bit in the FLASH_ECCR register is set.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>ECCC interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>ECCC interrupt enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ECCC</name>
              <description>ECC correction
This bit is set by hardware when one ECC error has been detected and corrected (only if ECCC and ECCD were previously cleared). An interrupt is generated if ECCIE is set. This bit is cleared by writing 1.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ECCD</name>
              <description>ECC detection
This bit is set by hardware when two ECC errors have been detected (only if ECCC and ECCD were previously cleared). When this bit is set, a NMI is generated. This bit is cleared by writing 1.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASH_OPSR</name>
          <displayName>FLASH_OPSR</displayName>
          <description>FLASH operation status register</description>
          <addressOffset>0x034</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0F000000</resetMask>
          <fields>
            <field>
              <name>ADDR_OP</name>
              <description>Interrupted operation address
This field indicates which address in the Flash memory was accessed when reset occurred. The address is given relative to the Flash base address, from offset 0x00000 to 0xFFFF0.
Note that bit 19 is reserved on STM32WBAxEx devices.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>20</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSF_OP</name>
              <description>Operation in system Flash memory interrupted
This bit indicates that the reset occurred during an operation in the system Flash memory.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CODE_OP</name>
              <description>Flash memory operation code
This field indicates which Flash memory operation has been interrupted by a system reset:</description>
              <bitOffset>29</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No Flash operation interrupted by previous reset</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Single write operation interrupted</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>Burst write operation interrupted</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>Page erase operation interrupted</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>Mass erase operation interrupted</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x6</name>
                  <description>Option change operation interrupted</description>
                  <value>0x6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASH_NSCR2</name>
          <displayName>FLASH_NSCR2</displayName>
          <description>FLASH control 2 register</description>
          <addressOffset>0x038</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PS</name>
              <description>Program suspend request</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>program suspend disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>program suspend requested (enabled)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ES</name>
              <description>Erase suspend request</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>erase suspend disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>erase suspend requested (enabled)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASH_SECCR2</name>
          <displayName>FLASH_SECCR2</displayName>
          <description>FLASH secure control 2 register</description>
          <addressOffset>0x03C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PS</name>
              <description>Program suspend request</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>program suspend disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>program suspend requested (enabled)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ES</name>
              <description>Erase suspend request</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>erase suspend disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>erase suspend requested (enabled)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASH_OPTR</name>
          <displayName>FLASH_OPTR</displayName>
          <description>FLASH option register</description>
          <addressOffset>0x040</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>RDP</name>
              <description>Readout protection level
Others: Level 1 (memories readout protection active)
Note: Refer to Section7.6.2: Readout protection (RDP) for more details.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0xAA</name>
                  <description>Level 0 (readout protection not active)</description>
                  <value>0xAA</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x55</name>
                  <description>Level 0.5 (readout protection not active, only non-secure debug access is possible). Only available when TrustZone is active (TZEN=1)</description>
                  <value>0x55</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xCC</name>
                  <description>Level 2 (chip readout protection active)</description>
                  <value>0xCC</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BOR_LEV</name>
              <description>BOR reset level
These bits contain the VsubDD/sub supply level threshold that activates/releases the reset.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>BOR level 0 (reset level threshold around 1.7V)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>BOR level 1 (reset level threshold around 2.0V)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>BOR level 2 (reset level threshold around 2.2V)</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>BOR level 3 (reset level threshold around 2.5V)</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>BOR level 4 (reset level threshold around 2.8V)</description>
                  <value>0x4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NRST_STOP</name>
              <description>Reset generation in Stop mode</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Reset generated when entering the Stop mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>No reset generated when entering the Stop mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NRST_STDBY</name>
              <description>Reset generation in Standby mode</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Reset generated when entering the Standby mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>No reset generated when entering the Standby mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRAM1_RST</name>
              <description>SRAM1 erase upon system reset</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>SRAM1erased when a system reset occurs</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>SRAM1 not erased when a system reset occurs</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IWDG_SW</name>
              <description>Independent watchdog enable selection</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Hardware mode, independent watchdog started automatically be hardware on reset selected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Software mode, independent watchdog started by software command selected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IWDG_STOP</name>
              <description>Independent watchdog counter freeze in Stop mode</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Independent watchdog counter frozen in Stop mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Independent watchdog counter running in Stop mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IWDG_STDBY</name>
              <description>Independent watchdog counter freeze in Standby mode</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Independent watchdog counter frozen in Standby mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Independent watchdog counter running in Standby mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WWDG_SW</name>
              <description>Window watchdog selection</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Hardware window watchdog selected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Software window watchdog selected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRAM2_PE</name>
              <description>SRAM2 parity check enable</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>SRAM2 parity check enabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>SRAM2 parity check disabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRAM2_RST</name>
              <description>SRAM2 erase when system reset</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>SRAM2 erased when a system reset occurs</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>SRAM2 not erased when a system reset occurs</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NSWBOOT0</name>
              <description>Software BOOT0</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>BOOT0 taken from the option bit NBOOT0</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>BOOT0 taken from PH3/BOOT0 pin</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NBOOT0</name>
              <description>NBOOT0 option bit</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>NBOOT0 = 0</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>NBOOT0 = 1</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TZEN</name>
              <description>Global TrustZone security enable</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Global TrustZone security disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Global TrustZone security enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASH_NSBOOTADD0R</name>
          <displayName>FLASH_NSBOOTADD0R</displayName>
          <description>FLASH boot address 0 register</description>
          <addressOffset>0x044</addressOffset>
          <size>0x20</size>
          <resetValue>0x0000000F</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>NSBOOTADD0</name>
              <description>Non-secure boot base address 0
This address is only used when TZEN = 0.
The non-secure boot memory address can be programmed to any address in the valid address range (see Table 28: Boot space versus RDP protection) with a granularity of 128 bytes. These bits correspond to address [31:7]. The NSBOOTADD0 option bytes are selected following the BOOT0 pin or NSWBOOT0 state.
Examples:
NSBOOTADD0[24:0] = 0x0100000: Boot from Flash memory (0x0800 0000)
NSBOOTADD0[24:0] = 0x017F100: Boot from system memory bootloader (0x0BF8 8000)
NSBOOTADD0[24:0] = 0x0400200: Boot from SRAM2 on S-Bus (0x2001 0000)</description>
              <bitOffset>7</bitOffset>
              <bitWidth>25</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASH_NSBOOTADD1R</name>
          <displayName>FLASH_NSBOOTADD1R</displayName>
          <description>FLASH boot address 1 register</description>
          <addressOffset>0x048</addressOffset>
          <size>0x20</size>
          <resetValue>0x0000000F</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>NSBOOTADD1</name>
              <description>Non-secure boot address 1
This address is only used when TZEN = 0.
The non-secure boot memory address can be programmed to any address in the valid address range (see Table 28: Boot space versus RDP protection) with a granularity of 128 bytes. These bits correspond to address [31:7]. The NSBOOTADD0 option bytes are selected following the BOOT0 pin or NSWBOOT0 state. 
Examples:
NSBOOTADD1[24:0] = 0x0100000: Boot from Flash memory (0x0800 0000)
NSBOOTADD1[24:0] = 0x017F100: Boot from system memory bootloader (0x0BF8 8000)
NSBOOTADD1[24:0] = 0x0400200: Boot from SRAM2 (0x2001 0000)</description>
              <bitOffset>7</bitOffset>
              <bitWidth>25</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASH_SECBOOTADD0R</name>
          <displayName>FLASH_SECBOOTADD0R</displayName>
          <description>FLASH secure boot address 0 register</description>
          <addressOffset>0x04C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>BOOT_LOCK</name>
              <description>Boot lock
This lock is only used when TZEN = 0.
When set, the boot is always forced to base address value programmed in SECBOOTADD0[24:0] option bytes whatever the boot selection option. When set, this bit can only be cleared by an RDP regression level 1 to level 0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SECBOOTADD0</name>
              <description>Secure boot base address 0
This address is only used when TZEN = 1.
The secure boot memory address can be programmed to any address in the valid address range (see Table28: Boot space versus RDP protection) with a granularity of 128 bytes. This bits correspond to address [31:7] The SECBOOTADD0 option bytes are selected following the BOOT0 pin or NSWBOOT0 state. 
Examples:
SECBOOTADD0[24:0] = 0x018 0000: Boot from secure user Flash memory (0x0C00 0000)
SECBOOTADD0[24:0] = 0x01F F000: Boot from RSS system Flash memory (0x0FF8 0000)
SECBOOTADD0[24:0] = 0x060 0000: Boot from secure SRAM1 on S-Bus (0x3000 0000)</description>
              <bitOffset>7</bitOffset>
              <bitWidth>25</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASH_SECWMR1</name>
          <displayName>FLASH_SECWMR1</displayName>
          <description>FLASH secure watermark register 1</description>
          <addressOffset>0x050</addressOffset>
          <size>0x20</size>
          <resetValue>0xFF00FF00</resetValue>
          <resetMask>0xFF00FF00</resetMask>
          <fields>
            <field>
              <name>SECWM_PSTRT</name>
              <description>Start page of secure area
This field contains the first page of the secure area.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SECWM_PEND</name>
              <description>End page of secure area
This field contains the last page of the secure area.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASH_SECWMR2</name>
          <displayName>FLASH_SECWMR2</displayName>
          <description>FLASH secure watermark register 2</description>
          <addressOffset>0x054</addressOffset>
          <size>0x20</size>
          <resetValue>0x0F000F00</resetValue>
          <resetMask>0x0F000F00</resetMask>
          <fields>
            <field>
              <name>HDP_PEND</name>
              <description>End page of secure hide protection area
This field contains the last page of the secure HDP area.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HDPEN</name>
              <description>Secure Hide protection area enable</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No secure HDP area</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Secure HDP area enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASH_WRPAR</name>
          <displayName>FLASH_WRPAR</displayName>
          <description>FLASH WRP area A address register</description>
          <addressOffset>0x058</addressOffset>
          <size>0x20</size>
          <resetValue>0x0F00FF00</resetValue>
          <resetMask>0x0F00FF00</resetMask>
          <fields>
            <field>
              <name>WRPA_PSTRT</name>
              <description>WPR area A start page
This field contains the first page of the WPR area A.
Note that bit 6 is reserved on STM32WBAxEx devices.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WRPA_PEND</name>
              <description>WPR area A end page
This field contains the last page of the WPR area A.
Note that bit 22 is reserved on STM32WBAxEx devices.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UNLOCK</name>
              <description>WPR area A unlock</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>WRPA start and end pages locked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>WRPA start and end pages unlocked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASH_WRPBR</name>
          <displayName>FLASH_WRPBR</displayName>
          <description>FLASH WRP area B address register</description>
          <addressOffset>0x05C</addressOffset>
          <size>0x20</size>
          <resetValue>0x0F00FF00</resetValue>
          <resetMask>0x0F00FF00</resetMask>
          <fields>
            <field>
              <name>WRPB_PSTRT</name>
              <description>WRP area B start page
This field contains the first page of the WRP area B.
Note that bit 6 is reserved on STM32WBAxEx devices.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WRPB_PEND</name>
              <description>WRP area B end page
This field contains the last page of the WRP area B.
Note that bit 22 is reserved on STM32WBAxEx devices.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UNLOCK</name>
              <description>WPR area B unlock</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>WRPB start and end pages locked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>WRPB start and end pages unlocked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASH_OEM1KEYR1</name>
          <displayName>FLASH_OEM1KEYR1</displayName>
          <description>FLASH OEM1 key register 1</description>
          <addressOffset>0x070</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OEM1KEY</name>
              <description>OEM1 key least significant bytes</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASH_OEM1KEYR2</name>
          <displayName>FLASH_OEM1KEYR2</displayName>
          <description>FLASH OEM1 key register 2</description>
          <addressOffset>0x074</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OEM1KEY</name>
              <description>OEM1 key most significant bytes</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASH_OEM2KEYR1</name>
          <displayName>FLASH_OEM2KEYR1</displayName>
          <description>FLASH OEM2 key register 1</description>
          <addressOffset>0x078</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OEM2KEY</name>
              <description>OEM2 key least significant bytes</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASH_OEM2KEYR2</name>
          <displayName>FLASH_OEM2KEYR2</displayName>
          <description>FLASH OEM2 key register 2</description>
          <addressOffset>0x07C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OEM2KEY</name>
              <description>OEM2 key most significant bytes</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASH_SECBBR1</name>
          <displayName>FLASH_SECBBR1</displayName>
          <description>FLASH secure block based register 1</description>
          <addressOffset>0x80</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SECBB0</name>
              <description>page secure/non-secure attribution
Each bit is used to set one page security attribution.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash not block-based secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash block-based secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECBB1</name>
              <description>page secure/non-secure attribution
Each bit is used to set one page security attribution.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash not block-based secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash block-based secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECBB2</name>
              <description>page secure/non-secure attribution
Each bit is used to set one page security attribution.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash not block-based secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash block-based secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECBB3</name>
              <description>page secure/non-secure attribution
Each bit is used to set one page security attribution.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash not block-based secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash block-based secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECBB4</name>
              <description>page secure/non-secure attribution
Each bit is used to set one page security attribution.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash not block-based secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash block-based secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECBB5</name>
              <description>page secure/non-secure attribution
Each bit is used to set one page security attribution.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash not block-based secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash block-based secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECBB6</name>
              <description>page secure/non-secure attribution
Each bit is used to set one page security attribution.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash not block-based secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash block-based secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECBB7</name>
              <description>page secure/non-secure attribution
Each bit is used to set one page security attribution.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash not block-based secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash block-based secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECBB8</name>
              <description>page secure/non-secure attribution
Each bit is used to set one page security attribution.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash not block-based secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash block-based secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECBB9</name>
              <description>page secure/non-secure attribution
Each bit is used to set one page security attribution.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash not block-based secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash block-based secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECBB10</name>
              <description>page secure/non-secure attribution
Each bit is used to set one page security attribution.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash not block-based secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash block-based secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECBB11</name>
              <description>page secure/non-secure attribution
Each bit is used to set one page security attribution.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash not block-based secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash block-based secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECBB12</name>
              <description>page secure/non-secure attribution
Each bit is used to set one page security attribution.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash not block-based secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash block-based secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECBB13</name>
              <description>page secure/non-secure attribution
Each bit is used to set one page security attribution.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash not block-based secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash block-based secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECBB14</name>
              <description>page secure/non-secure attribution
Each bit is used to set one page security attribution.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash not block-based secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash block-based secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECBB15</name>
              <description>page secure/non-secure attribution
Each bit is used to set one page security attribution.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash not block-based secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash block-based secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECBB16</name>
              <description>page secure/non-secure attribution
Each bit is used to set one page security attribution.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash not block-based secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash block-based secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECBB17</name>
              <description>page secure/non-secure attribution
Each bit is used to set one page security attribution.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash not block-based secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash block-based secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECBB18</name>
              <description>page secure/non-secure attribution
Each bit is used to set one page security attribution.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash not block-based secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash block-based secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECBB19</name>
              <description>page secure/non-secure attribution
Each bit is used to set one page security attribution.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash not block-based secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash block-based secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECBB20</name>
              <description>page secure/non-secure attribution
Each bit is used to set one page security attribution.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash not block-based secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash block-based secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECBB21</name>
              <description>page secure/non-secure attribution
Each bit is used to set one page security attribution.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash not block-based secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash block-based secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECBB22</name>
              <description>page secure/non-secure attribution
Each bit is used to set one page security attribution.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash not block-based secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash block-based secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECBB23</name>
              <description>page secure/non-secure attribution
Each bit is used to set one page security attribution.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash not block-based secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash block-based secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECBB24</name>
              <description>page secure/non-secure attribution
Each bit is used to set one page security attribution.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash not block-based secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash block-based secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECBB25</name>
              <description>page secure/non-secure attribution
Each bit is used to set one page security attribution.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash not block-based secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash block-based secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECBB26</name>
              <description>page secure/non-secure attribution
Each bit is used to set one page security attribution.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash not block-based secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash block-based secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECBB27</name>
              <description>page secure/non-secure attribution
Each bit is used to set one page security attribution.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash not block-based secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash block-based secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECBB28</name>
              <description>page secure/non-secure attribution
Each bit is used to set one page security attribution.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash not block-based secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash block-based secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECBB29</name>
              <description>page secure/non-secure attribution
Each bit is used to set one page security attribution.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash not block-based secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash block-based secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECBB30</name>
              <description>page secure/non-secure attribution
Each bit is used to set one page security attribution.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash not block-based secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash block-based secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECBB31</name>
              <description>page secure/non-secure attribution
Each bit is used to set one page security attribution.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash not block-based secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash block-based secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASH_SECBBR2</name>
          <displayName>FLASH_SECBBR2</displayName>
          <description>FLASH secure block based register 2</description>
          <addressOffset>0x84</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SECBB0</name>
              <description>page secure/non-secure attribution
Each bit is used to set one page security attribution.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash not block-based secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash block-based secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECBB1</name>
              <description>page secure/non-secure attribution
Each bit is used to set one page security attribution.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash not block-based secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash block-based secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECBB2</name>
              <description>page secure/non-secure attribution
Each bit is used to set one page security attribution.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash not block-based secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash block-based secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECBB3</name>
              <description>page secure/non-secure attribution
Each bit is used to set one page security attribution.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash not block-based secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash block-based secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECBB4</name>
              <description>page secure/non-secure attribution
Each bit is used to set one page security attribution.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash not block-based secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash block-based secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECBB5</name>
              <description>page secure/non-secure attribution
Each bit is used to set one page security attribution.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash not block-based secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash block-based secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECBB6</name>
              <description>page secure/non-secure attribution
Each bit is used to set one page security attribution.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash not block-based secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash block-based secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECBB7</name>
              <description>page secure/non-secure attribution
Each bit is used to set one page security attribution.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash not block-based secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash block-based secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECBB8</name>
              <description>page secure/non-secure attribution
Each bit is used to set one page security attribution.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash not block-based secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash block-based secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECBB9</name>
              <description>page secure/non-secure attribution
Each bit is used to set one page security attribution.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash not block-based secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash block-based secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECBB10</name>
              <description>page secure/non-secure attribution
Each bit is used to set one page security attribution.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash not block-based secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash block-based secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECBB11</name>
              <description>page secure/non-secure attribution
Each bit is used to set one page security attribution.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash not block-based secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash block-based secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECBB12</name>
              <description>page secure/non-secure attribution
Each bit is used to set one page security attribution.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash not block-based secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash block-based secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECBB13</name>
              <description>page secure/non-secure attribution
Each bit is used to set one page security attribution.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash not block-based secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash block-based secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECBB14</name>
              <description>page secure/non-secure attribution
Each bit is used to set one page security attribution.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash not block-based secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash block-based secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECBB15</name>
              <description>page secure/non-secure attribution
Each bit is used to set one page security attribution.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash not block-based secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash block-based secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECBB16</name>
              <description>page secure/non-secure attribution
Each bit is used to set one page security attribution.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash not block-based secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash block-based secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECBB17</name>
              <description>page secure/non-secure attribution
Each bit is used to set one page security attribution.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash not block-based secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash block-based secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECBB18</name>
              <description>page secure/non-secure attribution
Each bit is used to set one page security attribution.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash not block-based secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash block-based secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECBB19</name>
              <description>page secure/non-secure attribution
Each bit is used to set one page security attribution.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash not block-based secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash block-based secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECBB20</name>
              <description>page secure/non-secure attribution
Each bit is used to set one page security attribution.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash not block-based secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash block-based secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECBB21</name>
              <description>page secure/non-secure attribution
Each bit is used to set one page security attribution.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash not block-based secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash block-based secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECBB22</name>
              <description>page secure/non-secure attribution
Each bit is used to set one page security attribution.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash not block-based secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash block-based secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECBB23</name>
              <description>page secure/non-secure attribution
Each bit is used to set one page security attribution.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash not block-based secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash block-based secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECBB24</name>
              <description>page secure/non-secure attribution
Each bit is used to set one page security attribution.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash not block-based secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash block-based secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECBB25</name>
              <description>page secure/non-secure attribution
Each bit is used to set one page security attribution.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash not block-based secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash block-based secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECBB26</name>
              <description>page secure/non-secure attribution
Each bit is used to set one page security attribution.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash not block-based secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash block-based secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECBB27</name>
              <description>page secure/non-secure attribution
Each bit is used to set one page security attribution.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash not block-based secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash block-based secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECBB28</name>
              <description>page secure/non-secure attribution
Each bit is used to set one page security attribution.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash not block-based secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash block-based secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECBB29</name>
              <description>page secure/non-secure attribution
Each bit is used to set one page security attribution.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash not block-based secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash block-based secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECBB30</name>
              <description>page secure/non-secure attribution
Each bit is used to set one page security attribution.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash not block-based secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash block-based secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECBB31</name>
              <description>page secure/non-secure attribution
Each bit is used to set one page security attribution.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash not block-based secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash block-based secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASH_SECHDPCR</name>
          <displayName>FLASH_SECHDPCR</displayName>
          <description>FLASH secure HDP control register</description>
          <addressOffset>0x0C0</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HDP_ACCDIS</name>
              <description>Secure HDP area access disable 
When set, this bit is only cleared by a system reset.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Access to secure HDP area granted</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Access to secure HDP area denied (SECWMRx option bytes modification blocked, refer to Rules for modifying specific option bytes)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASH_PRIFCFGR</name>
          <displayName>FLASH_PRIFCFGR</displayName>
          <description>FLASH privilege configuration register</description>
          <addressOffset>0x0C4</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SPRIV</name>
              <description>Privileged protection for secure registers
This bit is secure write protected. It can only be written by a secure privileged access when TrustZone is enabled (TZEN=1).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Secure Flash registers can be read and written by privileged or unprivileged access.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Secure Flash registers can be read and written by privileged access only.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NSPRIV</name>
              <description>Privileged protection for non-secure registers</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Non-secure Flash registers can be read and written by privileged or unprivileged access.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Non-secure Flash registers can be read and written by privileged access only.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASH_PRIVBBR1</name>
          <displayName>FLASH_PRIVBBR1</displayName>
          <description>FLASH privilege block based register 1</description>
          <addressOffset>0xD0</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRIVBB0</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB1</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB2</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB3</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB4</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB5</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB6</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB7</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB8</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB9</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB10</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB11</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB12</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB13</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB14</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB15</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB16</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB17</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB18</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB19</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB20</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB21</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB22</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB23</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB24</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB25</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB26</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB27</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB28</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB29</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB30</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB31</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASH_PRIVBBR2</name>
          <displayName>FLASH_PRIVBBR2</displayName>
          <description>FLASH privilege block based register 2</description>
          <addressOffset>0xD4</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRIVBB0</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB1</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB2</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB3</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB4</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB5</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB6</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB7</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB8</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB9</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB10</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB11</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB12</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB13</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB14</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB15</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB16</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB17</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB18</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB19</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB20</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB21</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB22</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB23</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB24</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB25</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB26</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB27</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB28</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB29</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB30</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB31</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASH_PRIVBBR3</name>
          <displayName>FLASH_PRIVBBR3</displayName>
          <description>FLASH privilege block based register 3</description>
          <addressOffset>0xD8</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRIVBB0</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB1</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB2</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB3</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB4</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB5</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB6</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB7</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB8</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB9</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB10</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB11</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB12</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB13</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB14</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB15</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB16</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB17</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB18</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB19</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB20</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB21</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB22</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB23</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB24</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB25</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB26</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB27</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB28</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB29</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB30</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB31</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASH_PRIVBBR4</name>
          <displayName>FLASH_PRIVBBR4</displayName>
          <description>FLASH privilege block based register 4</description>
          <addressOffset>0xDC</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRIVBB0</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB1</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB2</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB3</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB4</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB5</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB6</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB7</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB8</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB9</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB10</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB11</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB12</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB13</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB14</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB15</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB16</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB17</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB18</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB19</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB20</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB21</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB22</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB23</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB24</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB25</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB26</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB27</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB28</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB29</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB30</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIVBB31</name>
              <description>page privileged/unprivileged attribution
Each bit is used to set one page privilege attribution in Flash.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Page (32 x (x - 1) + y) in Flash accessible by unprivileged access</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Page (32 x (x - 1) + y) in Flash only accessible by privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GPDMA</name>
      <description>General purpose direct memory access controller</description>
      <groupName>GPDMA</groupName>
      <baseAddress>0x40020000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>GPDMA1_CH0</name>
        <description>GPDMA1 channel 0 global interrupt</description>
        <value>029</value>
      </interrupt>
      <interrupt>
        <name>GPDMA1_CH1</name>
        <description>GPDMA1 channel 1 global interrupt</description>
        <value>030</value>
      </interrupt>
      <interrupt>
        <name>GPDMA1_CH2</name>
        <description>GPDMA1 channel 2 global interrupt</description>
        <value>031</value>
      </interrupt>
      <interrupt>
        <name>GPDMA1_CH3</name>
        <description>GPDMA1 channel 3 global interrupt</description>
        <value>032</value>
      </interrupt>
      <interrupt>
        <name>GPDMA1_CH4</name>
        <description>GPDMA1 channel 4 global interrupt</description>
        <value>033</value>
      </interrupt>
      <interrupt>
        <name>GPDMA1_CH5</name>
        <description>GPDMA1 channel 5 global interrupt</description>
        <value>034</value>
      </interrupt>
      <interrupt>
        <name>GPDMA1_CH6</name>
        <description>GPDMA1 channel 6 global interrupt</description>
        <value>035</value>
      </interrupt>
      <interrupt>
        <name>GPDMA1_CH7</name>
        <description>GPDMA1 channel 7 global interrupt</description>
        <value>036</value>
      </interrupt>
      <registers>
        <register>
          <name>GPDMA_SECCFGR</name>
          <displayName>GPDMA_SECCFGR</displayName>
          <description>GPDMA secure configuration register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SEC0</name>
              <description>secure state of channel x</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>non-secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEC1</name>
              <description>secure state of channel x</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>non-secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEC2</name>
              <description>secure state of channel x</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>non-secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEC3</name>
              <description>secure state of channel x</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>non-secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEC4</name>
              <description>secure state of channel x</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>non-secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEC5</name>
              <description>secure state of channel x</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>non-secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEC6</name>
              <description>secure state of channel x</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>non-secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEC7</name>
              <description>secure state of channel x</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>non-secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_PRIVCFGR</name>
          <displayName>GPDMA_PRIVCFGR</displayName>
          <description>GPDMA privileged configuration register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRIV0</name>
              <description>privileged state of channel x</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>unprivileged</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>privileged</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIV1</name>
              <description>privileged state of channel x</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>unprivileged</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>privileged</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIV2</name>
              <description>privileged state of channel x</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>unprivileged</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>privileged</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIV3</name>
              <description>privileged state of channel x</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>unprivileged</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>privileged</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIV4</name>
              <description>privileged state of channel x</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>unprivileged</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>privileged</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIV5</name>
              <description>privileged state of channel x</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>unprivileged</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>privileged</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIV6</name>
              <description>privileged state of channel x</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>unprivileged</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>privileged</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIV7</name>
              <description>privileged state of channel x</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>unprivileged</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>privileged</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_RCFGLOCKR</name>
          <displayName>GPDMA_RCFGLOCKR</displayName>
          <description>GPDMA configuration lock register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LOCK0</name>
              <description>lock the configuration of GPDMA_SECCFGR.SECx and GPDMA_PRIVCFGR.PRIVx, until a global GPDMA reset
This bit is cleared after reset and, once set, it cannot be reset until a global GPDMA reset.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>secure privilege configuration of the channel x is writable.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>secure privilege configuration of the channel x is not writable.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LOCK1</name>
              <description>lock the configuration of GPDMA_SECCFGR.SECx and GPDMA_PRIVCFGR.PRIVx, until a global GPDMA reset
This bit is cleared after reset and, once set, it cannot be reset until a global GPDMA reset.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>secure privilege configuration of the channel x is writable.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>secure privilege configuration of the channel x is not writable.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LOCK2</name>
              <description>lock the configuration of GPDMA_SECCFGR.SECx and GPDMA_PRIVCFGR.PRIVx, until a global GPDMA reset
This bit is cleared after reset and, once set, it cannot be reset until a global GPDMA reset.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>secure privilege configuration of the channel x is writable.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>secure privilege configuration of the channel x is not writable.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LOCK3</name>
              <description>lock the configuration of GPDMA_SECCFGR.SECx and GPDMA_PRIVCFGR.PRIVx, until a global GPDMA reset
This bit is cleared after reset and, once set, it cannot be reset until a global GPDMA reset.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>secure privilege configuration of the channel x is writable.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>secure privilege configuration of the channel x is not writable.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LOCK4</name>
              <description>lock the configuration of GPDMA_SECCFGR.SECx and GPDMA_PRIVCFGR.PRIVx, until a global GPDMA reset
This bit is cleared after reset and, once set, it cannot be reset until a global GPDMA reset.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>secure privilege configuration of the channel x is writable.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>secure privilege configuration of the channel x is not writable.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LOCK5</name>
              <description>lock the configuration of GPDMA_SECCFGR.SECx and GPDMA_PRIVCFGR.PRIVx, until a global GPDMA reset
This bit is cleared after reset and, once set, it cannot be reset until a global GPDMA reset.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>secure privilege configuration of the channel x is writable.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>secure privilege configuration of the channel x is not writable.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LOCK6</name>
              <description>lock the configuration of GPDMA_SECCFGR.SECx and GPDMA_PRIVCFGR.PRIVx, until a global GPDMA reset
This bit is cleared after reset and, once set, it cannot be reset until a global GPDMA reset.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>secure privilege configuration of the channel x is writable.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>secure privilege configuration of the channel x is not writable.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LOCK7</name>
              <description>lock the configuration of GPDMA_SECCFGR.SECx and GPDMA_PRIVCFGR.PRIVx, until a global GPDMA reset
This bit is cleared after reset and, once set, it cannot be reset until a global GPDMA reset.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>secure privilege configuration of the channel x is writable.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>secure privilege configuration of the channel x is not writable.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_MISR</name>
          <displayName>GPDMA_MISR</displayName>
          <description>GPDMA non-secure masked interrupt status register</description>
          <addressOffset>0x0C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MIS0</name>
              <description>masked interrupt status of channel x</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no interrupt occurred on channel x</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>an interrupt occurred on channel x</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MIS1</name>
              <description>masked interrupt status of channel x</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no interrupt occurred on channel x</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>an interrupt occurred on channel x</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MIS2</name>
              <description>masked interrupt status of channel x</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no interrupt occurred on channel x</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>an interrupt occurred on channel x</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MIS3</name>
              <description>masked interrupt status of channel x</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no interrupt occurred on channel x</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>an interrupt occurred on channel x</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MIS4</name>
              <description>masked interrupt status of channel x</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no interrupt occurred on channel x</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>an interrupt occurred on channel x</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MIS5</name>
              <description>masked interrupt status of channel x</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no interrupt occurred on channel x</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>an interrupt occurred on channel x</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MIS6</name>
              <description>masked interrupt status of channel x</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no interrupt occurred on channel x</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>an interrupt occurred on channel x</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MIS7</name>
              <description>masked interrupt status of channel x</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no interrupt occurred on channel x</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>an interrupt occurred on channel x</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_SMISR</name>
          <displayName>GPDMA_SMISR</displayName>
          <description>GPDMA secure masked interrupt status register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MIS0</name>
              <description>masked interrupt status of the secure channel x</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no interrupt occurred on the secure channel x</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>an interrupt occurred on the secure channel x</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MIS1</name>
              <description>masked interrupt status of the secure channel x</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no interrupt occurred on the secure channel x</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>an interrupt occurred on the secure channel x</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MIS2</name>
              <description>masked interrupt status of the secure channel x</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no interrupt occurred on the secure channel x</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>an interrupt occurred on the secure channel x</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MIS3</name>
              <description>masked interrupt status of the secure channel x</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no interrupt occurred on the secure channel x</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>an interrupt occurred on the secure channel x</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MIS4</name>
              <description>masked interrupt status of the secure channel x</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no interrupt occurred on the secure channel x</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>an interrupt occurred on the secure channel x</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MIS5</name>
              <description>masked interrupt status of the secure channel x</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no interrupt occurred on the secure channel x</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>an interrupt occurred on the secure channel x</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MIS6</name>
              <description>masked interrupt status of the secure channel x</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no interrupt occurred on the secure channel x</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>an interrupt occurred on the secure channel x</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MIS7</name>
              <description>masked interrupt status of the secure channel x</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no interrupt occurred on the secure channel x</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>an interrupt occurred on the secure channel x</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C0LBAR</name>
          <displayName>GPDMA_C0LBAR</displayName>
          <description>GPDMA channel 0 linked-list base address register</description>
          <addressOffset>0x50</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LBA</name>
              <description>linked-list base address of GPDMA channel x</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C0FCR</name>
          <displayName>GPDMA_C0FCR</displayName>
          <description>GPDMA channel 0 flag clear register</description>
          <addressOffset>0x5C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TCF</name>
              <description>transfer complete flag clear</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>corresponding TCF flag cleared</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HTF</name>
              <description>half transfer flag clear</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>corresponding HTF flag cleared</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DTEF</name>
              <description>data transfer error flag clear</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>corresponding DTEF flag cleared</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ULEF</name>
              <description>update link transfer error flag clear</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>corresponding ULEF flag cleared</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>USEF</name>
              <description>user setting error flag clear</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>corresponding USEF flag cleared</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SUSPF</name>
              <description>completed suspension flag clear</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>corresponding SUSPF flag cleared</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TOF</name>
              <description>trigger overrun flag clear</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>corresponding TOF flag cleared</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C0SR</name>
          <displayName>GPDMA_C0SR</displayName>
          <description>GPDMA channel 0 status register</description>
          <addressOffset>0x60</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IDLEF</name>
              <description>idle flag
This idle flag is deasserted by hardware when the channel is enabled (GPDMA_CxCR.EN = 1) with a valid channel configuration (no USEF to be immediately reported).
This idle flag is asserted after hard reset or by hardware when the channel is back in idle state (in suspended or disabled state).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>channel not in idle state</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>channel in idle state</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TCF</name>
              <description>transfer complete flag
A transfer complete event is either a block transfer complete, or a LLI transfer complete including the upload of the next LLI if any, or the full linked-list completion, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0]).</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no transfer complete event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>a transfer complete event occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HTF</name>
              <description>half transfer flag
A half block transfer occurs when half of the bytes of the source block size (rounded up integer of GPDMA_CxBR1.BNDT[15:0]/2) has been transferred to the destination.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no half transfer event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>a half transfer event occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DTEF</name>
              <description>data transfer error flag</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no data transfer error event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>a master bus error event occurred on a data transfer</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ULEF</name>
              <description>update link transfer error flag</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no update link transfer error event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>a master bus error event occurred while updating a linked-list register from memory</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>USEF</name>
              <description>user setting error flag</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no user setting error event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>a user setting error event occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SUSPF</name>
              <description>completed suspension flag</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no completed suspension event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>a completed suspension event occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TOF</name>
              <description>trigger overrun flag</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no trigger overrun event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>a trigger overrun event occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FIFOL</name>
              <description>monitored FIFO level
Number of available write beats in the FIFO, in units of the programmed destination data width (see GPDMA_CxTR1.DDW_LOG2[1:0], in units of bytes, half-words, or words).
Note: After having suspended an active transfer, the user may need to read FIFOL[7:0], additionally to GPDMA_CxBR1.BDNT[15:0] to know how many data have been transferred to the destination. Before reading, the user may wait for the transfer to be suspended (GPDMA_CxSR.SUSPF = 1).</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C0CR</name>
          <displayName>GPDMA_C0CR</displayName>
          <description>GPDMA channel 0 control register</description>
          <addressOffset>0x64</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>enable
Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 0. Else: 
this bit is deasserted by hardware when there is a transfer error (master bus error or user setting error) or when there is a channel transfer complete (channel ready to be configured, for example if LSM=1 at the end of a single execution of the LLI).
Else, this bit can be asserted by software. 
Writing 0 into this EN bit is ignored.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>write: ignored, read: channel disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>write: enable channel, read: channel enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESET</name>
              <description>reset
This bit is write only. Writing 0 has no impact. Writing 1 implies the reset of the following: the FIFO, the channel internal state, SUSP and EN bits (whatever is written receptively in bit 2 and bit 0).
The reset is effective when the channel is in steady state, meaning one of the following:
- active channel in suspended state (GPDMA_CxSR.SUSPF = 1 and GPDMA_CxSR.IDLEF = GPDMA_CxCR.EN = 1)
- channel in disabled state (GPDMA_CxSR.IDLEF = 1 and GPDMA_CxCR.EN = 0).
After writing a RESET, to continue using this channel, the user must explicitly reconfigure the channel including the hardware-modified configuration registers (GPDMA_CxBR1, GPDMA_CxSAR and GPDMA_CxDAR) before enabling again the channel (see the programming sequence in Figure 44).</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no channel reset</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>channel reset</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SUSP</name>
              <description>suspend
Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 2. Else:
Software must write 1 in order to suspend an active channel (channel with an ongoing GPDMA transfer over its master ports). 
The software must write 0 in order to resume a suspended channel, following the programming sequence detailed in Figure 43.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>write: resume channel, read: channel not suspended</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>write: suspend channel, read: channel suspended.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TCIE</name>
              <description>transfer complete interrupt enable</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HTIE</name>
              <description>half transfer complete interrupt enable</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DTEIE</name>
              <description>data transfer error interrupt enable</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ULEIE</name>
              <description>update link transfer error interrupt enable</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>USEIE</name>
              <description>user setting error interrupt enable</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SUSPIE</name>
              <description>completed suspension interrupt enable</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TOIE</name>
              <description>trigger overrun interrupt enable</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LSM</name>
              <description>Link step mode
First the (possible 1D/repeated) block transfer is executed as defined by the current internal register file until GPDMA_CxBR1.BNDT[15:0] = 0. Secondly the next linked-list data structure is conditionally uploaded from memory as defined by GPDMA_CxLLR. Then channel execution is completed.
Note: This bit must be written when EN=0. This bit is read-only when EN=1.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>channel executed for the full linked-list and completed at the end of the last LLI (GPDMA_CxLLR = 0). The 16 low-significant bits of the link address are null (LA[15:0] = 0) and all the update bits are null (UT1 =UB1 = UT2 = USA = UDA = ULL = 0). Then GPDMA_CxBR1.BNDT[15:0] = 0.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>channel executed once for the current LLI</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LAP</name>
              <description>linked-list allocated port
This bit is used to allocate the master port for the update of the GPDMA linked-list registers from the memory.
Note: This bit must be written when EN=0. This bit is read-only when EN=1.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>port 0 (AHB) allocated</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>port 1 (AHB) allocated</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>priority level of the channel x GPDMA transfer versus others
Note: This bit must be written when EN = 0. This bit is read-only when EN = 1.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>low priority, low weight</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>low priority, mid weight</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>low priority, high weight</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>high priority</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C0TR1</name>
          <displayName>GPDMA_C0TR1</displayName>
          <description>GPDMA channel 0 transfer register 1</description>
          <addressOffset>0x90</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SDW_LOG2</name>
              <description>binary logarithm of the source data width of a burst in bytes
Setting a 8-byte data width causes a user setting error to be reported and no transfer is issued.
A source block size must be a multiple of the source data width (GPDMA_CxBR1.BNDT[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and no transfer is issued.
Note: A source burst transfer must have an aligned address with its data width (start address GPDMA_CxSAR[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and none transfer is issued.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>byte</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>half-word (2 bytes)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>word (4 bytes)</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>user setting error reported and no transfer issued</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SINC</name>
              <description>source incrementing burst
The source address, pointed by GPDMA_CxSAR, is kept constant after a burst beat/single transfer or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>fixed burst</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>contiguously incremented burst</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SBL_1</name>
              <description>source burst length minus 1, between 0 and 63
The burst length unit is one data named beat within a burst. If SBL_1[5:0] =0 , the burst can be named as single. Each data/beat has a width defined by the destination data width SDW_LOG2[1:0].
Note: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol.
Note: If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower singles/bursts, but the data integrity is guaranteed.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PAM</name>
              <description>padding/alignment mode
If DDW_LOG2[1:0] = SDW_LOG2[1:0]: if the data width of a burst destination transfer is equal to the data width of a burst source transfer, these bits are ignored.
Else, in the following enumerated values, the condition PAM_1 is when destination data width is higher that source data width, and the condition PAM_2 is when destination data width is higher than source data width.
1x: successive source data are FIFO queued and packed at the destination data width, in a left (LSB) to right (MSB) order (named little endian), before a destination transfer
Note: 1x: source data is FIFO queued and unpacked at the destination data width, to be transferred in a left (LSB) to right (MSB) order (named little endian) to the destination</description>
              <bitOffset>11</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0_PAM_1</name>
                  <description>source data is transferred as right aligned, padded with 0s up to the destination data width</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1_PAM_1</name>
                  <description>source data is transferred as right aligned, sign extended up to the destination data width</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SBX</name>
              <description>source byte exchange within the unaligned half-word of each source word 
If the source data width is shorter than a word, this bit is ignored.
If the source data width is a word:</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no byte-based exchange within the unaligned half-word of each source word</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>the two consecutive bytes within the unaligned half-word of each source word are exchanged.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SAP</name>
              <description>source allocated port
This bit is used to allocate the master port for the source transfer
Note: This bit must be written when EN = 0. This bit is read-only when EN = 1.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>port 0 (AHB) allocated</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>port 1 (AHB) allocated</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SSEC</name>
              <description>security attribute of the GPDMA transfer from the source
If GPDMA_SECCFGR.SECx = 1 and the access is secure:
This is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx =1 . A secure write is ignored when GPDMA_SECCFGR.SECx = 0.
When GPDMA_SECCFGR.SECx is deasserted, this SSEC bit is also deasserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer from the source is non-secure.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>GPDMA transfer non-secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GPDMA transfer secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DDW_LOG2</name>
              <description>binary logarithm of the destination data width of a burst, in bytes
Setting a 8-byte data width causes a user setting error to be reported and none transfer is issued.
Note: A destination burst transfer must have an aligned address with its data width (start address GPDMA_CxDAR[2:0] versus DDW_LOG2[1:0]). Otherwise a user setting error is reported and no transfer is issued.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>byte</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>half-word (2 bytes)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>word (4 bytes)</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>user setting error reported and no transfer issued</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DINC</name>
              <description>destination incrementing burst
The destination address, pointed by GPDMA_CxDAR, is kept constant after a burst beat/single transfer, or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>fixed burst</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>contiguously incremented burst</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DBL_1</name>
              <description>destination burst length minus 1, between 0 and 63
The burst length unit is one data named beat within a burst. If DBL_1[5:0] =0 , the burst can be named as single. Each data/beat has a width defined by the destination data width DDW_LOG2[1:0].
Note: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol.
Note: If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower singles/bursts, but the data integrity is guaranteed.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DBX</name>
              <description>destination byte exchange
If the destination data size is a byte, this bit is ignored.
If the destination data size is not a byte:</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no byte-based exchange within half-word</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>the two consecutive (post PAM) bytes are exchanged in each destination half-word.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DHX</name>
              <description>destination half-word exchange
If the destination data size is shorter than a word, this bit is ignored.
If the destination data size is a word:</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no halfword-based exchanged within word</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>the two consecutive (post PAM) half-words are exchanged in each destination word.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DAP</name>
              <description>destination allocated port
This bit is used to allocate the master port for the destination transfer
Note: This bit must be written when EN = 0. This bit is read-only when EN = 1.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>port 0 (AHB) allocated</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>port 1 (AHB) allocated</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DSEC</name>
              <description>security attribute of the GPDMA transfer to the destination
If GPDMA_SECCFGR.SECx = 1 and the access is secure:
This is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx = 1. A secure write is ignored when GPDMA_SECCFGR.SECx = 0.
When GPDMA_SECCFGR.SECx is deasserted, this DSEC bit is also deasserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer to the destination is non-secure.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>GPDMA transfer non-secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GPDMA transfer secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C0TR2</name>
          <displayName>GPDMA_C0TR2</displayName>
          <description>GPDMA channel 0 transfer register 2</description>
          <addressOffset>0x94</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REQSEL</name>
              <description>GPDMA hardware request selection
These bits are ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer). Else, the selected hardware request is internally taken into account as per Section 16.3.3.
The user must not assign a same input hardware request (same REQSEL[5:0] value) to different active GPDMA channels (GPDMA_CxCR.EN = 1 and GPDMA_CxTR2.SWREQ = 0 for these channels). GPDMA is not intended to hardware support the case of simultaneous enabled channels incorrectly configured with a same hardware peripheral request signal, and there is no user setting error reporting.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SWREQ</name>
              <description>software request
This bit is internally taken into account when GPDMA_CxCR.EN is asserted.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no software request. The selected hardware request REQSEL[5:0] is taken into account.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>software request for a memory-to-memory transfer. The default selected hardware request as per REQSEL[5:0] is ignored.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DREQ</name>
              <description>destination hardware request
This bit is ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer). Else:</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>selected hardware request driven by a source peripheral (request signal taken into account by the GPDMA transfer scheduler over the source/read port)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>selected hardware request driven by a destination peripheral (request signal taken into account by the GPDMA transfer scheduler over the destination/write port)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BREQ</name>
              <description>Block hardware request
If the channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer), this bit is ignored. Else:</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>the selected hardware request is driven by a peripheral with a hardware request/acknowledge protocol at a burst level.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>the selected hardware request is driven by a peripheral with a hardware request/acknowledge protocol at a block level (see Section 16.3.3).</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TRIGM</name>
              <description>trigger mode
These bits define the transfer granularity for its conditioning by the trigger.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>at block level: the first burst read of each block transfer is conditioned by one hit trigger .</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>channel x = 0 to 7, same as 0010: at link level: a LLI link transfer is conditioned by one hit trigger. The LLI data transfer (if any) is not conditioned.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>at programmed burst level: If SWREQ = 1, each programmed burst read is conditioned by one hit trigger. If SWREQ = 0, each programmed burst that is requested by the selected peripheral, is conditioned by one hit trigger.</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TRIGSEL</name>
              <description>trigger event input selection
These bits select the trigger event input of the GPDMA transfer (as per Section 16.3.5), with an active trigger event if TRIGPOL[1:0] different 00.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIGPOL</name>
              <description>trigger event polarity
These bits define the polarity of the selected trigger event input defined by TRIGSEL[4:0].</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no trigger (masked trigger event)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>trigger on the rising edge</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>trigger on the falling edge</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>same as 00</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TCEM</name>
              <description>transfer complete event mode
These bits define the transfer granularity for the transfer complete and half transfer complete events generation.
Note: If the initial LLIsub0 /subdata transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] = 0), then neither the complete transfer event nor the half transfer event is generated.
Note: If the initial LLIsub0 /subdata transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] = 0), then neither the complete transfer event nor the half transfer event is generated.
Note: If the initial LLIsub0 /subdata transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] =0 ), then the half transfer event is not generated, and the transfer complete event is generated when is completed the loading of the LLIsub1/sub.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>at block level (when GPDMA_CxBR1.BNDT[15:0] = 0): the complete (and the half) transfer event is generated at the (respectively half of the) end of a block.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>channel x (0 to 7, same as 00</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>at LLI level: the complete transfer event is generated at the end of the LLI transfer, including the update of the LLI if any. The half transfer event is generated at the half of the LLI data transfer.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>at channel level: the complete transfer event is generated at the end of the last LLI transfer. The half transfer event is generated at the half of the data transfer of the last LLI. The last LLI updates the link address GPDMA_CxLLR.LA[15:2] to zero and clears all the GPDMA_CxLLR update bits (UT1, UT2, UB1, USA, UDA and ULL). If the channel transfer is continuous/infinite, no event is generated.</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C0BR1</name>
          <displayName>GPDMA_C0BR1</displayName>
          <description>GPDMA channel 0 block register 1</description>
          <addressOffset>0x98</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BNDT</name>
              <description>block number of data bytes to transfer from the source
Block size transferred from the source. When the channel is enabled, this field becomes read-only and is decremented, indicating the remaining number of data items in the current source block to be transferred. BNDT[15:0] is programmed in number of bytes, maximum source block size is 64 Kbytes -1.
Once the last data transfer is completed (BNDT[15:0] = 0):
- if GPDMA_CxLLR.UB1 = 1, this field is updated by the LLI in the memory.
- if GPDMA_CxLLR.UB1 = 0 and if there is at least one non null Uxx update bit, this field is internally restored to the programmed value.
- if all GPDMA_CxLLR.Uxx = 0 and if GPDMA_CxLLR.LA[15:0] = 0, this field is internally restored to the programmed value (infinite/continuous last LLI).
- if GPDMA_CxLLR = 0, this field is kept as zero following the last LLI data transfer.
Note: A non-null source block size must be a multiple of the source data width (BNDT[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.
Note: When configured in packing mode (GPDMA_CxTR1.PAM[1] = 1 and destination data width different from source data width), a non-null source block size must be a multiple of the destination data width (BNDT[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C0SAR</name>
          <displayName>GPDMA_C0SAR</displayName>
          <description>GPDMA channel 0 source address register</description>
          <addressOffset>0x9C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SA</name>
              <description>source address
This field is the pointer to the address from which the next data is read.
During the channel activity, depending on the source addressing mode (GPDMA_CxTR1.SINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.SDW_LOG2[1:0]) after each burst source data, reflecting the next address from which data is read.
During the channel activity, this address is updated after each completed source burst, consequently to:
the programmed source burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.SINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.SBL_1[5:0] and GPDMA_CxTR1.SDW_LOG2[21:0]
the additional source incremented/decremented offset value as programmed by GPDMA_CxBR1.SDEC
In linked-list mode, after a LLI data transfer is completed, this register is automatically updated by GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.USA = 1.
Note: A source address must be aligned with the programmed data width of a source burst (SA[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C0DAR</name>
          <displayName>GPDMA_C0DAR</displayName>
          <description>GPDMA channel 0 destination address register</description>
          <addressOffset>0xA0</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DA</name>
              <description>destination address
This field is the pointer to the address from which the next data is written.
During the channel activity, depending on the destination addressing mode (GPDMA_CxTR1.DINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.DDW_LOG2[21:0]) after each burst destination data, reflecting the next address from which data is written.
During the channel activity, this address is updated after each completed destination burst, consequently to:
the programmed destination burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.DINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.DBL_1[5:0] and GPDMA_CxTR1.DDW_LOG2[1:0]
the additional destination incremented/decremented offset value as programmed by GPDMA_CxBR1.DDEC.
In linked-list mode, after a LLI data transfer is completed, this register is automatically updated by the GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.UDA = 1.
Note: A destination address must be aligned with the programmed data width of a destination burst (DA[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C0LLR</name>
          <displayName>GPDMA_C0LLR</displayName>
          <description>GPDMA channel 0 linked-list address register</description>
          <addressOffset>0xCC</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LA</name>
              <description>pointer (16-bit low-significant address) to the next linked-list data structure
If UT1 = UT2 = UB1 = USA = UDA = ULL = 0 and if LA[15:20] = 0, the current LLI is the last one. The channel transfer is completed without any update of the linked-list GPDMA register file.
Else, this field is the pointer to the memory address offset from which the next linked-list data structure is automatically fetched from, once the data transfer is completed, in order to conditionally update the linked-list GPDMA internal register file (GPDMA_CxCTR1, GPDMA_CxTR2, GPDMA_CxBR1, GPDMA_CxSAR, GPDMA_CxDAR and GPDMA_CxLLR).
Note: The user must program the pointer to be 32-bit aligned. The two low-significant bits are write ignored.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>14</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ULL</name>
              <description>Update GPDMA_CxLLR register from memory
This bit is used to control the update of GPDMA_CxLLR from the memory during the link transfer.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no GPDMA_CxLLR update</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GPDMA_CxLLR update</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UDA</name>
              <description>Update GPDMA_CxDAR register from memory
This bit is used to control the update of GPDMA_CxDAR from the memory during the link transfer.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no GPDMA_CxDAR update</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GPDMA_CxDAR update</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>USA</name>
              <description>update GPDMA_CxSAR from memory
This bit controls the update of GPDMA_CxSAR from the memory during the link transfer.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no GPDMA_CxSAR update</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GPDMA_CxSAR update</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UB1</name>
              <description>Update GPDMA_CxBR1 from memory
This bit controls the update of GPDMA_CxBR1 from the memory during the link transfer. If UB1 = 0 and if GPDMA_CxLLR different 0, the linked-list is not completed. GPDMA_CxBR1.BNDT[15:0] is then restored to the programmed value after data transfer is completed and before the link transfer.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no GPDMA_CxBR1 update from memory (GPDMA_CxBR1.BNDT[15:0] restored if any link transfer)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GPDMA_CxBR1 update</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UT2</name>
              <description>Update GPDMA_CxTR2 from memory
This bit controls the update of GPDMA_CxTR2 from the memory during the link transfer.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no GPDMA_CxTR2 update</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GPDMA_CxTR2 update</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UT1</name>
              <description>Update GPDMA_CxTR1 from memory
This bit controls the update of GPDMA_CxTR1 from the memory during the link transfer.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no GPDMA_CxTR1 update</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GPDMA_CxTR1 update</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C1LBAR</name>
          <displayName>GPDMA_C1LBAR</displayName>
          <description>GPDMA channel 1 linked-list base address register</description>
          <addressOffset>0xD0</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LBA</name>
              <description>linked-list base address of GPDMA channel x</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C1FCR</name>
          <displayName>GPDMA_C1FCR</displayName>
          <description>GPDMA channel 1 flag clear register</description>
          <addressOffset>0xDC</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TCF</name>
              <description>transfer complete flag clear</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>corresponding TCF flag cleared</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HTF</name>
              <description>half transfer flag clear</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>corresponding HTF flag cleared</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DTEF</name>
              <description>data transfer error flag clear</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>corresponding DTEF flag cleared</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ULEF</name>
              <description>update link transfer error flag clear</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>corresponding ULEF flag cleared</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>USEF</name>
              <description>user setting error flag clear</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>corresponding USEF flag cleared</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SUSPF</name>
              <description>completed suspension flag clear</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>corresponding SUSPF flag cleared</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TOF</name>
              <description>trigger overrun flag clear</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>corresponding TOF flag cleared</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C1SR</name>
          <displayName>GPDMA_C1SR</displayName>
          <description>GPDMA channel 1 status register</description>
          <addressOffset>0xE0</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IDLEF</name>
              <description>idle flag
This idle flag is deasserted by hardware when the channel is enabled (GPDMA_CxCR.EN = 1) with a valid channel configuration (no USEF to be immediately reported).
This idle flag is asserted after hard reset or by hardware when the channel is back in idle state (in suspended or disabled state).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>channel not in idle state</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>channel in idle state</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TCF</name>
              <description>transfer complete flag
A transfer complete event is either a block transfer complete, or a LLI transfer complete including the upload of the next LLI if any, or the full linked-list completion, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0]).</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no transfer complete event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>a transfer complete event occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HTF</name>
              <description>half transfer flag
A half block transfer occurs when half of the bytes of the source block size (rounded up integer of GPDMA_CxBR1.BNDT[15:0]/2) has been transferred to the destination.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no half transfer event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>a half transfer event occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DTEF</name>
              <description>data transfer error flag</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no data transfer error event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>a master bus error event occurred on a data transfer</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ULEF</name>
              <description>update link transfer error flag</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no update link transfer error event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>a master bus error event occurred while updating a linked-list register from memory</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>USEF</name>
              <description>user setting error flag</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no user setting error event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>a user setting error event occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SUSPF</name>
              <description>completed suspension flag</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no completed suspension event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>a completed suspension event occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TOF</name>
              <description>trigger overrun flag</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no trigger overrun event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>a trigger overrun event occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FIFOL</name>
              <description>monitored FIFO level
Number of available write beats in the FIFO, in units of the programmed destination data width (see GPDMA_CxTR1.DDW_LOG2[1:0], in units of bytes, half-words, or words).
Note: After having suspended an active transfer, the user may need to read FIFOL[7:0], additionally to GPDMA_CxBR1.BDNT[15:0] to know how many data have been transferred to the destination. Before reading, the user may wait for the transfer to be suspended (GPDMA_CxSR.SUSPF = 1).</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C1CR</name>
          <displayName>GPDMA_C1CR</displayName>
          <description>GPDMA channel 1 control register</description>
          <addressOffset>0xE4</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>enable
Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 0. Else: 
this bit is deasserted by hardware when there is a transfer error (master bus error or user setting error) or when there is a channel transfer complete (channel ready to be configured, for example if LSM=1 at the end of a single execution of the LLI).
Else, this bit can be asserted by software. 
Writing 0 into this EN bit is ignored.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>write: ignored, read: channel disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>write: enable channel, read: channel enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESET</name>
              <description>reset
This bit is write only. Writing 0 has no impact. Writing 1 implies the reset of the following: the FIFO, the channel internal state, SUSP and EN bits (whatever is written receptively in bit 2 and bit 0).
The reset is effective when the channel is in steady state, meaning one of the following:
- active channel in suspended state (GPDMA_CxSR.SUSPF = 1 and GPDMA_CxSR.IDLEF = GPDMA_CxCR.EN = 1)
- channel in disabled state (GPDMA_CxSR.IDLEF = 1 and GPDMA_CxCR.EN = 0).
After writing a RESET, to continue using this channel, the user must explicitly reconfigure the channel including the hardware-modified configuration registers (GPDMA_CxBR1, GPDMA_CxSAR and GPDMA_CxDAR) before enabling again the channel (see the programming sequence in Figure 44).</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no channel reset</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>channel reset</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SUSP</name>
              <description>suspend
Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 2. Else:
Software must write 1 in order to suspend an active channel (channel with an ongoing GPDMA transfer over its master ports). 
The software must write 0 in order to resume a suspended channel, following the programming sequence detailed in Figure 43.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>write: resume channel, read: channel not suspended</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>write: suspend channel, read: channel suspended.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TCIE</name>
              <description>transfer complete interrupt enable</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HTIE</name>
              <description>half transfer complete interrupt enable</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DTEIE</name>
              <description>data transfer error interrupt enable</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ULEIE</name>
              <description>update link transfer error interrupt enable</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>USEIE</name>
              <description>user setting error interrupt enable</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SUSPIE</name>
              <description>completed suspension interrupt enable</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TOIE</name>
              <description>trigger overrun interrupt enable</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LSM</name>
              <description>Link step mode
First the (possible 1D/repeated) block transfer is executed as defined by the current internal register file until GPDMA_CxBR1.BNDT[15:0] = 0. Secondly the next linked-list data structure is conditionally uploaded from memory as defined by GPDMA_CxLLR. Then channel execution is completed.
Note: This bit must be written when EN=0. This bit is read-only when EN=1.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>channel executed for the full linked-list and completed at the end of the last LLI (GPDMA_CxLLR = 0). The 16 low-significant bits of the link address are null (LA[15:0] = 0) and all the update bits are null (UT1 =UB1 = UT2 = USA = UDA = ULL = 0). Then GPDMA_CxBR1.BNDT[15:0] = 0.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>channel executed once for the current LLI</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LAP</name>
              <description>linked-list allocated port
This bit is used to allocate the master port for the update of the GPDMA linked-list registers from the memory.
Note: This bit must be written when EN=0. This bit is read-only when EN=1.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>port 0 (AHB) allocated</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>port 1 (AHB) allocated</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>priority level of the channel x GPDMA transfer versus others
Note: This bit must be written when EN = 0. This bit is read-only when EN = 1.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>low priority, low weight</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>low priority, mid weight</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>low priority, high weight</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>high priority</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C1TR1</name>
          <displayName>GPDMA_C1TR1</displayName>
          <description>GPDMA channel 1 transfer register 1</description>
          <addressOffset>0x110</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SDW_LOG2</name>
              <description>binary logarithm of the source data width of a burst in bytes
Setting a 8-byte data width causes a user setting error to be reported and no transfer is issued.
A source block size must be a multiple of the source data width (GPDMA_CxBR1.BNDT[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and no transfer is issued.
Note: A source burst transfer must have an aligned address with its data width (start address GPDMA_CxSAR[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and none transfer is issued.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>byte</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>half-word (2 bytes)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>word (4 bytes)</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>user setting error reported and no transfer issued</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SINC</name>
              <description>source incrementing burst
The source address, pointed by GPDMA_CxSAR, is kept constant after a burst beat/single transfer or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>fixed burst</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>contiguously incremented burst</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SBL_1</name>
              <description>source burst length minus 1, between 0 and 63
The burst length unit is one data named beat within a burst. If SBL_1[5:0] =0 , the burst can be named as single. Each data/beat has a width defined by the destination data width SDW_LOG2[1:0].
Note: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol.
Note: If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower singles/bursts, but the data integrity is guaranteed.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PAM</name>
              <description>padding/alignment mode
If DDW_LOG2[1:0] = SDW_LOG2[1:0]: if the data width of a burst destination transfer is equal to the data width of a burst source transfer, these bits are ignored.
Else, in the following enumerated values, the condition PAM_1 is when destination data width is higher that source data width, and the condition PAM_2 is when destination data width is higher than source data width.
1x: successive source data are FIFO queued and packed at the destination data width, in a left (LSB) to right (MSB) order (named little endian), before a destination transfer
Note: 1x: source data is FIFO queued and unpacked at the destination data width, to be transferred in a left (LSB) to right (MSB) order (named little endian) to the destination</description>
              <bitOffset>11</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0_PAM_1</name>
                  <description>source data is transferred as right aligned, padded with 0s up to the destination data width</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1_PAM_1</name>
                  <description>source data is transferred as right aligned, sign extended up to the destination data width</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SBX</name>
              <description>source byte exchange within the unaligned half-word of each source word 
If the source data width is shorter than a word, this bit is ignored.
If the source data width is a word:</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no byte-based exchange within the unaligned half-word of each source word</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>the two consecutive bytes within the unaligned half-word of each source word are exchanged.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SAP</name>
              <description>source allocated port
This bit is used to allocate the master port for the source transfer
Note: This bit must be written when EN = 0. This bit is read-only when EN = 1.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>port 0 (AHB) allocated</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>port 1 (AHB) allocated</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SSEC</name>
              <description>security attribute of the GPDMA transfer from the source
If GPDMA_SECCFGR.SECx = 1 and the access is secure:
This is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx =1 . A secure write is ignored when GPDMA_SECCFGR.SECx = 0.
When GPDMA_SECCFGR.SECx is deasserted, this SSEC bit is also deasserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer from the source is non-secure.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>GPDMA transfer non-secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GPDMA transfer secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DDW_LOG2</name>
              <description>binary logarithm of the destination data width of a burst, in bytes
Setting a 8-byte data width causes a user setting error to be reported and none transfer is issued.
Note: A destination burst transfer must have an aligned address with its data width (start address GPDMA_CxDAR[2:0] versus DDW_LOG2[1:0]). Otherwise a user setting error is reported and no transfer is issued.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>byte</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>half-word (2 bytes)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>word (4 bytes)</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>user setting error reported and no transfer issued</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DINC</name>
              <description>destination incrementing burst
The destination address, pointed by GPDMA_CxDAR, is kept constant after a burst beat/single transfer, or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>fixed burst</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>contiguously incremented burst</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DBL_1</name>
              <description>destination burst length minus 1, between 0 and 63
The burst length unit is one data named beat within a burst. If DBL_1[5:0] =0 , the burst can be named as single. Each data/beat has a width defined by the destination data width DDW_LOG2[1:0].
Note: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol.
Note: If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower singles/bursts, but the data integrity is guaranteed.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DBX</name>
              <description>destination byte exchange
If the destination data size is a byte, this bit is ignored.
If the destination data size is not a byte:</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no byte-based exchange within half-word</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>the two consecutive (post PAM) bytes are exchanged in each destination half-word.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DHX</name>
              <description>destination half-word exchange
If the destination data size is shorter than a word, this bit is ignored.
If the destination data size is a word:</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no halfword-based exchanged within word</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>the two consecutive (post PAM) half-words are exchanged in each destination word.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DAP</name>
              <description>destination allocated port
This bit is used to allocate the master port for the destination transfer
Note: This bit must be written when EN = 0. This bit is read-only when EN = 1.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>port 0 (AHB) allocated</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>port 1 (AHB) allocated</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DSEC</name>
              <description>security attribute of the GPDMA transfer to the destination
If GPDMA_SECCFGR.SECx = 1 and the access is secure:
This is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx = 1. A secure write is ignored when GPDMA_SECCFGR.SECx = 0.
When GPDMA_SECCFGR.SECx is deasserted, this DSEC bit is also deasserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer to the destination is non-secure.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>GPDMA transfer non-secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GPDMA transfer secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C1TR2</name>
          <displayName>GPDMA_C1TR2</displayName>
          <description>GPDMA channel 1 transfer register 2</description>
          <addressOffset>0x114</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REQSEL</name>
              <description>GPDMA hardware request selection
These bits are ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer). Else, the selected hardware request is internally taken into account as per Section 16.3.3.
The user must not assign a same input hardware request (same REQSEL[5:0] value) to different active GPDMA channels (GPDMA_CxCR.EN = 1 and GPDMA_CxTR2.SWREQ = 0 for these channels). GPDMA is not intended to hardware support the case of simultaneous enabled channels incorrectly configured with a same hardware peripheral request signal, and there is no user setting error reporting.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SWREQ</name>
              <description>software request
This bit is internally taken into account when GPDMA_CxCR.EN is asserted.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no software request. The selected hardware request REQSEL[5:0] is taken into account.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>software request for a memory-to-memory transfer. The default selected hardware request as per REQSEL[5:0] is ignored.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DREQ</name>
              <description>destination hardware request
This bit is ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer). Else:</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>selected hardware request driven by a source peripheral (request signal taken into account by the GPDMA transfer scheduler over the source/read port)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>selected hardware request driven by a destination peripheral (request signal taken into account by the GPDMA transfer scheduler over the destination/write port)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BREQ</name>
              <description>Block hardware request
If the channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer), this bit is ignored. Else:</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>the selected hardware request is driven by a peripheral with a hardware request/acknowledge protocol at a burst level.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>the selected hardware request is driven by a peripheral with a hardware request/acknowledge protocol at a block level (see Section 16.3.3).</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TRIGM</name>
              <description>trigger mode
These bits define the transfer granularity for its conditioning by the trigger.
If the channel x is enabled (GPDMA_CxCR.EN asserted) with TRIGPOL[1:0] = 00 or 11, these TRIGM[1:0] bits are ignored.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>at block level: the first burst read of each block transfer is conditioned by one hit trigger .</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>channel x = 0 to 7, same as 0010: at link level: a LLI link transfer is conditioned by one hit trigger. The LLI data transfer (if any) is not conditioned.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>at programmed burst level: If SWREQ = 1, each programmed burst read is conditioned by one hit trigger. If SWREQ = 0, each programmed burst that is requested by the selected peripheral, is conditioned by one hit trigger.</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TRIGSEL</name>
              <description>trigger event input selection
These bits select the trigger event input of the GPDMA transfer (as per Section 16.3.5), with an active trigger event if TRIGPOL[1:0] different 00.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIGPOL</name>
              <description>trigger event polarity
These bits define the polarity of the selected trigger event input defined by TRIGSEL[4:0].</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no trigger (masked trigger event)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>trigger on the rising edge</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>trigger on the falling edge</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>same as 00</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TCEM</name>
              <description>transfer complete event mode
These bits define the transfer granularity for the transfer complete and half transfer complete events generation.
Note: If the initial LLIsub0 /subdata transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] = 0), then neither the complete transfer event nor the half transfer event is generated.
Note: If the initial LLIsub0 /subdata transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] = 0), then neither the complete transfer event nor the half transfer event is generated.
Note: If the initial LLIsub0 /subdata transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] =0 ), then the half transfer event is not generated, and the transfer complete event is generated when is completed the loading of the LLIsub1/sub.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>at block level (when GPDMA_CxBR1.BNDT[15:0] = 0): the complete (and the half) transfer event is generated at the (respectively half of the) end of a block.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>channel x (0 to 7, same as 00</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>at LLI level: the complete transfer event is generated at the end of the LLI transfer, including the update of the LLI if any. The half transfer event is generated at the half of the LLI data transfer.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>at channel level: the complete transfer event is generated at the end of the last LLI transfer. The half transfer event is generated at the half of the data transfer of the last LLI. The last LLI updates the link address GPDMA_CxLLR.LA[15:2] to zero and clears all the GPDMA_CxLLR update bits (UT1, UT2, UB1, USA, UDA and ULL). If the channel transfer is continuous/infinite, no event is generated.</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C1BR1</name>
          <displayName>GPDMA_C1BR1</displayName>
          <description>GPDMA channel 1 block register 1</description>
          <addressOffset>0x118</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BNDT</name>
              <description>block number of data bytes to transfer from the source
Block size transferred from the source. When the channel is enabled, this field becomes read-only and is decremented, indicating the remaining number of data items in the current source block to be transferred. BNDT[15:0] is programmed in number of bytes, maximum source block size is 64 Kbytes -1.
Once the last data transfer is completed (BNDT[15:0] = 0):
- if GPDMA_CxLLR.UB1 = 1, this field is updated by the LLI in the memory.
- if GPDMA_CxLLR.UB1 = 0 and if there is at least one non null Uxx update bit, this field is internally restored to the programmed value.
- if all GPDMA_CxLLR.Uxx = 0 and if GPDMA_CxLLR.LA[15:0] = 0, this field is internally restored to the programmed value (infinite/continuous last LLI).
- if GPDMA_CxLLR = 0, this field is kept as zero following the last LLI data transfer.
Note: A non-null source block size must be a multiple of the source data width (BNDT[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.
Note: When configured in packing mode (GPDMA_CxTR1.PAM[1] = 1 and destination data width different from source data width), a non-null source block size must be a multiple of the destination data width (BNDT[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C1SAR</name>
          <displayName>GPDMA_C1SAR</displayName>
          <description>GPDMA channel 1 source address register</description>
          <addressOffset>0x11C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SA</name>
              <description>source address
This field is the pointer to the address from which the next data is read.
During the channel activity, depending on the source addressing mode (GPDMA_CxTR1.SINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.SDW_LOG2[1:0]) after each burst source data, reflecting the next address from which data is read.
During the channel activity, this address is updated after each completed source burst, consequently to:
the programmed source burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.SINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.SBL_1[5:0] and GPDMA_CxTR1.SDW_LOG2[21:0]
the additional source incremented/decremented offset value as programmed by GPDMA_CxBR1.SDEC
In linked-list mode, after a LLI data transfer is completed, this register is automatically updated by GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.USA = 1.
Note: A source address must be aligned with the programmed data width of a source burst (SA[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C1DAR</name>
          <displayName>GPDMA_C1DAR</displayName>
          <description>GPDMA channel 1 destination address register</description>
          <addressOffset>0x120</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DA</name>
              <description>destination address
This field is the pointer to the address from which the next data is written.
During the channel activity, depending on the destination addressing mode (GPDMA_CxTR1.DINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.DDW_LOG2[21:0]) after each burst destination data, reflecting the next address from which data is written.
During the channel activity, this address is updated after each completed destination burst, consequently to:
the programmed destination burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.DINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.DBL_1[5:0] and GPDMA_CxTR1.DDW_LOG2[1:0]
the additional destination incremented/decremented offset value as programmed by GPDMA_CxBR1.DDEC.
In linked-list mode, after a LLI data transfer is completed, this register is automatically updated by the GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.UDA = 1.
Note: A destination address must be aligned with the programmed data width of a destination burst (DA[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C1LLR</name>
          <displayName>GPDMA_C1LLR</displayName>
          <description>GPDMA channel 1 linked-list address register</description>
          <addressOffset>0x14C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LA</name>
              <description>pointer (16-bit low-significant address) to the next linked-list data structure
If UT1 = UT2 = UB1 = USA = UDA = ULL = 0 and if LA[15:20] = 0, the current LLI is the last one. The channel transfer is completed without any update of the linked-list GPDMA register file.
Else, this field is the pointer to the memory address offset from which the next linked-list data structure is automatically fetched from, once the data transfer is completed, in order to conditionally update the linked-list GPDMA internal register file (GPDMA_CxCTR1, GPDMA_CxTR2, GPDMA_CxBR1, GPDMA_CxSAR, GPDMA_CxDAR and GPDMA_CxLLR).
Note: The user must program the pointer to be 32-bit aligned. The two low-significant bits are write ignored.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>14</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ULL</name>
              <description>Update GPDMA_CxLLR register from memory
This bit is used to control the update of GPDMA_CxLLR from the memory during the link transfer.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no GPDMA_CxLLR update</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GPDMA_CxLLR update</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UDA</name>
              <description>Update GPDMA_CxDAR register from memory
This bit is used to control the update of GPDMA_CxDAR from the memory during the link transfer.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no GPDMA_CxDAR update</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GPDMA_CxDAR update</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>USA</name>
              <description>update GPDMA_CxSAR from memory
This bit controls the update of GPDMA_CxSAR from the memory during the link transfer.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no GPDMA_CxSAR update</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GPDMA_CxSAR update</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UB1</name>
              <description>Update GPDMA_CxBR1 from memory
This bit controls the update of GPDMA_CxBR1 from the memory during the link transfer. If UB1 = 0 and if GPDMA_CxLLR different 0, the linked-list is not completed. GPDMA_CxBR1.BNDT[15:0] is then restored to the programmed value after data transfer is completed and before the link transfer.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no GPDMA_CxBR1 update from memory (GPDMA_CxBR1.BNDT[15:0] restored if any link transfer)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GPDMA_CxBR1 update</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UT2</name>
              <description>Update GPDMA_CxTR2 from memory
This bit controls the update of GPDMA_CxTR2 from the memory during the link transfer.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no GPDMA_CxTR2 update</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GPDMA_CxTR2 update</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UT1</name>
              <description>Update GPDMA_CxTR1 from memory
This bit controls the update of GPDMA_CxTR1 from the memory during the link transfer.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no GPDMA_CxTR1 update</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GPDMA_CxTR1 update</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C2LBAR</name>
          <displayName>GPDMA_C2LBAR</displayName>
          <description>GPDMA channel 2 linked-list base address register</description>
          <addressOffset>0x150</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LBA</name>
              <description>linked-list base address of GPDMA channel x</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C2FCR</name>
          <displayName>GPDMA_C2FCR</displayName>
          <description>GPDMA channel 2 flag clear register</description>
          <addressOffset>0x15C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TCF</name>
              <description>transfer complete flag clear</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>corresponding TCF flag cleared</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HTF</name>
              <description>half transfer flag clear</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>corresponding HTF flag cleared</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DTEF</name>
              <description>data transfer error flag clear</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>corresponding DTEF flag cleared</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ULEF</name>
              <description>update link transfer error flag clear</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>corresponding ULEF flag cleared</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>USEF</name>
              <description>user setting error flag clear</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>corresponding USEF flag cleared</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SUSPF</name>
              <description>completed suspension flag clear</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>corresponding SUSPF flag cleared</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TOF</name>
              <description>trigger overrun flag clear</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>corresponding TOF flag cleared</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C2SR</name>
          <displayName>GPDMA_C2SR</displayName>
          <description>GPDMA channel 2 status register</description>
          <addressOffset>0x160</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IDLEF</name>
              <description>idle flag
This idle flag is deasserted by hardware when the channel is enabled (GPDMA_CxCR.EN = 1) with a valid channel configuration (no USEF to be immediately reported).
This idle flag is asserted after hard reset or by hardware when the channel is back in idle state (in suspended or disabled state).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>channel not in idle state</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>channel in idle state</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TCF</name>
              <description>transfer complete flag
A transfer complete event is either a block transfer complete, or a LLI transfer complete including the upload of the next LLI if any, or the full linked-list completion, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0]).</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no transfer complete event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>a transfer complete event occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HTF</name>
              <description>half transfer flag
A half block transfer occurs when half of the bytes of the source block size (rounded up integer of GPDMA_CxBR1.BNDT[15:0]/2) has been transferred to the destination.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no half transfer event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>a half transfer event occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DTEF</name>
              <description>data transfer error flag</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no data transfer error event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>a master bus error event occurred on a data transfer</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ULEF</name>
              <description>update link transfer error flag</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no update link transfer error event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>a master bus error event occurred while updating a linked-list register from memory</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>USEF</name>
              <description>user setting error flag</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no user setting error event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>a user setting error event occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SUSPF</name>
              <description>completed suspension flag</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no completed suspension event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>a completed suspension event occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TOF</name>
              <description>trigger overrun flag</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no trigger overrun event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>a trigger overrun event occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FIFOL</name>
              <description>monitored FIFO level
Number of available write beats in the FIFO, in units of the programmed destination data width (see GPDMA_CxTR1.DDW_LOG2[1:0], in units of bytes, half-words, or words).
Note: After having suspended an active transfer, the user may need to read FIFOL[7:0], additionally to GPDMA_CxBR1.BDNT[15:0] to know how many data have been transferred to the destination. Before reading, the user may wait for the transfer to be suspended (GPDMA_CxSR.SUSPF = 1).</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C2CR</name>
          <displayName>GPDMA_C2CR</displayName>
          <description>GPDMA channel 2 control register</description>
          <addressOffset>0x164</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>enable
Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 0. Else: 
this bit is deasserted by hardware when there is a transfer error (master bus error or user setting error) or when there is a channel transfer complete (channel ready to be configured, for example if LSM=1 at the end of a single execution of the LLI).
Else, this bit can be asserted by software. 
Writing 0 into this EN bit is ignored.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>write: ignored, read: channel disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>write: enable channel, read: channel enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESET</name>
              <description>reset
This bit is write only. Writing 0 has no impact. Writing 1 implies the reset of the following: the FIFO, the channel internal state, SUSP and EN bits (whatever is written receptively in bit 2 and bit 0).
The reset is effective when the channel is in steady state, meaning one of the following:
- active channel in suspended state (GPDMA_CxSR.SUSPF = 1 and GPDMA_CxSR.IDLEF = GPDMA_CxCR.EN = 1)
- channel in disabled state (GPDMA_CxSR.IDLEF = 1 and GPDMA_CxCR.EN = 0).
After writing a RESET, to continue using this channel, the user must explicitly reconfigure the channel including the hardware-modified configuration registers (GPDMA_CxBR1, GPDMA_CxSAR and GPDMA_CxDAR) before enabling again the channel (see the programming sequence in Figure 44).</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no channel reset</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>channel reset</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SUSP</name>
              <description>suspend
Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 2. Else:
Software must write 1 in order to suspend an active channel (channel with an ongoing GPDMA transfer over its master ports). 
The software must write 0 in order to resume a suspended channel, following the programming sequence detailed in Figure 43.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>write: resume channel, read: channel not suspended</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>write: suspend channel, read: channel suspended.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TCIE</name>
              <description>transfer complete interrupt enable</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HTIE</name>
              <description>half transfer complete interrupt enable</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DTEIE</name>
              <description>data transfer error interrupt enable</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ULEIE</name>
              <description>update link transfer error interrupt enable</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>USEIE</name>
              <description>user setting error interrupt enable</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SUSPIE</name>
              <description>completed suspension interrupt enable</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TOIE</name>
              <description>trigger overrun interrupt enable</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LSM</name>
              <description>Link step mode
First the (possible 1D/repeated) block transfer is executed as defined by the current internal register file until GPDMA_CxBR1.BNDT[15:0] = 0. Secondly the next linked-list data structure is conditionally uploaded from memory as defined by GPDMA_CxLLR. Then channel execution is completed.
Note: This bit must be written when EN=0. This bit is read-only when EN=1.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>channel executed for the full linked-list and completed at the end of the last LLI (GPDMA_CxLLR = 0). The 16 low-significant bits of the link address are null (LA[15:0] = 0) and all the update bits are null (UT1 =UB1 = UT2 = USA = UDA = ULL = 0). Then GPDMA_CxBR1.BNDT[15:0] = 0.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>channel executed once for the current LLI</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LAP</name>
              <description>linked-list allocated port
This bit is used to allocate the master port for the update of the GPDMA linked-list registers from the memory.
Note: This bit must be written when EN=0. This bit is read-only when EN=1.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>port 0 (AHB) allocated</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>port 1 (AHB) allocated</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>priority level of the channel x GPDMA transfer versus others
Note: This bit must be written when EN = 0. This bit is read-only when EN = 1.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>low priority, low weight</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>low priority, mid weight</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>low priority, high weight</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>high priority</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C2TR1</name>
          <displayName>GPDMA_C2TR1</displayName>
          <description>GPDMA channel 2 transfer register 1</description>
          <addressOffset>0x190</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SDW_LOG2</name>
              <description>binary logarithm of the source data width of a burst in bytes
Setting a 8-byte data width causes a user setting error to be reported and no transfer is issued.
A source block size must be a multiple of the source data width (GPDMA_CxBR1.BNDT[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and no transfer is issued.
Note: A source burst transfer must have an aligned address with its data width (start address GPDMA_CxSAR[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and none transfer is issued.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>byte</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>half-word (2 bytes)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>word (4 bytes)</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>user setting error reported and no transfer issued</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SINC</name>
              <description>source incrementing burst
The source address, pointed by GPDMA_CxSAR, is kept constant after a burst beat/single transfer or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>fixed burst</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>contiguously incremented burst</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SBL_1</name>
              <description>source burst length minus 1, between 0 and 63
The burst length unit is one data named beat within a burst. If SBL_1[5:0] =0 , the burst can be named as single. Each data/beat has a width defined by the destination data width SDW_LOG2[1:0].
Note: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol.
Note: If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower singles/bursts, but the data integrity is guaranteed.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PAM</name>
              <description>padding/alignment mode
If DDW_LOG2[1:0] = SDW_LOG2[1:0]: if the data width of a burst destination transfer is equal to the data width of a burst source transfer, these bits are ignored.
Else, in the following enumerated values, the condition PAM_1 is when destination data width is higher that source data width, and the condition PAM_2 is when destination data width is higher than source data width.
1x: successive source data are FIFO queued and packed at the destination data width, in a left (LSB) to right (MSB) order (named little endian), before a destination transfer
Note: 1x: source data is FIFO queued and unpacked at the destination data width, to be transferred in a left (LSB) to right (MSB) order (named little endian) to the destination</description>
              <bitOffset>11</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0_PAM_1</name>
                  <description>source data is transferred as right aligned, padded with 0s up to the destination data width</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1_PAM_1</name>
                  <description>source data is transferred as right aligned, sign extended up to the destination data width</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SBX</name>
              <description>source byte exchange within the unaligned half-word of each source word 
If the source data width is shorter than a word, this bit is ignored.
If the source data width is a word:</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no byte-based exchange within the unaligned half-word of each source word</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>the two consecutive bytes within the unaligned half-word of each source word are exchanged.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SAP</name>
              <description>source allocated port
This bit is used to allocate the master port for the source transfer
Note: This bit must be written when EN = 0. This bit is read-only when EN = 1.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>port 0 (AHB) allocated</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>port 1 (AHB) allocated</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SSEC</name>
              <description>security attribute of the GPDMA transfer from the source
If GPDMA_SECCFGR.SECx = 1 and the access is secure:
This is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx =1 . A secure write is ignored when GPDMA_SECCFGR.SECx = 0.
When GPDMA_SECCFGR.SECx is deasserted, this SSEC bit is also deasserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer from the source is non-secure.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>GPDMA transfer non-secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GPDMA transfer secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DDW_LOG2</name>
              <description>binary logarithm of the destination data width of a burst, in bytes
Setting a 8-byte data width causes a user setting error to be reported and none transfer is issued.
Note: A destination burst transfer must have an aligned address with its data width (start address GPDMA_CxDAR[2:0] versus DDW_LOG2[1:0]). Otherwise a user setting error is reported and no transfer is issued.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>byte</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>half-word (2 bytes)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>word (4 bytes)</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>user setting error reported and no transfer issued</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DINC</name>
              <description>destination incrementing burst
The destination address, pointed by GPDMA_CxDAR, is kept constant after a burst beat/single transfer, or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>fixed burst</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>contiguously incremented burst</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DBL_1</name>
              <description>destination burst length minus 1, between 0 and 63
The burst length unit is one data named beat within a burst. If DBL_1[5:0] =0 , the burst can be named as single. Each data/beat has a width defined by the destination data width DDW_LOG2[1:0].
Note: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol.
Note: If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower singles/bursts, but the data integrity is guaranteed.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DBX</name>
              <description>destination byte exchange
If the destination data size is a byte, this bit is ignored.
If the destination data size is not a byte:</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no byte-based exchange within half-word</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>the two consecutive (post PAM) bytes are exchanged in each destination half-word.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DHX</name>
              <description>destination half-word exchange
If the destination data size is shorter than a word, this bit is ignored.
If the destination data size is a word:</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no halfword-based exchanged within word</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>the two consecutive (post PAM) half-words are exchanged in each destination word.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DAP</name>
              <description>destination allocated port
This bit is used to allocate the master port for the destination transfer
Note: This bit must be written when EN = 0. This bit is read-only when EN = 1.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>port 0 (AHB) allocated</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>port 1 (AHB) allocated</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DSEC</name>
              <description>security attribute of the GPDMA transfer to the destination
If GPDMA_SECCFGR.SECx = 1 and the access is secure:
This is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx = 1. A secure write is ignored when GPDMA_SECCFGR.SECx = 0.
When GPDMA_SECCFGR.SECx is deasserted, this DSEC bit is also deasserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer to the destination is non-secure.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>GPDMA transfer non-secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GPDMA transfer secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C2TR2</name>
          <displayName>GPDMA_C2TR2</displayName>
          <description>GPDMA channel 2 transfer register 2</description>
          <addressOffset>0x194</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REQSEL</name>
              <description>GPDMA hardware request selection
These bits are ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer). Else, the selected hardware request is internally taken into account as per Section 16.3.3.
The user must not assign a same input hardware request (same REQSEL[5:0] value) to different active GPDMA channels (GPDMA_CxCR.EN = 1 and GPDMA_CxTR2.SWREQ = 0 for these channels). GPDMA is not intended to hardware support the case of simultaneous enabled channels incorrectly configured with a same hardware peripheral request signal, and there is no user setting error reporting.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SWREQ</name>
              <description>software request
This bit is internally taken into account when GPDMA_CxCR.EN is asserted.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no software request. The selected hardware request REQSEL[5:0] is taken into account.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>software request for a memory-to-memory transfer. The default selected hardware request as per REQSEL[5:0] is ignored.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DREQ</name>
              <description>destination hardware request
This bit is ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer). Else:</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>selected hardware request driven by a source peripheral (request signal taken into account by the GPDMA transfer scheduler over the source/read port)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>selected hardware request driven by a destination peripheral (request signal taken into account by the GPDMA transfer scheduler over the destination/write port)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BREQ</name>
              <description>Block hardware request
If the channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer), this bit is ignored. Else:</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>the selected hardware request is driven by a peripheral with a hardware request/acknowledge protocol at a burst level.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>the selected hardware request is driven by a peripheral with a hardware request/acknowledge protocol at a block level (see Section 16.3.3).</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TRIGM</name>
              <description>trigger mode
These bits define the transfer granularity for its conditioning by the trigger.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>at block level: the first burst read of each block transfer is conditioned by one hit trigger .</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>channel x = 0 to 7, same as 0010: at link level: a LLI link transfer is conditioned by one hit trigger. The LLI data transfer (if any) is not conditioned.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>at programmed burst level: If SWREQ = 1, each programmed burst read is conditioned by one hit trigger. If SWREQ = 0, each programmed burst that is requested by the selected peripheral, is conditioned by one hit trigger.</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TRIGSEL</name>
              <description>trigger event input selection
These bits select the trigger event input of the GPDMA transfer (as per Section 16.3.5), with an active trigger event if TRIGPOL[1:0] different 00.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIGPOL</name>
              <description>trigger event polarity
These bits define the polarity of the selected trigger event input defined by TRIGSEL[4:0].</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no trigger (masked trigger event)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>trigger on the rising edge</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>trigger on the falling edge</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>same as 00</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TCEM</name>
              <description>transfer complete event mode
These bits define the transfer granularity for the transfer complete and half transfer complete events generation.
Note: If the initial LLIsub0 /subdata transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] = 0), then neither the complete transfer event nor the half transfer event is generated.
Note: If the initial LLIsub0 /subdata transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] = 0), then neither the complete transfer event nor the half transfer event is generated.
Note: If the initial LLIsub0 /subdata transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] =0 ), then the half transfer event is not generated, and the transfer complete event is generated when is completed the loading of the LLIsub1/sub.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>at block level (when GPDMA_CxBR1.BNDT[15:0] = 0): the complete (and the half) transfer event is generated at the (respectively half of the) end of a block.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>channel x (0 to 7, same as 00</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>at LLI level: the complete transfer event is generated at the end of the LLI transfer, including the update of the LLI if any. The half transfer event is generated at the half of the LLI data transfer.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>at channel level: the complete transfer event is generated at the end of the last LLI transfer. The half transfer event is generated at the half of the data transfer of the last LLI. The last LLI updates the link address GPDMA_CxLLR.LA[15:2] to zero and clears all the GPDMA_CxLLR update bits (UT1, UT2, UB1, USA, UDA and ULL). If the channel transfer is continuous/infinite, no event is generated.</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C2BR1</name>
          <displayName>GPDMA_C2BR1</displayName>
          <description>GPDMA channel 2 block register 1</description>
          <addressOffset>0x198</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BNDT</name>
              <description>block number of data bytes to transfer from the source
Block size transferred from the source. When the channel is enabled, this field becomes read-only and is decremented, indicating the remaining number of data items in the current source block to be transferred. BNDT[15:0] is programmed in number of bytes, maximum source block size is 64 Kbytes -1.
Once the last data transfer is completed (BNDT[15:0] = 0):
- if GPDMA_CxLLR.UB1 = 1, this field is updated by the LLI in the memory.
- if GPDMA_CxLLR.UB1 = 0 and if there is at least one non null Uxx update bit, this field is internally restored to the programmed value.
- if all GPDMA_CxLLR.Uxx = 0 and if GPDMA_CxLLR.LA[15:0] = 0, this field is internally restored to the programmed value (infinite/continuous last LLI).
- if GPDMA_CxLLR = 0, this field is kept as zero following the last LLI data transfer.
Note: A non-null source block size must be a multiple of the source data width (BNDT[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.
Note: When configured in packing mode (GPDMA_CxTR1.PAM[1] = 1 and destination data width different from source data width), a non-null source block size must be a multiple of the destination data width (BNDT[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C2SAR</name>
          <displayName>GPDMA_C2SAR</displayName>
          <description>GPDMA channel 2 source address register</description>
          <addressOffset>0x19C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SA</name>
              <description>source address
This field is the pointer to the address from which the next data is read.
During the channel activity, depending on the source addressing mode (GPDMA_CxTR1.SINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.SDW_LOG2[1:0]) after each burst source data, reflecting the next address from which data is read.
During the channel activity, this address is updated after each completed source burst, consequently to:
the programmed source burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.SINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.SBL_1[5:0] and GPDMA_CxTR1.SDW_LOG2[21:0]
the additional source incremented/decremented offset value as programmed by GPDMA_CxBR1.SDEC
In linked-list mode, after a LLI data transfer is completed, this register is automatically updated by GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.USA = 1.
Note: A source address must be aligned with the programmed data width of a source burst (SA[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C2DAR</name>
          <displayName>GPDMA_C2DAR</displayName>
          <description>GPDMA channel 2 destination address register</description>
          <addressOffset>0x1A0</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DA</name>
              <description>destination address
This field is the pointer to the address from which the next data is written.
During the channel activity, depending on the destination addressing mode (GPDMA_CxTR1.DINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.DDW_LOG2[21:0]) after each burst destination data, reflecting the next address from which data is written.
During the channel activity, this address is updated after each completed destination burst, consequently to:
the programmed destination burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.DINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.DBL_1[5:0] and GPDMA_CxTR1.DDW_LOG2[1:0]
the additional destination incremented/decremented offset value as programmed by GPDMA_CxBR1.DDEC.
In linked-list mode, after a LLI data transfer is completed, this register is automatically updated by the GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.UDA = 1.
Note: A destination address must be aligned with the programmed data width of a destination burst (DA[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C2LLR</name>
          <displayName>GPDMA_C2LLR</displayName>
          <description>GPDMA channel 2 linked-list address register</description>
          <addressOffset>0x1CC</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LA</name>
              <description>pointer (16-bit low-significant address) to the next linked-list data structure
If UT1 = UT2 = UB1 = USA = UDA = ULL = 0 and if LA[15:20] = 0, the current LLI is the last one. The channel transfer is completed without any update of the linked-list GPDMA register file.
Else, this field is the pointer to the memory address offset from which the next linked-list data structure is automatically fetched from, once the data transfer is completed, in order to conditionally update the linked-list GPDMA internal register file (GPDMA_CxCTR1, GPDMA_CxTR2, GPDMA_CxBR1, GPDMA_CxSAR, GPDMA_CxDAR and GPDMA_CxLLR).
Note: The user must program the pointer to be 32-bit aligned. The two low-significant bits are write ignored.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>14</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ULL</name>
              <description>Update GPDMA_CxLLR register from memory
This bit is used to control the update of GPDMA_CxLLR from the memory during the link transfer.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no GPDMA_CxLLR update</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GPDMA_CxLLR update</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UDA</name>
              <description>Update GPDMA_CxDAR register from memory
This bit is used to control the update of GPDMA_CxDAR from the memory during the link transfer.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no GPDMA_CxDAR update</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GPDMA_CxDAR update</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>USA</name>
              <description>update GPDMA_CxSAR from memory
This bit controls the update of GPDMA_CxSAR from the memory during the link transfer.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no GPDMA_CxSAR update</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GPDMA_CxSAR update</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UB1</name>
              <description>Update GPDMA_CxBR1 from memory
This bit controls the update of GPDMA_CxBR1 from the memory during the link transfer. If UB1 = 0 and if GPDMA_CxLLR different 0, the linked-list is not completed. GPDMA_CxBR1.BNDT[15:0] is then restored to the programmed value after data transfer is completed and before the link transfer.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no GPDMA_CxBR1 update from memory (GPDMA_CxBR1.BNDT[15:0] restored if any link transfer)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GPDMA_CxBR1 update</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UT2</name>
              <description>Update GPDMA_CxTR2 from memory
This bit controls the update of GPDMA_CxTR2 from the memory during the link transfer.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no GPDMA_CxTR2 update</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GPDMA_CxTR2 update</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UT1</name>
              <description>Update GPDMA_CxTR1 from memory
This bit controls the update of GPDMA_CxTR1 from the memory during the link transfer.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no GPDMA_CxTR1 update</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GPDMA_CxTR1 update</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C3LBAR</name>
          <displayName>GPDMA_C3LBAR</displayName>
          <description>GPDMA channel 3 linked-list base address register</description>
          <addressOffset>0x1D0</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LBA</name>
              <description>linked-list base address of GPDMA channel x</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C3FCR</name>
          <displayName>GPDMA_C3FCR</displayName>
          <description>GPDMA channel 3 flag clear register</description>
          <addressOffset>0x1DC</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TCF</name>
              <description>transfer complete flag clear</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>corresponding TCF flag cleared</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HTF</name>
              <description>half transfer flag clear</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>corresponding HTF flag cleared</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DTEF</name>
              <description>data transfer error flag clear</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>corresponding DTEF flag cleared</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ULEF</name>
              <description>update link transfer error flag clear</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>corresponding ULEF flag cleared</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>USEF</name>
              <description>user setting error flag clear</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>corresponding USEF flag cleared</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SUSPF</name>
              <description>completed suspension flag clear</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>corresponding SUSPF flag cleared</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TOF</name>
              <description>trigger overrun flag clear</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>corresponding TOF flag cleared</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C3SR</name>
          <displayName>GPDMA_C3SR</displayName>
          <description>GPDMA channel 3 status register</description>
          <addressOffset>0x1E0</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IDLEF</name>
              <description>idle flag
This idle flag is deasserted by hardware when the channel is enabled (GPDMA_CxCR.EN = 1) with a valid channel configuration (no USEF to be immediately reported).
This idle flag is asserted after hard reset or by hardware when the channel is back in idle state (in suspended or disabled state).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>channel not in idle state</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>channel in idle state</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TCF</name>
              <description>transfer complete flag
A transfer complete event is either a block transfer complete, or a LLI transfer complete including the upload of the next LLI if any, or the full linked-list completion, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0]).</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no transfer complete event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>a transfer complete event occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HTF</name>
              <description>half transfer flag
A half block transfer occurs when half of the bytes of the source block size (rounded up integer of GPDMA_CxBR1.BNDT[15:0]/2) has been transferred to the destination.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no half transfer event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>a half transfer event occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DTEF</name>
              <description>data transfer error flag</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no data transfer error event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>a master bus error event occurred on a data transfer</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ULEF</name>
              <description>update link transfer error flag</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no update link transfer error event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>a master bus error event occurred while updating a linked-list register from memory</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>USEF</name>
              <description>user setting error flag</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no user setting error event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>a user setting error event occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SUSPF</name>
              <description>completed suspension flag</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no completed suspension event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>a completed suspension event occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TOF</name>
              <description>trigger overrun flag</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no trigger overrun event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>a trigger overrun event occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FIFOL</name>
              <description>monitored FIFO level
Number of available write beats in the FIFO, in units of the programmed destination data width (see GPDMA_CxTR1.DDW_LOG2[1:0], in units of bytes, half-words, or words).
Note: After having suspended an active transfer, the user may need to read FIFOL[7:0], additionally to GPDMA_CxBR1.BDNT[15:0] to know how many data have been transferred to the destination. Before reading, the user may wait for the transfer to be suspended (GPDMA_CxSR.SUSPF = 1).</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C3CR</name>
          <displayName>GPDMA_C3CR</displayName>
          <description>GPDMA channel 3 control register</description>
          <addressOffset>0x1E4</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>enable
Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 0. Else: 
this bit is deasserted by hardware when there is a transfer error (master bus error or user setting error) or when there is a channel transfer complete (channel ready to be configured, for example if LSM=1 at the end of a single execution of the LLI).
Else, this bit can be asserted by software. 
Writing 0 into this EN bit is ignored.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>write: ignored, read: channel disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>write: enable channel, read: channel enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESET</name>
              <description>reset
This bit is write only. Writing 0 has no impact. Writing 1 implies the reset of the following: the FIFO, the channel internal state, SUSP and EN bits (whatever is written receptively in bit 2 and bit 0).
The reset is effective when the channel is in steady state, meaning one of the following:
- active channel in suspended state (GPDMA_CxSR.SUSPF = 1 and GPDMA_CxSR.IDLEF = GPDMA_CxCR.EN = 1)
- channel in disabled state (GPDMA_CxSR.IDLEF = 1 and GPDMA_CxCR.EN = 0).
After writing a RESET, to continue using this channel, the user must explicitly reconfigure the channel including the hardware-modified configuration registers (GPDMA_CxBR1, GPDMA_CxSAR and GPDMA_CxDAR) before enabling again the channel (see the programming sequence in Figure 44).</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no channel reset</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>channel reset</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SUSP</name>
              <description>suspend
Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 2. Else:
Software must write 1 in order to suspend an active channel (channel with an ongoing GPDMA transfer over its master ports). 
The software must write 0 in order to resume a suspended channel, following the programming sequence detailed in Figure 43.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>write: resume channel, read: channel not suspended</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>write: suspend channel, read: channel suspended.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TCIE</name>
              <description>transfer complete interrupt enable</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HTIE</name>
              <description>half transfer complete interrupt enable</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DTEIE</name>
              <description>data transfer error interrupt enable</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ULEIE</name>
              <description>update link transfer error interrupt enable</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>USEIE</name>
              <description>user setting error interrupt enable</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SUSPIE</name>
              <description>completed suspension interrupt enable</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TOIE</name>
              <description>trigger overrun interrupt enable</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LSM</name>
              <description>Link step mode
First the (possible 1D/repeated) block transfer is executed as defined by the current internal register file until GPDMA_CxBR1.BNDT[15:0] = 0. Secondly the next linked-list data structure is conditionally uploaded from memory as defined by GPDMA_CxLLR. Then channel execution is completed.
Note: This bit must be written when EN=0. This bit is read-only when EN=1.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>channel executed for the full linked-list and completed at the end of the last LLI (GPDMA_CxLLR = 0). The 16 low-significant bits of the link address are null (LA[15:0] = 0) and all the update bits are null (UT1 =UB1 = UT2 = USA = UDA = ULL = 0). Then GPDMA_CxBR1.BNDT[15:0] = 0.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>channel executed once for the current LLI</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LAP</name>
              <description>linked-list allocated port
This bit is used to allocate the master port for the update of the GPDMA linked-list registers from the memory.
Note: This bit must be written when EN=0. This bit is read-only when EN=1.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>port 0 (AHB) allocated</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>port 1 (AHB) allocated</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>priority level of the channel x GPDMA transfer versus others
Note: This bit must be written when EN = 0. This bit is read-only when EN = 1.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>low priority, low weight</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>low priority, mid weight</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>low priority, high weight</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>high priority</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C3TR1</name>
          <displayName>GPDMA_C3TR1</displayName>
          <description>GPDMA channel 3 transfer register 1</description>
          <addressOffset>0x210</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SDW_LOG2</name>
              <description>binary logarithm of the source data width of a burst in bytes
Setting a 8-byte data width causes a user setting error to be reported and no transfer is issued.
A source block size must be a multiple of the source data width (GPDMA_CxBR1.BNDT[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and no transfer is issued.
Note: A source burst transfer must have an aligned address with its data width (start address GPDMA_CxSAR[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and none transfer is issued.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>byte</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>half-word (2 bytes)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>word (4 bytes)</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>user setting error reported and no transfer issued</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SINC</name>
              <description>source incrementing burst
The source address, pointed by GPDMA_CxSAR, is kept constant after a burst beat/single transfer or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>fixed burst</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>contiguously incremented burst</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SBL_1</name>
              <description>source burst length minus 1, between 0 and 63
The burst length unit is one data named beat within a burst. If SBL_1[5:0] =0 , the burst can be named as single. Each data/beat has a width defined by the destination data width SDW_LOG2[1:0].
Note: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol.
Note: If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower singles/bursts, but the data integrity is guaranteed.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PAM</name>
              <description>padding/alignment mode
If DDW_LOG2[1:0] = SDW_LOG2[1:0]: if the data width of a burst destination transfer is equal to the data width of a burst source transfer, these bits are ignored.
Else, in the following enumerated values, the condition PAM_1 is when destination data width is higher that source data width, and the condition PAM_2 is when destination data width is higher than source data width.
1x: successive source data are FIFO queued and packed at the destination data width, in a left (LSB) to right (MSB) order (named little endian), before a destination transfer
Note: 1x: source data is FIFO queued and unpacked at the destination data width, to be transferred in a left (LSB) to right (MSB) order (named little endian) to the destination</description>
              <bitOffset>11</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0_PAM_1</name>
                  <description>source data is transferred as right aligned, padded with 0s up to the destination data width</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1_PAM_1</name>
                  <description>source data is transferred as right aligned, sign extended up to the destination data width</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SBX</name>
              <description>source byte exchange within the unaligned half-word of each source word 
If the source data width is shorter than a word, this bit is ignored.
If the source data width is a word:</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no byte-based exchange within the unaligned half-word of each source word</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>the two consecutive bytes within the unaligned half-word of each source word are exchanged.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SAP</name>
              <description>source allocated port
This bit is used to allocate the master port for the source transfer
Note: This bit must be written when EN = 0. This bit is read-only when EN = 1.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>port 0 (AHB) allocated</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>port 1 (AHB) allocated</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SSEC</name>
              <description>security attribute of the GPDMA transfer from the source
If GPDMA_SECCFGR.SECx = 1 and the access is secure:
This is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx =1 . A secure write is ignored when GPDMA_SECCFGR.SECx = 0.
When GPDMA_SECCFGR.SECx is deasserted, this SSEC bit is also deasserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer from the source is non-secure.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>GPDMA transfer non-secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GPDMA transfer secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DDW_LOG2</name>
              <description>binary logarithm of the destination data width of a burst, in bytes
Setting a 8-byte data width causes a user setting error to be reported and none transfer is issued.
Note: A destination burst transfer must have an aligned address with its data width (start address GPDMA_CxDAR[2:0] versus DDW_LOG2[1:0]). Otherwise a user setting error is reported and no transfer is issued.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>byte</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>half-word (2 bytes)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>word (4 bytes)</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>user setting error reported and no transfer issued</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DINC</name>
              <description>destination incrementing burst
The destination address, pointed by GPDMA_CxDAR, is kept constant after a burst beat/single transfer, or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>fixed burst</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>contiguously incremented burst</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DBL_1</name>
              <description>destination burst length minus 1, between 0 and 63
The burst length unit is one data named beat within a burst. If DBL_1[5:0] =0 , the burst can be named as single. Each data/beat has a width defined by the destination data width DDW_LOG2[1:0].
Note: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol.
Note: If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower singles/bursts, but the data integrity is guaranteed.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DBX</name>
              <description>destination byte exchange
If the destination data size is a byte, this bit is ignored.
If the destination data size is not a byte:</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no byte-based exchange within half-word</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>the two consecutive (post PAM) bytes are exchanged in each destination half-word.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DHX</name>
              <description>destination half-word exchange
If the destination data size is shorter than a word, this bit is ignored.
If the destination data size is a word:</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no halfword-based exchanged within word</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>the two consecutive (post PAM) half-words are exchanged in each destination word.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DAP</name>
              <description>destination allocated port
This bit is used to allocate the master port for the destination transfer
Note: This bit must be written when EN = 0. This bit is read-only when EN = 1.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>port 0 (AHB) allocated</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>port 1 (AHB) allocated</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DSEC</name>
              <description>security attribute of the GPDMA transfer to the destination
If GPDMA_SECCFGR.SECx = 1 and the access is secure:
This is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx = 1. A secure write is ignored when GPDMA_SECCFGR.SECx = 0.
When GPDMA_SECCFGR.SECx is deasserted, this DSEC bit is also deasserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer to the destination is non-secure.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>GPDMA transfer non-secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GPDMA transfer secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C3TR2</name>
          <displayName>GPDMA_C3TR2</displayName>
          <description>GPDMA channel 3 transfer register 2</description>
          <addressOffset>0x214</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REQSEL</name>
              <description>GPDMA hardware request selection
These bits are ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer). Else, the selected hardware request is internally taken into account as per Section 16.3.3.
The user must not assign a same input hardware request (same REQSEL[5:0] value) to different active GPDMA channels (GPDMA_CxCR.EN = 1 and GPDMA_CxTR2.SWREQ = 0 for these channels). GPDMA is not intended to hardware support the case of simultaneous enabled channels incorrectly configured with a same hardware peripheral request signal, and there is no user setting error reporting.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SWREQ</name>
              <description>software request
This bit is internally taken into account when GPDMA_CxCR.EN is asserted.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no software request. The selected hardware request REQSEL[5:0] is taken into account.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>software request for a memory-to-memory transfer. The default selected hardware request as per REQSEL[5:0] is ignored.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DREQ</name>
              <description>destination hardware request
This bit is ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer). Else:</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>selected hardware request driven by a source peripheral (request signal taken into account by the GPDMA transfer scheduler over the source/read port)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>selected hardware request driven by a destination peripheral (request signal taken into account by the GPDMA transfer scheduler over the destination/write port)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BREQ</name>
              <description>Block hardware request
If the channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer), this bit is ignored. Else:</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>the selected hardware request is driven by a peripheral with a hardware request/acknowledge protocol at a burst level.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>the selected hardware request is driven by a peripheral with a hardware request/acknowledge protocol at a block level (see Section 16.3.3).</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TRIGM</name>
              <description>trigger mode
These bits define the transfer granularity for its conditioning by the trigger.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>at block level: the first burst read of each block transfer is conditioned by one hit trigger .</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>channel x = 0 to 7, same as 0010: at link level: a LLI link transfer is conditioned by one hit trigger. The LLI data transfer (if any) is not conditioned.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>at programmed burst level: If SWREQ = 1, each programmed burst read is conditioned by one hit trigger. If SWREQ = 0, each programmed burst that is requested by the selected peripheral, is conditioned by one hit trigger.</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TRIGSEL</name>
              <description>trigger event input selection
These bits select the trigger event input of the GPDMA transfer (as per Section 16.3.5), with an active trigger event if TRIGPOL[1:0] different 00.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIGPOL</name>
              <description>trigger event polarity
These bits define the polarity of the selected trigger event input defined by TRIGSEL[4:0].</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no trigger (masked trigger event)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>trigger on the rising edge</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>trigger on the falling edge</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>same as 00</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TCEM</name>
              <description>transfer complete event mode
These bits define the transfer granularity for the transfer complete and half transfer complete events generation.
Note: If the initial LLIsub0 /subdata transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] = 0), then neither the complete transfer event nor the half transfer event is generated.
Note: If the initial LLIsub0 /subdata transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] = 0), then neither the complete transfer event nor the half transfer event is generated.
Note: If the initial LLIsub0 /subdata transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] =0 ), then the half transfer event is not generated, and the transfer complete event is generated when is completed the loading of the LLIsub1/sub.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>at block level (when GPDMA_CxBR1.BNDT[15:0] = 0): the complete (and the half) transfer event is generated at the (respectively half of the) end of a block.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>channel x (0 to 7, same as 00</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>at LLI level: the complete transfer event is generated at the end of the LLI transfer, including the update of the LLI if any. The half transfer event is generated at the half of the LLI data transfer.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>at channel level: the complete transfer event is generated at the end of the last LLI transfer. The half transfer event is generated at the half of the data transfer of the last LLI. The last LLI updates the link address GPDMA_CxLLR.LA[15:2] to zero and clears all the GPDMA_CxLLR update bits (UT1, UT2, UB1, USA, UDA and ULL). If the channel transfer is continuous/infinite, no event is generated.</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C3BR1</name>
          <displayName>GPDMA_C3BR1</displayName>
          <description>GPDMA channel 3 block register 1</description>
          <addressOffset>0x218</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BNDT</name>
              <description>block number of data bytes to transfer from the source
Block size transferred from the source. When the channel is enabled, this field becomes read-only and is decremented, indicating the remaining number of data items in the current source block to be transferred. BNDT[15:0] is programmed in number of bytes, maximum source block size is 64 Kbytes -1.
Once the last data transfer is completed (BNDT[15:0] = 0):
- if GPDMA_CxLLR.UB1 = 1, this field is updated by the LLI in the memory.
- if GPDMA_CxLLR.UB1 = 0 and if there is at least one non null Uxx update bit, this field is internally restored to the programmed value.
- if all GPDMA_CxLLR.Uxx = 0 and if GPDMA_CxLLR.LA[15:0] = 0, this field is internally restored to the programmed value (infinite/continuous last LLI).
- if GPDMA_CxLLR = 0, this field is kept as zero following the last LLI data transfer.
Note: A non-null source block size must be a multiple of the source data width (BNDT[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.
Note: When configured in packing mode (GPDMA_CxTR1.PAM[1] = 1 and destination data width different from source data width), a non-null source block size must be a multiple of the destination data width (BNDT[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C3SAR</name>
          <displayName>GPDMA_C3SAR</displayName>
          <description>GPDMA channel 3 source address register</description>
          <addressOffset>0x21C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SA</name>
              <description>source address
This field is the pointer to the address from which the next data is read.
During the channel activity, depending on the source addressing mode (GPDMA_CxTR1.SINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.SDW_LOG2[1:0]) after each burst source data, reflecting the next address from which data is read.
During the channel activity, this address is updated after each completed source burst, consequently to:
the programmed source burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.SINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.SBL_1[5:0] and GPDMA_CxTR1.SDW_LOG2[21:0]
the additional source incremented/decremented offset value as programmed by GPDMA_CxBR1.SDEC
In linked-list mode, after a LLI data transfer is completed, this register is automatically updated by GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.USA = 1.
Note: A source address must be aligned with the programmed data width of a source burst (SA[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C3DAR</name>
          <displayName>GPDMA_C3DAR</displayName>
          <description>GPDMA channel 3 destination address register</description>
          <addressOffset>0x220</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DA</name>
              <description>destination address
This field is the pointer to the address from which the next data is written.
During the channel activity, depending on the destination addressing mode (GPDMA_CxTR1.DINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.DDW_LOG2[21:0]) after each burst destination data, reflecting the next address from which data is written.
During the channel activity, this address is updated after each completed destination burst, consequently to:
the programmed destination burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.DINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.DBL_1[5:0] and GPDMA_CxTR1.DDW_LOG2[1:0]
the additional destination incremented/decremented offset value as programmed by GPDMA_CxBR1.DDEC.
In linked-list mode, after a LLI data transfer is completed, this register is automatically updated by the GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.UDA = 1.
Note: A destination address must be aligned with the programmed data width of a destination burst (DA[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C3LLR</name>
          <displayName>GPDMA_C3LLR</displayName>
          <description>GPDMA channel 3 linked-list address register</description>
          <addressOffset>0x24C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LA</name>
              <description>pointer (16-bit low-significant address) to the next linked-list data structure
If UT1 = UT2 = UB1 = USA = UDA = ULL = 0 and if LA[15:20] = 0, the current LLI is the last one. The channel transfer is completed without any update of the linked-list GPDMA register file.
Else, this field is the pointer to the memory address offset from which the next linked-list data structure is automatically fetched from, once the data transfer is completed, in order to conditionally update the linked-list GPDMA internal register file (GPDMA_CxCTR1, GPDMA_CxTR2, GPDMA_CxBR1, GPDMA_CxSAR, GPDMA_CxDAR and GPDMA_CxLLR).
Note: The user must program the pointer to be 32-bit aligned. The two low-significant bits are write ignored.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>14</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ULL</name>
              <description>Update GPDMA_CxLLR register from memory
This bit is used to control the update of GPDMA_CxLLR from the memory during the link transfer.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no GPDMA_CxLLR update</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GPDMA_CxLLR update</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UDA</name>
              <description>Update GPDMA_CxDAR register from memory
This bit is used to control the update of GPDMA_CxDAR from the memory during the link transfer.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no GPDMA_CxDAR update</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GPDMA_CxDAR update</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>USA</name>
              <description>update GPDMA_CxSAR from memory
This bit controls the update of GPDMA_CxSAR from the memory during the link transfer.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no GPDMA_CxSAR update</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GPDMA_CxSAR update</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UB1</name>
              <description>Update GPDMA_CxBR1 from memory
This bit controls the update of GPDMA_CxBR1 from the memory during the link transfer. If UB1 = 0 and if GPDMA_CxLLR different 0, the linked-list is not completed. GPDMA_CxBR1.BNDT[15:0] is then restored to the programmed value after data transfer is completed and before the link transfer.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no GPDMA_CxBR1 update from memory (GPDMA_CxBR1.BNDT[15:0] restored if any link transfer)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GPDMA_CxBR1 update</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UT2</name>
              <description>Update GPDMA_CxTR2 from memory
This bit controls the update of GPDMA_CxTR2 from the memory during the link transfer.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no GPDMA_CxTR2 update</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GPDMA_CxTR2 update</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UT1</name>
              <description>Update GPDMA_CxTR1 from memory
This bit controls the update of GPDMA_CxTR1 from the memory during the link transfer.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no GPDMA_CxTR1 update</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GPDMA_CxTR1 update</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C4LBAR</name>
          <displayName>GPDMA_C4LBAR</displayName>
          <description>GPDMA channel 4 linked-list base address register</description>
          <addressOffset>0x250</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LBA</name>
              <description>linked-list base address of GPDMA channel x</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C4FCR</name>
          <displayName>GPDMA_C4FCR</displayName>
          <description>GPDMA channel 4 flag clear register</description>
          <addressOffset>0x25C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TCF</name>
              <description>transfer complete flag clear</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>corresponding TCF flag cleared</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HTF</name>
              <description>half transfer flag clear</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>corresponding HTF flag cleared</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DTEF</name>
              <description>data transfer error flag clear</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>corresponding DTEF flag cleared</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ULEF</name>
              <description>update link transfer error flag clear</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>corresponding ULEF flag cleared</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>USEF</name>
              <description>user setting error flag clear</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>corresponding USEF flag cleared</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SUSPF</name>
              <description>completed suspension flag clear</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>corresponding SUSPF flag cleared</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TOF</name>
              <description>trigger overrun flag clear</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>corresponding TOF flag cleared</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C4SR</name>
          <displayName>GPDMA_C4SR</displayName>
          <description>GPDMA channel 4 status register</description>
          <addressOffset>0x260</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IDLEF</name>
              <description>idle flag
This idle flag is deasserted by hardware when the channel is enabled (GPDMA_CxCR.EN = 1) with a valid channel configuration (no USEF to be immediately reported).
This idle flag is asserted after hard reset or by hardware when the channel is back in idle state (in suspended or disabled state).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>channel not in idle state</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>channel in idle state</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TCF</name>
              <description>transfer complete flag
A transfer complete event is either a block transfer complete, or a LLI transfer complete including the upload of the next LLI if any, or the full linked-list completion, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0]).</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no transfer complete event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>a transfer complete event occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HTF</name>
              <description>half transfer flag
A half block transfer occurs when half of the bytes of the source block size (rounded up integer of GPDMA_CxBR1.BNDT[15:0]/2) has been transferred to the destination.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no half transfer event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>a half transfer event occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DTEF</name>
              <description>data transfer error flag</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no data transfer error event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>a master bus error event occurred on a data transfer</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ULEF</name>
              <description>update link transfer error flag</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no update link transfer error event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>a master bus error event occurred while updating a linked-list register from memory</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>USEF</name>
              <description>user setting error flag</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no user setting error event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>a user setting error event occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SUSPF</name>
              <description>completed suspension flag</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no completed suspension event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>a completed suspension event occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TOF</name>
              <description>trigger overrun flag</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no trigger overrun event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>a trigger overrun event occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FIFOL</name>
              <description>monitored FIFO level
Number of available write beats in the FIFO, in units of the programmed destination data width (see GPDMA_CxTR1.DDW_LOG2[1:0], in units of bytes, half-words, or words).
Note: After having suspended an active transfer, the user may need to read FIFOL[7:0], additionally to GPDMA_CxBR1.BDNT[15:0] to know how many data have been transferred to the destination. Before reading, the user may wait for the transfer to be suspended (GPDMA_CxSR.SUSPF = 1).</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C4CR</name>
          <displayName>GPDMA_C4CR</displayName>
          <description>GPDMA channel 4 control register</description>
          <addressOffset>0x264</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>enable
Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 0. Else: 
this bit is deasserted by hardware when there is a transfer error (master bus error or user setting error) or when there is a channel transfer complete (channel ready to be configured, for example if LSM=1 at the end of a single execution of the LLI).
Else, this bit can be asserted by software. 
Writing 0 into this EN bit is ignored.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>write: ignored, read: channel disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>write: enable channel, read: channel enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESET</name>
              <description>reset
This bit is write only. Writing 0 has no impact. Writing 1 implies the reset of the following: the FIFO, the channel internal state, SUSP and EN bits (whatever is written receptively in bit 2 and bit 0).
The reset is effective when the channel is in steady state, meaning one of the following:
- active channel in suspended state (GPDMA_CxSR.SUSPF = 1 and GPDMA_CxSR.IDLEF = GPDMA_CxCR.EN = 1)
- channel in disabled state (GPDMA_CxSR.IDLEF = 1 and GPDMA_CxCR.EN = 0).
After writing a RESET, to continue using this channel, the user must explicitly reconfigure the channel including the hardware-modified configuration registers (GPDMA_CxBR1, GPDMA_CxSAR and GPDMA_CxDAR) before enabling again the channel (see the programming sequence in Figure 44).</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no channel reset</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>channel reset</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SUSP</name>
              <description>suspend
Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 2. Else:
Software must write 1 in order to suspend an active channel (channel with an ongoing GPDMA transfer over its master ports). 
The software must write 0 in order to resume a suspended channel, following the programming sequence detailed in Figure 43.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>write: resume channel, read: channel not suspended</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>write: suspend channel, read: channel suspended.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TCIE</name>
              <description>transfer complete interrupt enable</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HTIE</name>
              <description>half transfer complete interrupt enable</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DTEIE</name>
              <description>data transfer error interrupt enable</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ULEIE</name>
              <description>update link transfer error interrupt enable</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>USEIE</name>
              <description>user setting error interrupt enable</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SUSPIE</name>
              <description>completed suspension interrupt enable</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TOIE</name>
              <description>trigger overrun interrupt enable</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LSM</name>
              <description>Link step mode
First the (possible 1D/repeated) block transfer is executed as defined by the current internal register file until GPDMA_CxBR1.BNDT[15:0] = 0. Secondly the next linked-list data structure is conditionally uploaded from memory as defined by GPDMA_CxLLR. Then channel execution is completed.
Note: This bit must be written when EN=0. This bit is read-only when EN=1.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>channel executed for the full linked-list and completed at the end of the last LLI (GPDMA_CxLLR = 0). The 16 low-significant bits of the link address are null (LA[15:0] = 0) and all the update bits are null (UT1 =UB1 = UT2 = USA = UDA = ULL = 0). Then GPDMA_CxBR1.BNDT[15:0] = 0.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>channel executed once for the current LLI</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LAP</name>
              <description>linked-list allocated port
This bit is used to allocate the master port for the update of the GPDMA linked-list registers from the memory.
Note: This bit must be written when EN=0. This bit is read-only when EN=1.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>port 0 (AHB) allocated</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>port 1 (AHB) allocated</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>priority level of the channel x GPDMA transfer versus others
Note: This bit must be written when EN = 0. This bit is read-only when EN = 1.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>low priority, low weight</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>low priority, mid weight</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>low priority, high weight</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>high priority</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C4TR1</name>
          <displayName>GPDMA_C4TR1</displayName>
          <description>GPDMA channel 4 transfer register 1</description>
          <addressOffset>0x290</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SDW_LOG2</name>
              <description>binary logarithm of the source data width of a burst in bytes
Setting a 8-byte data width causes a user setting error to be reported and no transfer is issued.
A source block size must be a multiple of the source data width (GPDMA_CxBR1.BNDT[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and no transfer is issued.
Note: A source burst transfer must have an aligned address with its data width (start address GPDMA_CxSAR[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and none transfer is issued.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>byte</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>half-word (2 bytes)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>word (4 bytes)</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>user setting error reported and no transfer issued</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SINC</name>
              <description>source incrementing burst
The source address, pointed by GPDMA_CxSAR, is kept constant after a burst beat/single transfer or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>fixed burst</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>contiguously incremented burst</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SBL_1</name>
              <description>source burst length minus 1, between 0 and 63
The burst length unit is one data named beat within a burst. If SBL_1[5:0] =0 , the burst can be named as single. Each data/beat has a width defined by the destination data width SDW_LOG2[1:0].
Note: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol.
Note: If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower singles/bursts, but the data integrity is guaranteed.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PAM</name>
              <description>padding/alignment mode
If DDW_LOG2[1:0] = SDW_LOG2[1:0]: if the data width of a burst destination transfer is equal to the data width of a burst source transfer, these bits are ignored.
Else, in the following enumerated values, the condition PAM_1 is when destination data width is higher that source data width, and the condition PAM_2 is when destination data width is higher than source data width.
1x: successive source data are FIFO queued and packed at the destination data width, in a left (LSB) to right (MSB) order (named little endian), before a destination transfer
Note: 1x: source data is FIFO queued and unpacked at the destination data width, to be transferred in a left (LSB) to right (MSB) order (named little endian) to the destination</description>
              <bitOffset>11</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0_PAM_1</name>
                  <description>source data is transferred as right aligned, padded with 0s up to the destination data width</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1_PAM_1</name>
                  <description>source data is transferred as right aligned, sign extended up to the destination data width</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SBX</name>
              <description>source byte exchange within the unaligned half-word of each source word 
If the source data width is shorter than a word, this bit is ignored.
If the source data width is a word:</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no byte-based exchange within the unaligned half-word of each source word</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>the two consecutive bytes within the unaligned half-word of each source word are exchanged.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SAP</name>
              <description>source allocated port
This bit is used to allocate the master port for the source transfer
Note: This bit must be written when EN = 0. This bit is read-only when EN = 1.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>port 0 (AHB) allocated</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>port 1 (AHB) allocated</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SSEC</name>
              <description>security attribute of the GPDMA transfer from the source
If GPDMA_SECCFGR.SECx = 1 and the access is secure:
This is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx =1 . A secure write is ignored when GPDMA_SECCFGR.SECx = 0.
When GPDMA_SECCFGR.SECx is deasserted, this SSEC bit is also deasserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer from the source is non-secure.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>GPDMA transfer non-secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GPDMA transfer secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DDW_LOG2</name>
              <description>binary logarithm of the destination data width of a burst, in bytes
Setting a 8-byte data width causes a user setting error to be reported and none transfer is issued.
Note: A destination burst transfer must have an aligned address with its data width (start address GPDMA_CxDAR[2:0] versus DDW_LOG2[1:0]). Otherwise a user setting error is reported and no transfer is issued.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>byte</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>half-word (2 bytes)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>word (4 bytes)</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>user setting error reported and no transfer issued</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DINC</name>
              <description>destination incrementing burst
The destination address, pointed by GPDMA_CxDAR, is kept constant after a burst beat/single transfer, or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>fixed burst</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>contiguously incremented burst</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DBL_1</name>
              <description>destination burst length minus 1, between 0 and 63
The burst length unit is one data named beat within a burst. If DBL_1[5:0] =0 , the burst can be named as single. Each data/beat has a width defined by the destination data width DDW_LOG2[1:0].
Note: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol.
Note: If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower singles/bursts, but the data integrity is guaranteed.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DBX</name>
              <description>destination byte exchange
If the destination data size is a byte, this bit is ignored.
If the destination data size is not a byte:</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no byte-based exchange within half-word</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>the two consecutive (post PAM) bytes are exchanged in each destination half-word.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DHX</name>
              <description>destination half-word exchange
If the destination data size is shorter than a word, this bit is ignored.
If the destination data size is a word:</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no halfword-based exchanged within word</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>the two consecutive (post PAM) half-words are exchanged in each destination word.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DAP</name>
              <description>destination allocated port
This bit is used to allocate the master port for the destination transfer
Note: This bit must be written when EN = 0. This bit is read-only when EN = 1.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>port 0 (AHB) allocated</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>port 1 (AHB) allocated</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DSEC</name>
              <description>security attribute of the GPDMA transfer to the destination
If GPDMA_SECCFGR.SECx = 1 and the access is secure:
This is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx = 1. A secure write is ignored when GPDMA_SECCFGR.SECx = 0.
When GPDMA_SECCFGR.SECx is deasserted, this DSEC bit is also deasserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer to the destination is non-secure.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>GPDMA transfer non-secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GPDMA transfer secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C4TR2</name>
          <displayName>GPDMA_C4TR2</displayName>
          <description>GPDMA channel 4 transfer register 2</description>
          <addressOffset>0x294</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REQSEL</name>
              <description>GPDMA hardware request selection
These bits are ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer). Else, the selected hardware request is internally taken into account as per Section 16.3.3.
The user must not assign a same input hardware request (same REQSEL[5:0] value) to different active GPDMA channels (GPDMA_CxCR.EN = 1 and GPDMA_CxTR2.SWREQ = 0 for these channels). GPDMA is not intended to hardware support the case of simultaneous enabled channels incorrectly configured with a same hardware peripheral request signal, and there is no user setting error reporting.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SWREQ</name>
              <description>software request
This bit is internally taken into account when GPDMA_CxCR.EN is asserted.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no software request. The selected hardware request REQSEL[5:0] is taken into account.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>software request for a memory-to-memory transfer. The default selected hardware request as per REQSEL[5:0] is ignored.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DREQ</name>
              <description>destination hardware request
This bit is ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer). Else:</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>selected hardware request driven by a source peripheral (request signal taken into account by the GPDMA transfer scheduler over the source/read port)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>selected hardware request driven by a destination peripheral (request signal taken into account by the GPDMA transfer scheduler over the destination/write port)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BREQ</name>
              <description>Block hardware request
If the channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer), this bit is ignored. Else:</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>the selected hardware request is driven by a peripheral with a hardware request/acknowledge protocol at a burst level.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>the selected hardware request is driven by a peripheral with a hardware request/acknowledge protocol at a block level (see Section 16.3.3).</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TRIGM</name>
              <description>trigger mode
These bits define the transfer granularity for its conditioning by the trigger.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>at block level: the first burst read of each block transfer is conditioned by one hit trigger .</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>channel x = 0 to 7, same as 0010: at link level: a LLI link transfer is conditioned by one hit trigger. The LLI data transfer (if any) is not conditioned.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>at programmed burst level: If SWREQ = 1, each programmed burst read is conditioned by one hit trigger. If SWREQ = 0, each programmed burst that is requested by the selected peripheral, is conditioned by one hit trigger.</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TRIGSEL</name>
              <description>trigger event input selection
These bits select the trigger event input of the GPDMA transfer (as per Section 16.3.5), with an active trigger event if TRIGPOL[1:0] different 00.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIGPOL</name>
              <description>trigger event polarity
These bits define the polarity of the selected trigger event input defined by TRIGSEL[4:0].</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no trigger (masked trigger event)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>trigger on the rising edge</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>trigger on the falling edge</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>same as 00</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TCEM</name>
              <description>transfer complete event mode
These bits define the transfer granularity for the transfer complete and half transfer complete events generation.
Note: If the initial LLIsub0 /subdata transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] = 0), then neither the complete transfer event nor the half transfer event is generated.
Note: If the initial LLIsub0 /subdata transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] = 0), then neither the complete transfer event nor the half transfer event is generated.
Note: If the initial LLIsub0 /subdata transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] =0 ), then the half transfer event is not generated, and the transfer complete event is generated when is completed the loading of the LLIsub1/sub.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>at block level (when GPDMA_CxBR1.BNDT[15:0] = 0): the complete (and the half) transfer event is generated at the (respectively half of the) end of a block.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>channel x (0 to 7, same as 00</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>at LLI level: the complete transfer event is generated at the end of the LLI transfer, including the update of the LLI if any. The half transfer event is generated at the half of the LLI data transfer.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>at channel level: the complete transfer event is generated at the end of the last LLI transfer. The half transfer event is generated at the half of the data transfer of the last LLI. The last LLI updates the link address GPDMA_CxLLR.LA[15:2] to zero and clears all the GPDMA_CxLLR update bits (UT1, UT2, UB1, USA, UDA and ULL). If the channel transfer is continuous/infinite, no event is generated.</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C4BR1</name>
          <displayName>GPDMA_C4BR1</displayName>
          <description>GPDMA channel 4 block register 1</description>
          <addressOffset>0x298</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BNDT</name>
              <description>block number of data bytes to transfer from the source
Block size transferred from the source. When the channel is enabled, this field becomes read-only and is decremented, indicating the remaining number of data items in the current source block to be transferred. BNDT[15:0] is programmed in number of bytes, maximum source block size is 64 Kbytes -1.
Once the last data transfer is completed (BNDT[15:0] = 0):
- if GPDMA_CxLLR.UB1 = 1, this field is updated by the LLI in the memory.
- if GPDMA_CxLLR.UB1 = 0 and if there is at least one non null Uxx update bit, this field is internally restored to the programmed value.
- if all GPDMA_CxLLR.Uxx = 0 and if GPDMA_CxLLR.LA[15:0] = 0, this field is internally restored to the programmed value (infinite/continuous last LLI).
- if GPDMA_CxLLR = 0, this field is kept as zero following the last LLI data transfer.
Note: A non-null source block size must be a multiple of the source data width (BNDT[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.
Note: When configured in packing mode (GPDMA_CxTR1.PAM[1] = 1 and destination data width different from source data width), a non-null source block size must be a multiple of the destination data width (BNDT[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C4SAR</name>
          <displayName>GPDMA_C4SAR</displayName>
          <description>GPDMA channel 4 source address register</description>
          <addressOffset>0x29C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SA</name>
              <description>source address
This field is the pointer to the address from which the next data is read.
During the channel activity, depending on the source addressing mode (GPDMA_CxTR1.SINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.SDW_LOG2[1:0]) after each burst source data, reflecting the next address from which data is read.
During the channel activity, this address is updated after each completed source burst, consequently to:
the programmed source burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.SINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.SBL_1[5:0] and GPDMA_CxTR1.SDW_LOG2[21:0]
the additional source incremented/decremented offset value as programmed by GPDMA_CxBR1.SDEC
In linked-list mode, after a LLI data transfer is completed, this register is automatically updated by GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.USA = 1.
Note: A source address must be aligned with the programmed data width of a source burst (SA[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C4DAR</name>
          <displayName>GPDMA_C4DAR</displayName>
          <description>GPDMA channel 4 destination address register</description>
          <addressOffset>0x2A0</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DA</name>
              <description>destination address
This field is the pointer to the address from which the next data is written.
During the channel activity, depending on the destination addressing mode (GPDMA_CxTR1.DINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.DDW_LOG2[21:0]) after each burst destination data, reflecting the next address from which data is written.
During the channel activity, this address is updated after each completed destination burst, consequently to:
the programmed destination burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.DINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.DBL_1[5:0] and GPDMA_CxTR1.DDW_LOG2[1:0]
the additional destination incremented/decremented offset value as programmed by GPDMA_CxBR1.DDEC.
In linked-list mode, after a LLI data transfer is completed, this register is automatically updated by the GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.UDA = 1.
Note: A destination address must be aligned with the programmed data width of a destination burst (DA[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C4LLR</name>
          <displayName>GPDMA_C4LLR</displayName>
          <description>GPDMA channel 4 linked-list address register</description>
          <addressOffset>0x2CC</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LA</name>
              <description>pointer (16-bit low-significant address) to the next linked-list data structure
If UT1 = UT2 = UB1 = USA = UDA = ULL = 0 and if LA[15:20] = 0, the current LLI is the last one. The channel transfer is completed without any update of the linked-list GPDMA register file.
Else, this field is the pointer to the memory address offset from which the next linked-list data structure is automatically fetched from, once the data transfer is completed, in order to conditionally update the linked-list GPDMA internal register file (GPDMA_CxCTR1, GPDMA_CxTR2, GPDMA_CxBR1, GPDMA_CxSAR, GPDMA_CxDAR and GPDMA_CxLLR).
Note: The user must program the pointer to be 32-bit aligned. The two low-significant bits are write ignored.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>14</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ULL</name>
              <description>Update GPDMA_CxLLR register from memory
This bit is used to control the update of GPDMA_CxLLR from the memory during the link transfer.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no GPDMA_CxLLR update</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GPDMA_CxLLR update</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UDA</name>
              <description>Update GPDMA_CxDAR register from memory
This bit is used to control the update of GPDMA_CxDAR from the memory during the link transfer.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no GPDMA_CxDAR update</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GPDMA_CxDAR update</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>USA</name>
              <description>update GPDMA_CxSAR from memory
This bit controls the update of GPDMA_CxSAR from the memory during the link transfer.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no GPDMA_CxSAR update</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GPDMA_CxSAR update</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UB1</name>
              <description>Update GPDMA_CxBR1 from memory
This bit controls the update of GPDMA_CxBR1 from the memory during the link transfer. If UB1 = 0 and if GPDMA_CxLLR different 0, the linked-list is not completed. GPDMA_CxBR1.BNDT[15:0] is then restored to the programmed value after data transfer is completed and before the link transfer.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no GPDMA_CxBR1 update from memory (GPDMA_CxBR1.BNDT[15:0] restored if any link transfer)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GPDMA_CxBR1 update</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UT2</name>
              <description>Update GPDMA_CxTR2 from memory
This bit controls the update of GPDMA_CxTR2 from the memory during the link transfer.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no GPDMA_CxTR2 update</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GPDMA_CxTR2 update</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UT1</name>
              <description>Update GPDMA_CxTR1 from memory
This bit controls the update of GPDMA_CxTR1 from the memory during the link transfer.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no GPDMA_CxTR1 update</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GPDMA_CxTR1 update</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C5LBAR</name>
          <displayName>GPDMA_C5LBAR</displayName>
          <description>GPDMA channel 5 linked-list base address register</description>
          <addressOffset>0x2D0</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LBA</name>
              <description>linked-list base address of GPDMA channel x</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C5FCR</name>
          <displayName>GPDMA_C5FCR</displayName>
          <description>GPDMA channel 5 flag clear register</description>
          <addressOffset>0x2DC</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TCF</name>
              <description>transfer complete flag clear</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>corresponding TCF flag cleared</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HTF</name>
              <description>half transfer flag clear</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>corresponding HTF flag cleared</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DTEF</name>
              <description>data transfer error flag clear</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>corresponding DTEF flag cleared</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ULEF</name>
              <description>update link transfer error flag clear</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>corresponding ULEF flag cleared</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>USEF</name>
              <description>user setting error flag clear</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>corresponding USEF flag cleared</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SUSPF</name>
              <description>completed suspension flag clear</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>corresponding SUSPF flag cleared</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TOF</name>
              <description>trigger overrun flag clear</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>corresponding TOF flag cleared</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C5SR</name>
          <displayName>GPDMA_C5SR</displayName>
          <description>GPDMA channel 5 status register</description>
          <addressOffset>0x2E0</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IDLEF</name>
              <description>idle flag
This idle flag is deasserted by hardware when the channel is enabled (GPDMA_CxCR.EN = 1) with a valid channel configuration (no USEF to be immediately reported).
This idle flag is asserted after hard reset or by hardware when the channel is back in idle state (in suspended or disabled state).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>channel not in idle state</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>channel in idle state</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TCF</name>
              <description>transfer complete flag
A transfer complete event is either a block transfer complete, or a LLI transfer complete including the upload of the next LLI if any, or the full linked-list completion, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0]).</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no transfer complete event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>a transfer complete event occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HTF</name>
              <description>half transfer flag
A half block transfer occurs when half of the bytes of the source block size (rounded up integer of GPDMA_CxBR1.BNDT[15:0]/2) has been transferred to the destination.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no half transfer event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>a half transfer event occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DTEF</name>
              <description>data transfer error flag</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no data transfer error event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>a master bus error event occurred on a data transfer</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ULEF</name>
              <description>update link transfer error flag</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no update link transfer error event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>a master bus error event occurred while updating a linked-list register from memory</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>USEF</name>
              <description>user setting error flag</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no user setting error event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>a user setting error event occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SUSPF</name>
              <description>completed suspension flag</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no completed suspension event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>a completed suspension event occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TOF</name>
              <description>trigger overrun flag</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no trigger overrun event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>a trigger overrun event occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FIFOL</name>
              <description>monitored FIFO level
Number of available write beats in the FIFO, in units of the programmed destination data width (see GPDMA_CxTR1.DDW_LOG2[1:0], in units of bytes, half-words, or words).
Note: After having suspended an active transfer, the user may need to read FIFOL[7:0], additionally to GPDMA_CxBR1.BDNT[15:0] to know how many data have been transferred to the destination. Before reading, the user may wait for the transfer to be suspended (GPDMA_CxSR.SUSPF = 1).</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C5CR</name>
          <displayName>GPDMA_C5CR</displayName>
          <description>GPDMA channel 5 control register</description>
          <addressOffset>0x2E4</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>enable
Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 0. Else: 
this bit is deasserted by hardware when there is a transfer error (master bus error or user setting error) or when there is a channel transfer complete (channel ready to be configured, for example if LSM=1 at the end of a single execution of the LLI).
Else, this bit can be asserted by software. 
Writing 0 into this EN bit is ignored.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>write: ignored, read: channel disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>write: enable channel, read: channel enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESET</name>
              <description>reset
This bit is write only. Writing 0 has no impact. Writing 1 implies the reset of the following: the FIFO, the channel internal state, SUSP and EN bits (whatever is written receptively in bit 2 and bit 0).
The reset is effective when the channel is in steady state, meaning one of the following:
- active channel in suspended state (GPDMA_CxSR.SUSPF = 1 and GPDMA_CxSR.IDLEF = GPDMA_CxCR.EN = 1)
- channel in disabled state (GPDMA_CxSR.IDLEF = 1 and GPDMA_CxCR.EN = 0).
After writing a RESET, to continue using this channel, the user must explicitly reconfigure the channel including the hardware-modified configuration registers (GPDMA_CxBR1, GPDMA_CxSAR and GPDMA_CxDAR) before enabling again the channel (see the programming sequence in Figure 44).</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no channel reset</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>channel reset</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SUSP</name>
              <description>suspend
Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 2. Else:
Software must write 1 in order to suspend an active channel (channel with an ongoing GPDMA transfer over its master ports). 
The software must write 0 in order to resume a suspended channel, following the programming sequence detailed in Figure 43.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>write: resume channel, read: channel not suspended</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>write: suspend channel, read: channel suspended.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TCIE</name>
              <description>transfer complete interrupt enable</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HTIE</name>
              <description>half transfer complete interrupt enable</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DTEIE</name>
              <description>data transfer error interrupt enable</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ULEIE</name>
              <description>update link transfer error interrupt enable</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>USEIE</name>
              <description>user setting error interrupt enable</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SUSPIE</name>
              <description>completed suspension interrupt enable</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TOIE</name>
              <description>trigger overrun interrupt enable</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LSM</name>
              <description>Link step mode
First the (possible 1D/repeated) block transfer is executed as defined by the current internal register file until GPDMA_CxBR1.BNDT[15:0] = 0. Secondly the next linked-list data structure is conditionally uploaded from memory as defined by GPDMA_CxLLR. Then channel execution is completed.
Note: This bit must be written when EN=0. This bit is read-only when EN=1.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>channel executed for the full linked-list and completed at the end of the last LLI (GPDMA_CxLLR = 0). The 16 low-significant bits of the link address are null (LA[15:0] = 0) and all the update bits are null (UT1 =UB1 = UT2 = USA = UDA = ULL = 0). Then GPDMA_CxBR1.BNDT[15:0] = 0.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>channel executed once for the current LLI</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LAP</name>
              <description>linked-list allocated port
This bit is used to allocate the master port for the update of the GPDMA linked-list registers from the memory.
Note: This bit must be written when EN=0. This bit is read-only when EN=1.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>port 0 (AHB) allocated</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>port 1 (AHB) allocated</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>priority level of the channel x GPDMA transfer versus others
Note: This bit must be written when EN = 0. This bit is read-only when EN = 1.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>low priority, low weight</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>low priority, mid weight</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>low priority, high weight</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>high priority</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C5TR1</name>
          <displayName>GPDMA_C5TR1</displayName>
          <description>GPDMA channel 5 transfer register 1</description>
          <addressOffset>0x310</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SDW_LOG2</name>
              <description>binary logarithm of the source data width of a burst in bytes
Setting a 8-byte data width causes a user setting error to be reported and no transfer is issued.
A source block size must be a multiple of the source data width (GPDMA_CxBR1.BNDT[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and no transfer is issued.
Note: A source burst transfer must have an aligned address with its data width (start address GPDMA_CxSAR[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and none transfer is issued.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>byte</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>half-word (2 bytes)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>word (4 bytes)</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>user setting error reported and no transfer issued</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SINC</name>
              <description>source incrementing burst
The source address, pointed by GPDMA_CxSAR, is kept constant after a burst beat/single transfer or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>fixed burst</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>contiguously incremented burst</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SBL_1</name>
              <description>source burst length minus 1, between 0 and 63
The burst length unit is one data named beat within a burst. If SBL_1[5:0] =0 , the burst can be named as single. Each data/beat has a width defined by the destination data width SDW_LOG2[1:0].
Note: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol.
Note: If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower singles/bursts, but the data integrity is guaranteed.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PAM</name>
              <description>padding/alignment mode
If DDW_LOG2[1:0] = SDW_LOG2[1:0]: if the data width of a burst destination transfer is equal to the data width of a burst source transfer, these bits are ignored.
Else, in the following enumerated values, the condition PAM_1 is when destination data width is higher that source data width, and the condition PAM_2 is when destination data width is higher than source data width.
1x: successive source data are FIFO queued and packed at the destination data width, in a left (LSB) to right (MSB) order (named little endian), before a destination transfer
Note: 1x: source data is FIFO queued and unpacked at the destination data width, to be transferred in a left (LSB) to right (MSB) order (named little endian) to the destination</description>
              <bitOffset>11</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0_PAM_1</name>
                  <description>source data is transferred as right aligned, padded with 0s up to the destination data width</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1_PAM_1</name>
                  <description>source data is transferred as right aligned, sign extended up to the destination data width</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SBX</name>
              <description>source byte exchange within the unaligned half-word of each source word 
If the source data width is shorter than a word, this bit is ignored.
If the source data width is a word:</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no byte-based exchange within the unaligned half-word of each source word</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>the two consecutive bytes within the unaligned half-word of each source word are exchanged.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SAP</name>
              <description>source allocated port
This bit is used to allocate the master port for the source transfer
Note: This bit must be written when EN = 0. This bit is read-only when EN = 1.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>port 0 (AHB) allocated</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>port 1 (AHB) allocated</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SSEC</name>
              <description>security attribute of the GPDMA transfer from the source
If GPDMA_SECCFGR.SECx = 1 and the access is secure:
This is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx =1 . A secure write is ignored when GPDMA_SECCFGR.SECx = 0.
When GPDMA_SECCFGR.SECx is deasserted, this SSEC bit is also deasserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer from the source is non-secure.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>GPDMA transfer non-secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GPDMA transfer secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DDW_LOG2</name>
              <description>binary logarithm of the destination data width of a burst, in bytes
Setting a 8-byte data width causes a user setting error to be reported and none transfer is issued.
Note: A destination burst transfer must have an aligned address with its data width (start address GPDMA_CxDAR[2:0] versus DDW_LOG2[1:0]). Otherwise a user setting error is reported and no transfer is issued.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>byte</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>half-word (2 bytes)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>word (4 bytes)</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>user setting error reported and no transfer issued</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DINC</name>
              <description>destination incrementing burst
The destination address, pointed by GPDMA_CxDAR, is kept constant after a burst beat/single transfer, or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>fixed burst</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>contiguously incremented burst</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DBL_1</name>
              <description>destination burst length minus 1, between 0 and 63
The burst length unit is one data named beat within a burst. If DBL_1[5:0] =0 , the burst can be named as single. Each data/beat has a width defined by the destination data width DDW_LOG2[1:0].
Note: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol.
Note: If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower singles/bursts, but the data integrity is guaranteed.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DBX</name>
              <description>destination byte exchange
If the destination data size is a byte, this bit is ignored.
If the destination data size is not a byte:</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no byte-based exchange within half-word</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>the two consecutive (post PAM) bytes are exchanged in each destination half-word.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DHX</name>
              <description>destination half-word exchange
If the destination data size is shorter than a word, this bit is ignored.
If the destination data size is a word:</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no halfword-based exchanged within word</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>the two consecutive (post PAM) half-words are exchanged in each destination word.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DAP</name>
              <description>destination allocated port
This bit is used to allocate the master port for the destination transfer
Note: This bit must be written when EN = 0. This bit is read-only when EN = 1.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>port 0 (AHB) allocated</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>port 1 (AHB) allocated</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DSEC</name>
              <description>security attribute of the GPDMA transfer to the destination
If GPDMA_SECCFGR.SECx = 1 and the access is secure:
This is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx = 1. A secure write is ignored when GPDMA_SECCFGR.SECx = 0.
When GPDMA_SECCFGR.SECx is deasserted, this DSEC bit is also deasserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer to the destination is non-secure.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>GPDMA transfer non-secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GPDMA transfer secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C5TR2</name>
          <displayName>GPDMA_C5TR2</displayName>
          <description>GPDMA channel 5 transfer register 2</description>
          <addressOffset>0x314</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REQSEL</name>
              <description>GPDMA hardware request selection
These bits are ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer). Else, the selected hardware request is internally taken into account as per Section 16.3.3.
The user must not assign a same input hardware request (same REQSEL[5:0] value) to different active GPDMA channels (GPDMA_CxCR.EN = 1 and GPDMA_CxTR2.SWREQ = 0 for these channels). GPDMA is not intended to hardware support the case of simultaneous enabled channels incorrectly configured with a same hardware peripheral request signal, and there is no user setting error reporting.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SWREQ</name>
              <description>software request
This bit is internally taken into account when GPDMA_CxCR.EN is asserted.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no software request. The selected hardware request REQSEL[5:0] is taken into account.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>software request for a memory-to-memory transfer. The default selected hardware request as per REQSEL[5:0] is ignored.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DREQ</name>
              <description>destination hardware request
This bit is ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer). Else:</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>selected hardware request driven by a source peripheral (request signal taken into account by the GPDMA transfer scheduler over the source/read port)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>selected hardware request driven by a destination peripheral (request signal taken into account by the GPDMA transfer scheduler over the destination/write port)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BREQ</name>
              <description>Block hardware request
If the channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer), this bit is ignored. Else:</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>the selected hardware request is driven by a peripheral with a hardware request/acknowledge protocol at a burst level.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>the selected hardware request is driven by a peripheral with a hardware request/acknowledge protocol at a block level (see Section 16.3.3).</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TRIGM</name>
              <description>trigger mode
These bits define the transfer granularity for its conditioning by the trigger.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>at block level: the first burst read of each block transfer is conditioned by one hit trigger .</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>channel x = 0 to 7, same as 0010: at link level: a LLI link transfer is conditioned by one hit trigger. The LLI data transfer (if any) is not conditioned.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>at programmed burst level: If SWREQ = 1, each programmed burst read is conditioned by one hit trigger. If SWREQ = 0, each programmed burst that is requested by the selected peripheral, is conditioned by one hit trigger.</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TRIGSEL</name>
              <description>trigger event input selection
These bits select the trigger event input of the GPDMA transfer (as per Section 16.3.5), with an active trigger event if TRIGPOL[1:0] different 00.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIGPOL</name>
              <description>trigger event polarity
These bits define the polarity of the selected trigger event input defined by TRIGSEL[4:0].</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no trigger (masked trigger event)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>trigger on the rising edge</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>trigger on the falling edge</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>same as 00</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TCEM</name>
              <description>transfer complete event mode
These bits define the transfer granularity for the transfer complete and half transfer complete events generation.
Note: If the initial LLIsub0 /subdata transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] = 0), then neither the complete transfer event nor the half transfer event is generated.
Note: If the initial LLIsub0 /subdata transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] = 0), then neither the complete transfer event nor the half transfer event is generated.
Note: If the initial LLIsub0 /subdata transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] =0 ), then the half transfer event is not generated, and the transfer complete event is generated when is completed the loading of the LLIsub1/sub.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>at block level (when GPDMA_CxBR1.BNDT[15:0] = 0): the complete (and the half) transfer event is generated at the (respectively half of the) end of a block.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>channel x (0 to 7, same as 00</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>at LLI level: the complete transfer event is generated at the end of the LLI transfer, including the update of the LLI if any. The half transfer event is generated at the half of the LLI data transfer.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>at channel level: the complete transfer event is generated at the end of the last LLI transfer. The half transfer event is generated at the half of the data transfer of the last LLI. The last LLI updates the link address GPDMA_CxLLR.LA[15:2] to zero and clears all the GPDMA_CxLLR update bits (UT1, UT2, UB1, USA, UDA and ULL). If the channel transfer is continuous/infinite, no event is generated.</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C5BR1</name>
          <displayName>GPDMA_C5BR1</displayName>
          <description>GPDMA channel 5 block register 1</description>
          <addressOffset>0x318</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BNDT</name>
              <description>block number of data bytes to transfer from the source
Block size transferred from the source. When the channel is enabled, this field becomes read-only and is decremented, indicating the remaining number of data items in the current source block to be transferred. BNDT[15:0] is programmed in number of bytes, maximum source block size is 64 Kbytes -1.
Once the last data transfer is completed (BNDT[15:0] = 0):
- if GPDMA_CxLLR.UB1 = 1, this field is updated by the LLI in the memory.
- if GPDMA_CxLLR.UB1 = 0 and if there is at least one non null Uxx update bit, this field is internally restored to the programmed value.
- if all GPDMA_CxLLR.Uxx = 0 and if GPDMA_CxLLR.LA[15:0] = 0, this field is internally restored to the programmed value (infinite/continuous last LLI).
- if GPDMA_CxLLR = 0, this field is kept as zero following the last LLI data transfer.
Note: A non-null source block size must be a multiple of the source data width (BNDT[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.
Note: When configured in packing mode (GPDMA_CxTR1.PAM[1] = 1 and destination data width different from source data width), a non-null source block size must be a multiple of the destination data width (BNDT[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C5SAR</name>
          <displayName>GPDMA_C5SAR</displayName>
          <description>GPDMA channel 5 source address register</description>
          <addressOffset>0x31C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SA</name>
              <description>source address
This field is the pointer to the address from which the next data is read.
During the channel activity, depending on the source addressing mode (GPDMA_CxTR1.SINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.SDW_LOG2[1:0]) after each burst source data, reflecting the next address from which data is read.
During the channel activity, this address is updated after each completed source burst, consequently to:
the programmed source burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.SINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.SBL_1[5:0] and GPDMA_CxTR1.SDW_LOG2[21:0]
the additional source incremented/decremented offset value as programmed by GPDMA_CxBR1.SDEC
In linked-list mode, after a LLI data transfer is completed, this register is automatically updated by GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.USA = 1.
Note: A source address must be aligned with the programmed data width of a source burst (SA[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C5DAR</name>
          <displayName>GPDMA_C5DAR</displayName>
          <description>GPDMA channel 5 destination address register</description>
          <addressOffset>0x320</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DA</name>
              <description>destination address
This field is the pointer to the address from which the next data is written.
During the channel activity, depending on the destination addressing mode (GPDMA_CxTR1.DINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.DDW_LOG2[21:0]) after each burst destination data, reflecting the next address from which data is written.
During the channel activity, this address is updated after each completed destination burst, consequently to:
the programmed destination burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.DINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.DBL_1[5:0] and GPDMA_CxTR1.DDW_LOG2[1:0]
the additional destination incremented/decremented offset value as programmed by GPDMA_CxBR1.DDEC.
In linked-list mode, after a LLI data transfer is completed, this register is automatically updated by the GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.UDA = 1.
Note: A destination address must be aligned with the programmed data width of a destination burst (DA[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C5LLR</name>
          <displayName>GPDMA_C5LLR</displayName>
          <description>GPDMA channel 5 linked-list address register</description>
          <addressOffset>0x34C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LA</name>
              <description>pointer (16-bit low-significant address) to the next linked-list data structure
If UT1 = UT2 = UB1 = USA = UDA = ULL = 0 and if LA[15:20] = 0, the current LLI is the last one. The channel transfer is completed without any update of the linked-list GPDMA register file.
Else, this field is the pointer to the memory address offset from which the next linked-list data structure is automatically fetched from, once the data transfer is completed, in order to conditionally update the linked-list GPDMA internal register file (GPDMA_CxCTR1, GPDMA_CxTR2, GPDMA_CxBR1, GPDMA_CxSAR, GPDMA_CxDAR and GPDMA_CxLLR).
Note: The user must program the pointer to be 32-bit aligned. The two low-significant bits are write ignored.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>14</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ULL</name>
              <description>Update GPDMA_CxLLR register from memory
This bit is used to control the update of GPDMA_CxLLR from the memory during the link transfer.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no GPDMA_CxLLR update</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GPDMA_CxLLR update</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UDA</name>
              <description>Update GPDMA_CxDAR register from memory
This bit is used to control the update of GPDMA_CxDAR from the memory during the link transfer.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no GPDMA_CxDAR update</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GPDMA_CxDAR update</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>USA</name>
              <description>update GPDMA_CxSAR from memory
This bit controls the update of GPDMA_CxSAR from the memory during the link transfer.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no GPDMA_CxSAR update</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GPDMA_CxSAR update</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UB1</name>
              <description>Update GPDMA_CxBR1 from memory
This bit controls the update of GPDMA_CxBR1 from the memory during the link transfer. If UB1 = 0 and if GPDMA_CxLLR different 0, the linked-list is not completed. GPDMA_CxBR1.BNDT[15:0] is then restored to the programmed value after data transfer is completed and before the link transfer.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no GPDMA_CxBR1 update from memory (GPDMA_CxBR1.BNDT[15:0] restored if any link transfer)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GPDMA_CxBR1 update</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UT2</name>
              <description>Update GPDMA_CxTR2 from memory
This bit controls the update of GPDMA_CxTR2 from the memory during the link transfer.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no GPDMA_CxTR2 update</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GPDMA_CxTR2 update</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UT1</name>
              <description>Update GPDMA_CxTR1 from memory
This bit controls the update of GPDMA_CxTR1 from the memory during the link transfer.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no GPDMA_CxTR1 update</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GPDMA_CxTR1 update</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C6LBAR</name>
          <displayName>GPDMA_C6LBAR</displayName>
          <description>GPDMA channel 6 linked-list base address register</description>
          <addressOffset>0x350</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LBA</name>
              <description>linked-list base address of GPDMA channel x</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C6FCR</name>
          <displayName>GPDMA_C6FCR</displayName>
          <description>GPDMA channel 6 flag clear register</description>
          <addressOffset>0x35C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TCF</name>
              <description>transfer complete flag clear</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>corresponding TCF flag cleared</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HTF</name>
              <description>half transfer flag clear</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>corresponding HTF flag cleared</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DTEF</name>
              <description>data transfer error flag clear</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>corresponding DTEF flag cleared</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ULEF</name>
              <description>update link transfer error flag clear</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>corresponding ULEF flag cleared</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>USEF</name>
              <description>user setting error flag clear</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>corresponding USEF flag cleared</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SUSPF</name>
              <description>completed suspension flag clear</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>corresponding SUSPF flag cleared</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TOF</name>
              <description>trigger overrun flag clear</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>corresponding TOF flag cleared</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C6SR</name>
          <displayName>GPDMA_C6SR</displayName>
          <description>GPDMA channel 6 status register</description>
          <addressOffset>0x360</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IDLEF</name>
              <description>idle flag
This idle flag is deasserted by hardware when the channel is enabled (GPDMA_CxCR.EN = 1) with a valid channel configuration (no USEF to be immediately reported).
This idle flag is asserted after hard reset or by hardware when the channel is back in idle state (in suspended or disabled state).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>channel not in idle state</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>channel in idle state</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TCF</name>
              <description>transfer complete flag
A transfer complete event is either a block transfer complete, or a LLI transfer complete including the upload of the next LLI if any, or the full linked-list completion, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0]).</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no transfer complete event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>a transfer complete event occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HTF</name>
              <description>half transfer flag
A half block transfer occurs when half of the bytes of the source block size (rounded up integer of GPDMA_CxBR1.BNDT[15:0]/2) has been transferred to the destination.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no half transfer event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>a half transfer event occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DTEF</name>
              <description>data transfer error flag</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no data transfer error event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>a master bus error event occurred on a data transfer</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ULEF</name>
              <description>update link transfer error flag</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no update link transfer error event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>a master bus error event occurred while updating a linked-list register from memory</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>USEF</name>
              <description>user setting error flag</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no user setting error event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>a user setting error event occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SUSPF</name>
              <description>completed suspension flag</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no completed suspension event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>a completed suspension event occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TOF</name>
              <description>trigger overrun flag</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no trigger overrun event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>a trigger overrun event occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FIFOL</name>
              <description>monitored FIFO level
Number of available write beats in the FIFO, in units of the programmed destination data width (see GPDMA_CxTR1.DDW_LOG2[1:0], in units of bytes, half-words, or words).
Note: After having suspended an active transfer, the user may need to read FIFOL[7:0], additionally to GPDMA_CxBR1.BDNT[15:0] to know how many data have been transferred to the destination. Before reading, the user may wait for the transfer to be suspended (GPDMA_CxSR.SUSPF = 1).</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C6CR</name>
          <displayName>GPDMA_C6CR</displayName>
          <description>GPDMA channel 6 control register</description>
          <addressOffset>0x364</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>enable
Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 0. Else: 
this bit is deasserted by hardware when there is a transfer error (master bus error or user setting error) or when there is a channel transfer complete (channel ready to be configured, for example if LSM=1 at the end of a single execution of the LLI).
Else, this bit can be asserted by software. 
Writing 0 into this EN bit is ignored.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>write: ignored, read: channel disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>write: enable channel, read: channel enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESET</name>
              <description>reset
This bit is write only. Writing 0 has no impact. Writing 1 implies the reset of the following: the FIFO, the channel internal state, SUSP and EN bits (whatever is written receptively in bit 2 and bit 0).
The reset is effective when the channel is in steady state, meaning one of the following:
- active channel in suspended state (GPDMA_CxSR.SUSPF = 1 and GPDMA_CxSR.IDLEF = GPDMA_CxCR.EN = 1)
- channel in disabled state (GPDMA_CxSR.IDLEF = 1 and GPDMA_CxCR.EN = 0).
After writing a RESET, to continue using this channel, the user must explicitly reconfigure the channel including the hardware-modified configuration registers (GPDMA_CxBR1, GPDMA_CxSAR and GPDMA_CxDAR) before enabling again the channel (see the programming sequence in Figure 44).</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no channel reset</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>channel reset</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SUSP</name>
              <description>suspend
Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 2. Else:
Software must write 1 in order to suspend an active channel (channel with an ongoing GPDMA transfer over its master ports). 
The software must write 0 in order to resume a suspended channel, following the programming sequence detailed in Figure 43.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>write: resume channel, read: channel not suspended</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>write: suspend channel, read: channel suspended.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TCIE</name>
              <description>transfer complete interrupt enable</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HTIE</name>
              <description>half transfer complete interrupt enable</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DTEIE</name>
              <description>data transfer error interrupt enable</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ULEIE</name>
              <description>update link transfer error interrupt enable</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>USEIE</name>
              <description>user setting error interrupt enable</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SUSPIE</name>
              <description>completed suspension interrupt enable</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TOIE</name>
              <description>trigger overrun interrupt enable</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LSM</name>
              <description>Link step mode
First the (possible 1D/repeated) block transfer is executed as defined by the current internal register file until GPDMA_CxBR1.BNDT[15:0] = 0. Secondly the next linked-list data structure is conditionally uploaded from memory as defined by GPDMA_CxLLR. Then channel execution is completed.
Note: This bit must be written when EN=0. This bit is read-only when EN=1.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>channel executed for the full linked-list and completed at the end of the last LLI (GPDMA_CxLLR = 0). The 16 low-significant bits of the link address are null (LA[15:0] = 0) and all the update bits are null (UT1 =UB1 = UT2 = USA = UDA = ULL = 0). Then GPDMA_CxBR1.BNDT[15:0] = 0.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>channel executed once for the current LLI</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LAP</name>
              <description>linked-list allocated port
This bit is used to allocate the master port for the update of the GPDMA linked-list registers from the memory.
Note: This bit must be written when EN=0. This bit is read-only when EN=1.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>port 0 (AHB) allocated</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>port 1 (AHB) allocated</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>priority level of the channel x GPDMA transfer versus others
Note: This bit must be written when EN = 0. This bit is read-only when EN = 1.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>low priority, low weight</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>low priority, mid weight</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>low priority, high weight</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>high priority</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C6TR1</name>
          <displayName>GPDMA_C6TR1</displayName>
          <description>GPDMA channel 6 transfer register 1</description>
          <addressOffset>0x390</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SDW_LOG2</name>
              <description>binary logarithm of the source data width of a burst in bytes
Setting a 8-byte data width causes a user setting error to be reported and no transfer is issued.
A source block size must be a multiple of the source data width (GPDMA_CxBR1.BNDT[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and no transfer is issued.
Note: A source burst transfer must have an aligned address with its data width (start address GPDMA_CxSAR[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and none transfer is issued.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>byte</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>half-word (2 bytes)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>word (4 bytes)</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>user setting error reported and no transfer issued</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SINC</name>
              <description>source incrementing burst
The source address, pointed by GPDMA_CxSAR, is kept constant after a burst beat/single transfer or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>fixed burst</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>contiguously incremented burst</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SBL_1</name>
              <description>source burst length minus 1, between 0 and 63
The burst length unit is one data named beat within a burst. If SBL_1[5:0] =0 , the burst can be named as single. Each data/beat has a width defined by the destination data width SDW_LOG2[1:0].
Note: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol.
Note: If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower singles/bursts, but the data integrity is guaranteed.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PAM</name>
              <description>padding/alignment mode
If DDW_LOG2[1:0] = SDW_LOG2[1:0]: if the data width of a burst destination transfer is equal to the data width of a burst source transfer, these bits are ignored.
Else, in the following enumerated values, the condition PAM_1 is when destination data width is higher that source data width, and the condition PAM_2 is when destination data width is higher than source data width.
1x: successive source data are FIFO queued and packed at the destination data width, in a left (LSB) to right (MSB) order (named little endian), before a destination transfer
Note: 1x: source data is FIFO queued and unpacked at the destination data width, to be transferred in a left (LSB) to right (MSB) order (named little endian) to the destination</description>
              <bitOffset>11</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0_PAM_1</name>
                  <description>source data is transferred as right aligned, padded with 0s up to the destination data width</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1_PAM_1</name>
                  <description>source data is transferred as right aligned, sign extended up to the destination data width</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SBX</name>
              <description>source byte exchange within the unaligned half-word of each source word 
If the source data width is shorter than a word, this bit is ignored.
If the source data width is a word:</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no byte-based exchange within the unaligned half-word of each source word</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>the two consecutive bytes within the unaligned half-word of each source word are exchanged.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SAP</name>
              <description>source allocated port
This bit is used to allocate the master port for the source transfer
Note: This bit must be written when EN = 0. This bit is read-only when EN = 1.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>port 0 (AHB) allocated</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>port 1 (AHB) allocated</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SSEC</name>
              <description>security attribute of the GPDMA transfer from the source
If GPDMA_SECCFGR.SECx = 1 and the access is secure:
This is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx =1 . A secure write is ignored when GPDMA_SECCFGR.SECx = 0.
When GPDMA_SECCFGR.SECx is deasserted, this SSEC bit is also deasserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer from the source is non-secure.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>GPDMA transfer non-secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GPDMA transfer secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DDW_LOG2</name>
              <description>binary logarithm of the destination data width of a burst, in bytes
Setting a 8-byte data width causes a user setting error to be reported and none transfer is issued.
Note: A destination burst transfer must have an aligned address with its data width (start address GPDMA_CxDAR[2:0] versus DDW_LOG2[1:0]). Otherwise a user setting error is reported and no transfer is issued.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>byte</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>half-word (2 bytes)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>word (4 bytes)</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>user setting error reported and no transfer issued</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DINC</name>
              <description>destination incrementing burst
The destination address, pointed by GPDMA_CxDAR, is kept constant after a burst beat/single transfer, or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>fixed burst</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>contiguously incremented burst</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DBL_1</name>
              <description>destination burst length minus 1, between 0 and 63
The burst length unit is one data named beat within a burst. If DBL_1[5:0] =0 , the burst can be named as single. Each data/beat has a width defined by the destination data width DDW_LOG2[1:0].
Note: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol.
Note: If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower singles/bursts, but the data integrity is guaranteed.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DBX</name>
              <description>destination byte exchange
If the destination data size is a byte, this bit is ignored.
If the destination data size is not a byte:</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no byte-based exchange within half-word</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>the two consecutive (post PAM) bytes are exchanged in each destination half-word.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DHX</name>
              <description>destination half-word exchange
If the destination data size is shorter than a word, this bit is ignored.
If the destination data size is a word:</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no halfword-based exchanged within word</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>the two consecutive (post PAM) half-words are exchanged in each destination word.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DAP</name>
              <description>destination allocated port
This bit is used to allocate the master port for the destination transfer
Note: This bit must be written when EN = 0. This bit is read-only when EN = 1.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>port 0 (AHB) allocated</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>port 1 (AHB) allocated</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DSEC</name>
              <description>security attribute of the GPDMA transfer to the destination
If GPDMA_SECCFGR.SECx = 1 and the access is secure:
This is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx = 1. A secure write is ignored when GPDMA_SECCFGR.SECx = 0.
When GPDMA_SECCFGR.SECx is deasserted, this DSEC bit is also deasserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer to the destination is non-secure.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>GPDMA transfer non-secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GPDMA transfer secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C6TR2</name>
          <displayName>GPDMA_C6TR2</displayName>
          <description>GPDMA channel 6 transfer register 2</description>
          <addressOffset>0x394</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REQSEL</name>
              <description>GPDMA hardware request selection
These bits are ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer). Else, the selected hardware request is internally taken into account as per Section 16.3.3.
The user must not assign a same input hardware request (same REQSEL[5:0] value) to different active GPDMA channels (GPDMA_CxCR.EN = 1 and GPDMA_CxTR2.SWREQ = 0 for these channels). GPDMA is not intended to hardware support the case of simultaneous enabled channels incorrectly configured with a same hardware peripheral request signal, and there is no user setting error reporting.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SWREQ</name>
              <description>software request
This bit is internally taken into account when GPDMA_CxCR.EN is asserted.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no software request. The selected hardware request REQSEL[5:0] is taken into account.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>software request for a memory-to-memory transfer. The default selected hardware request as per REQSEL[5:0] is ignored.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DREQ</name>
              <description>destination hardware request
This bit is ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer). Else:</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>selected hardware request driven by a source peripheral (request signal taken into account by the GPDMA transfer scheduler over the source/read port)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>selected hardware request driven by a destination peripheral (request signal taken into account by the GPDMA transfer scheduler over the destination/write port)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BREQ</name>
              <description>Block hardware request
If the channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer), this bit is ignored. Else:</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>the selected hardware request is driven by a peripheral with a hardware request/acknowledge protocol at a burst level.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>the selected hardware request is driven by a peripheral with a hardware request/acknowledge protocol at a block level (see Section 16.3.3).</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TRIGM</name>
              <description>trigger mode
These bits define the transfer granularity for its conditioning by the trigger.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>at block level: the first burst read of each block transfer is conditioned by one hit trigger .</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>channel x = 0 to 7, same as 0010: at link level: a LLI link transfer is conditioned by one hit trigger. The LLI data transfer (if any) is not conditioned.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>at programmed burst level: If SWREQ = 1, each programmed burst read is conditioned by one hit trigger. If SWREQ = 0, each programmed burst that is requested by the selected peripheral, is conditioned by one hit trigger.</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TRIGSEL</name>
              <description>trigger event input selection
These bits select the trigger event input of the GPDMA transfer (as per Section 16.3.5), with an active trigger event if TRIGPOL[1:0] different 00.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIGPOL</name>
              <description>trigger event polarity
These bits define the polarity of the selected trigger event input defined by TRIGSEL[4:0].</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no trigger (masked trigger event)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>trigger on the rising edge</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>trigger on the falling edge</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>same as 00</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TCEM</name>
              <description>transfer complete event mode
These bits define the transfer granularity for the transfer complete and half transfer complete events generation.
Note: If the initial LLIsub0 /subdata transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] = 0), then neither the complete transfer event nor the half transfer event is generated.
Note: If the initial LLIsub0 /subdata transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] = 0), then neither the complete transfer event nor the half transfer event is generated.
Note: If the initial LLIsub0 /subdata transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] =0 ), then the half transfer event is not generated, and the transfer complete event is generated when is completed the loading of the LLIsub1/sub.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>at block level (when GPDMA_CxBR1.BNDT[15:0] = 0): the complete (and the half) transfer event is generated at the (respectively half of the) end of a block.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>channel x (0 to 7, same as 00</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>at LLI level: the complete transfer event is generated at the end of the LLI transfer, including the update of the LLI if any. The half transfer event is generated at the half of the LLI data transfer.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>at channel level: the complete transfer event is generated at the end of the last LLI transfer. The half transfer event is generated at the half of the data transfer of the last LLI. The last LLI updates the link address GPDMA_CxLLR.LA[15:2] to zero and clears all the GPDMA_CxLLR update bits (UT1, UT2, UB1, USA, UDA and ULL). If the channel transfer is continuous/infinite, no event is generated.</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C6BR1</name>
          <displayName>GPDMA_C6BR1</displayName>
          <description>GPDMA channel 6 block register 1</description>
          <addressOffset>0x398</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BNDT</name>
              <description>block number of data bytes to transfer from the source
Block size transferred from the source. When the channel is enabled, this field becomes read-only and is decremented, indicating the remaining number of data items in the current source block to be transferred. BNDT[15:0] is programmed in number of bytes, maximum source block size is 64 Kbytes -1.
Once the last data transfer is completed (BNDT[15:0] = 0):
- if GPDMA_CxLLR.UB1 = 1, this field is updated by the LLI in the memory.
- if GPDMA_CxLLR.UB1 = 0 and if there is at least one non null Uxx update bit, this field is internally restored to the programmed value.
- if all GPDMA_CxLLR.Uxx = 0 and if GPDMA_CxLLR.LA[15:0] = 0, this field is internally restored to the programmed value (infinite/continuous last LLI).
- if GPDMA_CxLLR = 0, this field is kept as zero following the last LLI data transfer.
Note: A non-null source block size must be a multiple of the source data width (BNDT[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.
Note: When configured in packing mode (GPDMA_CxTR1.PAM[1] = 1 and destination data width different from source data width), a non-null source block size must be a multiple of the destination data width (BNDT[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C6SAR</name>
          <displayName>GPDMA_C6SAR</displayName>
          <description>GPDMA channel 6 source address register</description>
          <addressOffset>0x39C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SA</name>
              <description>source address
This field is the pointer to the address from which the next data is read.
During the channel activity, depending on the source addressing mode (GPDMA_CxTR1.SINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.SDW_LOG2[1:0]) after each burst source data, reflecting the next address from which data is read.
During the channel activity, this address is updated after each completed source burst, consequently to:
the programmed source burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.SINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.SBL_1[5:0] and GPDMA_CxTR1.SDW_LOG2[21:0]
the additional source incremented/decremented offset value as programmed by GPDMA_CxBR1.SDEC
In linked-list mode, after a LLI data transfer is completed, this register is automatically updated by GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.USA = 1.
Note: A source address must be aligned with the programmed data width of a source burst (SA[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C6DAR</name>
          <displayName>GPDMA_C6DAR</displayName>
          <description>GPDMA channel 6 destination address register</description>
          <addressOffset>0x3A0</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DA</name>
              <description>destination address
This field is the pointer to the address from which the next data is written.
During the channel activity, depending on the destination addressing mode (GPDMA_CxTR1.DINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.DDW_LOG2[21:0]) after each burst destination data, reflecting the next address from which data is written.
During the channel activity, this address is updated after each completed destination burst, consequently to:
the programmed destination burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.DINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.DBL_1[5:0] and GPDMA_CxTR1.DDW_LOG2[1:0]
the additional destination incremented/decremented offset value as programmed by GPDMA_CxBR1.DDEC.
In linked-list mode, after a LLI data transfer is completed, this register is automatically updated by the GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.UDA = 1.
Note: A destination address must be aligned with the programmed data width of a destination burst (DA[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C6LLR</name>
          <displayName>GPDMA_C6LLR</displayName>
          <description>GPDMA channel 6 linked-list address register</description>
          <addressOffset>0x3CC</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LA</name>
              <description>pointer (16-bit low-significant address) to the next linked-list data structure
If UT1 = UT2 = UB1 = USA = UDA = ULL = 0 and if LA[15:20] = 0, the current LLI is the last one. The channel transfer is completed without any update of the linked-list GPDMA register file.
Else, this field is the pointer to the memory address offset from which the next linked-list data structure is automatically fetched from, once the data transfer is completed, in order to conditionally update the linked-list GPDMA internal register file (GPDMA_CxCTR1, GPDMA_CxTR2, GPDMA_CxBR1, GPDMA_CxSAR, GPDMA_CxDAR and GPDMA_CxLLR).
Note: The user must program the pointer to be 32-bit aligned. The two low-significant bits are write ignored.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>14</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ULL</name>
              <description>Update GPDMA_CxLLR register from memory
This bit is used to control the update of GPDMA_CxLLR from the memory during the link transfer.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no GPDMA_CxLLR update</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GPDMA_CxLLR update</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UDA</name>
              <description>Update GPDMA_CxDAR register from memory
This bit is used to control the update of GPDMA_CxDAR from the memory during the link transfer.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no GPDMA_CxDAR update</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GPDMA_CxDAR update</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>USA</name>
              <description>update GPDMA_CxSAR from memory
This bit controls the update of GPDMA_CxSAR from the memory during the link transfer.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no GPDMA_CxSAR update</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GPDMA_CxSAR update</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UB1</name>
              <description>Update GPDMA_CxBR1 from memory
This bit controls the update of GPDMA_CxBR1 from the memory during the link transfer. If UB1 = 0 and if GPDMA_CxLLR different 0, the linked-list is not completed. GPDMA_CxBR1.BNDT[15:0] is then restored to the programmed value after data transfer is completed and before the link transfer.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no GPDMA_CxBR1 update from memory (GPDMA_CxBR1.BNDT[15:0] restored if any link transfer)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GPDMA_CxBR1 update</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UT2</name>
              <description>Update GPDMA_CxTR2 from memory
This bit controls the update of GPDMA_CxTR2 from the memory during the link transfer.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no GPDMA_CxTR2 update</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GPDMA_CxTR2 update</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UT1</name>
              <description>Update GPDMA_CxTR1 from memory
This bit controls the update of GPDMA_CxTR1 from the memory during the link transfer.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no GPDMA_CxTR1 update</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GPDMA_CxTR1 update</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C7LBAR</name>
          <displayName>GPDMA_C7LBAR</displayName>
          <description>GPDMA channel 7 linked-list base address register</description>
          <addressOffset>0x3D0</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LBA</name>
              <description>linked-list base address of GPDMA channel x</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C7FCR</name>
          <displayName>GPDMA_C7FCR</displayName>
          <description>GPDMA channel 7 flag clear register</description>
          <addressOffset>0x3DC</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TCF</name>
              <description>transfer complete flag clear</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>corresponding TCF flag cleared</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HTF</name>
              <description>half transfer flag clear</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>corresponding HTF flag cleared</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DTEF</name>
              <description>data transfer error flag clear</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>corresponding DTEF flag cleared</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ULEF</name>
              <description>update link transfer error flag clear</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>corresponding ULEF flag cleared</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>USEF</name>
              <description>user setting error flag clear</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>corresponding USEF flag cleared</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SUSPF</name>
              <description>completed suspension flag clear</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>corresponding SUSPF flag cleared</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TOF</name>
              <description>trigger overrun flag clear</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>corresponding TOF flag cleared</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C7SR</name>
          <displayName>GPDMA_C7SR</displayName>
          <description>GPDMA channel 7 status register</description>
          <addressOffset>0x3E0</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IDLEF</name>
              <description>idle flag
This idle flag is deasserted by hardware when the channel is enabled (GPDMA_CxCR.EN = 1) with a valid channel configuration (no USEF to be immediately reported).
This idle flag is asserted after hard reset or by hardware when the channel is back in idle state (in suspended or disabled state).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>channel not in idle state</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>channel in idle state</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TCF</name>
              <description>transfer complete flag
A transfer complete event is either a block transfer complete, or a LLI transfer complete including the upload of the next LLI if any, or the full linked-list completion, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0]).</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no transfer complete event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>a transfer complete event occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HTF</name>
              <description>half transfer flag
A half block transfer occurs when half of the bytes of the source block size (rounded up integer of GPDMA_CxBR1.BNDT[15:0]/2) has been transferred to the destination.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no half transfer event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>a half transfer event occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DTEF</name>
              <description>data transfer error flag</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no data transfer error event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>a master bus error event occurred on a data transfer</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ULEF</name>
              <description>update link transfer error flag</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no update link transfer error event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>a master bus error event occurred while updating a linked-list register from memory</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>USEF</name>
              <description>user setting error flag</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no user setting error event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>a user setting error event occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SUSPF</name>
              <description>completed suspension flag</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no completed suspension event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>a completed suspension event occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TOF</name>
              <description>trigger overrun flag</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no trigger overrun event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>a trigger overrun event occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FIFOL</name>
              <description>monitored FIFO level
Number of available write beats in the FIFO, in units of the programmed destination data width (see GPDMA_CxTR1.DDW_LOG2[1:0], in units of bytes, half-words, or words).
Note: After having suspended an active transfer, the user may need to read FIFOL[7:0], additionally to GPDMA_CxBR1.BDNT[15:0] to know how many data have been transferred to the destination. Before reading, the user may wait for the transfer to be suspended (GPDMA_CxSR.SUSPF = 1).</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C7CR</name>
          <displayName>GPDMA_C7CR</displayName>
          <description>GPDMA channel 7 control register</description>
          <addressOffset>0x3E4</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>enable
Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 0. Else: 
this bit is deasserted by hardware when there is a transfer error (master bus error or user setting error) or when there is a channel transfer complete (channel ready to be configured, for example if LSM=1 at the end of a single execution of the LLI).
Else, this bit can be asserted by software. 
Writing 0 into this EN bit is ignored.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>write: ignored, read: channel disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>write: enable channel, read: channel enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESET</name>
              <description>reset
This bit is write only. Writing 0 has no impact. Writing 1 implies the reset of the following: the FIFO, the channel internal state, SUSP and EN bits (whatever is written receptively in bit 2 and bit 0).
The reset is effective when the channel is in steady state, meaning one of the following:
- active channel in suspended state (GPDMA_CxSR.SUSPF = 1 and GPDMA_CxSR.IDLEF = GPDMA_CxCR.EN = 1)
- channel in disabled state (GPDMA_CxSR.IDLEF = 1 and GPDMA_CxCR.EN = 0).
After writing a RESET, to continue using this channel, the user must explicitly reconfigure the channel including the hardware-modified configuration registers (GPDMA_CxBR1, GPDMA_CxSAR and GPDMA_CxDAR) before enabling again the channel (see the programming sequence in Figure 44).</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no channel reset</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>channel reset</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SUSP</name>
              <description>suspend
Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 2. Else:
Software must write 1 in order to suspend an active channel (channel with an ongoing GPDMA transfer over its master ports). 
The software must write 0 in order to resume a suspended channel, following the programming sequence detailed in Figure 43.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>write: resume channel, read: channel not suspended</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>write: suspend channel, read: channel suspended.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TCIE</name>
              <description>transfer complete interrupt enable</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HTIE</name>
              <description>half transfer complete interrupt enable</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DTEIE</name>
              <description>data transfer error interrupt enable</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ULEIE</name>
              <description>update link transfer error interrupt enable</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>USEIE</name>
              <description>user setting error interrupt enable</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SUSPIE</name>
              <description>completed suspension interrupt enable</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TOIE</name>
              <description>trigger overrun interrupt enable</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LSM</name>
              <description>Link step mode
First the (possible 1D/repeated) block transfer is executed as defined by the current internal register file until GPDMA_CxBR1.BNDT[15:0] = 0. Secondly the next linked-list data structure is conditionally uploaded from memory as defined by GPDMA_CxLLR. Then channel execution is completed.
Note: This bit must be written when EN=0. This bit is read-only when EN=1.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>channel executed for the full linked-list and completed at the end of the last LLI (GPDMA_CxLLR = 0). The 16 low-significant bits of the link address are null (LA[15:0] = 0) and all the update bits are null (UT1 =UB1 = UT2 = USA = UDA = ULL = 0). Then GPDMA_CxBR1.BNDT[15:0] = 0.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>channel executed once for the current LLI</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LAP</name>
              <description>linked-list allocated port
This bit is used to allocate the master port for the update of the GPDMA linked-list registers from the memory.
Note: This bit must be written when EN=0. This bit is read-only when EN=1.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>port 0 (AHB) allocated</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>port 1 (AHB) allocated</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>priority level of the channel x GPDMA transfer versus others
Note: This bit must be written when EN = 0. This bit is read-only when EN = 1.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>low priority, low weight</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>low priority, mid weight</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>low priority, high weight</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>high priority</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C7TR1</name>
          <displayName>GPDMA_C7TR1</displayName>
          <description>GPDMA channel 7 transfer register 1</description>
          <addressOffset>0x410</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SDW_LOG2</name>
              <description>binary logarithm of the source data width of a burst in bytes
Setting a 8-byte data width causes a user setting error to be reported and no transfer is issued.
A source block size must be a multiple of the source data width (GPDMA_CxBR1.BNDT[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and no transfer is issued.
Note: A source burst transfer must have an aligned address with its data width (start address GPDMA_CxSAR[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and none transfer is issued.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>byte</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>half-word (2 bytes)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>word (4 bytes)</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>user setting error reported and no transfer issued</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SINC</name>
              <description>source incrementing burst
The source address, pointed by GPDMA_CxSAR, is kept constant after a burst beat/single transfer or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>fixed burst</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>contiguously incremented burst</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SBL_1</name>
              <description>source burst length minus 1, between 0 and 63
The burst length unit is one data named beat within a burst. If SBL_1[5:0] =0 , the burst can be named as single. Each data/beat has a width defined by the destination data width SDW_LOG2[1:0].
Note: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol.
Note: If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower singles/bursts, but the data integrity is guaranteed.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PAM</name>
              <description>padding/alignment mode
If DDW_LOG2[1:0] = SDW_LOG2[1:0]: if the data width of a burst destination transfer is equal to the data width of a burst source transfer, these bits are ignored.
Else, in the following enumerated values, the condition PAM_1 is when destination data width is higher that source data width, and the condition PAM_2 is when destination data width is higher than source data width.
1x: successive source data are FIFO queued and packed at the destination data width, in a left (LSB) to right (MSB) order (named little endian), before a destination transfer
Note: 1x: source data is FIFO queued and unpacked at the destination data width, to be transferred in a left (LSB) to right (MSB) order (named little endian) to the destination</description>
              <bitOffset>11</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0_PAM_1</name>
                  <description>source data is transferred as right aligned, padded with 0s up to the destination data width</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1_PAM_1</name>
                  <description>source data is transferred as right aligned, sign extended up to the destination data width</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SBX</name>
              <description>source byte exchange within the unaligned half-word of each source word 
If the source data width is shorter than a word, this bit is ignored.
If the source data width is a word:</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no byte-based exchange within the unaligned half-word of each source word</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>the two consecutive bytes within the unaligned half-word of each source word are exchanged.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SAP</name>
              <description>source allocated port
This bit is used to allocate the master port for the source transfer
Note: This bit must be written when EN = 0. This bit is read-only when EN = 1.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>port 0 (AHB) allocated</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>port 1 (AHB) allocated</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SSEC</name>
              <description>security attribute of the GPDMA transfer from the source
If GPDMA_SECCFGR.SECx = 1 and the access is secure:
This is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx =1 . A secure write is ignored when GPDMA_SECCFGR.SECx = 0.
When GPDMA_SECCFGR.SECx is deasserted, this SSEC bit is also deasserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer from the source is non-secure.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>GPDMA transfer non-secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GPDMA transfer secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DDW_LOG2</name>
              <description>binary logarithm of the destination data width of a burst, in bytes
Setting a 8-byte data width causes a user setting error to be reported and none transfer is issued.
Note: A destination burst transfer must have an aligned address with its data width (start address GPDMA_CxDAR[2:0] versus DDW_LOG2[1:0]). Otherwise a user setting error is reported and no transfer is issued.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>byte</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>half-word (2 bytes)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>word (4 bytes)</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>user setting error reported and no transfer issued</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DINC</name>
              <description>destination incrementing burst
The destination address, pointed by GPDMA_CxDAR, is kept constant after a burst beat/single transfer, or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>fixed burst</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>contiguously incremented burst</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DBL_1</name>
              <description>destination burst length minus 1, between 0 and 63
The burst length unit is one data named beat within a burst. If DBL_1[5:0] =0 , the burst can be named as single. Each data/beat has a width defined by the destination data width DDW_LOG2[1:0].
Note: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol.
Note: If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower singles/bursts, but the data integrity is guaranteed.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DBX</name>
              <description>destination byte exchange
If the destination data size is a byte, this bit is ignored.
If the destination data size is not a byte:</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no byte-based exchange within half-word</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>the two consecutive (post PAM) bytes are exchanged in each destination half-word.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DHX</name>
              <description>destination half-word exchange
If the destination data size is shorter than a word, this bit is ignored.
If the destination data size is a word:</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no halfword-based exchanged within word</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>the two consecutive (post PAM) half-words are exchanged in each destination word.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DAP</name>
              <description>destination allocated port
This bit is used to allocate the master port for the destination transfer
Note: This bit must be written when EN = 0. This bit is read-only when EN = 1.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>port 0 (AHB) allocated</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>port 1 (AHB) allocated</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DSEC</name>
              <description>security attribute of the GPDMA transfer to the destination
If GPDMA_SECCFGR.SECx = 1 and the access is secure:
This is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx = 1. A secure write is ignored when GPDMA_SECCFGR.SECx = 0.
When GPDMA_SECCFGR.SECx is deasserted, this DSEC bit is also deasserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer to the destination is non-secure.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>GPDMA transfer non-secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GPDMA transfer secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C7TR2</name>
          <displayName>GPDMA_C7TR2</displayName>
          <description>GPDMA channel 7 transfer register 2</description>
          <addressOffset>0x414</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REQSEL</name>
              <description>GPDMA hardware request selection
These bits are ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer). Else, the selected hardware request is internally taken into account as per Section 16.3.3.
The user must not assign a same input hardware request (same REQSEL[5:0] value) to different active GPDMA channels (GPDMA_CxCR.EN = 1 and GPDMA_CxTR2.SWREQ = 0 for these channels). GPDMA is not intended to hardware support the case of simultaneous enabled channels incorrectly configured with a same hardware peripheral request signal, and there is no user setting error reporting.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SWREQ</name>
              <description>software request
This bit is internally taken into account when GPDMA_CxCR.EN is asserted.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no software request. The selected hardware request REQSEL[5:0] is taken into account.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>software request for a memory-to-memory transfer. The default selected hardware request as per REQSEL[5:0] is ignored.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DREQ</name>
              <description>destination hardware request
This bit is ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer). Else:</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>selected hardware request driven by a source peripheral (request signal taken into account by the GPDMA transfer scheduler over the source/read port)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>selected hardware request driven by a destination peripheral (request signal taken into account by the GPDMA transfer scheduler over the destination/write port)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BREQ</name>
              <description>Block hardware request
If the channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer), this bit is ignored. Else:</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>the selected hardware request is driven by a peripheral with a hardware request/acknowledge protocol at a burst level.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>the selected hardware request is driven by a peripheral with a hardware request/acknowledge protocol at a block level (see Section 16.3.3).</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TRIGM</name>
              <description>trigger mode
These bits define the transfer granularity for its conditioning by the trigger.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>at block level: the first burst read of each block transfer is conditioned by one hit trigger .</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>channel x = 0 to 7, same as 0010: at link level: a LLI link transfer is conditioned by one hit trigger. The LLI data transfer (if any) is not conditioned.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>at programmed burst level: If SWREQ = 1, each programmed burst read is conditioned by one hit trigger. If SWREQ = 0, each programmed burst that is requested by the selected peripheral, is conditioned by one hit trigger.</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TRIGSEL</name>
              <description>trigger event input selection
These bits select the trigger event input of the GPDMA transfer (as per Section 16.3.5), with an active trigger event if TRIGPOL[1:0] different 00.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIGPOL</name>
              <description>trigger event polarity
These bits define the polarity of the selected trigger event input defined by TRIGSEL[4:0].</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no trigger (masked trigger event)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>trigger on the rising edge</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>trigger on the falling edge</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>same as 00</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TCEM</name>
              <description>transfer complete event mode
These bits define the transfer granularity for the transfer complete and half transfer complete events generation.
Note: If the initial LLIsub0 /subdata transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] = 0), then neither the complete transfer event nor the half transfer event is generated.
Note: If the initial LLIsub0 /subdata transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] = 0), then neither the complete transfer event nor the half transfer event is generated.
Note: If the initial LLIsub0 /subdata transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] =0 ), then the half transfer event is not generated, and the transfer complete event is generated when is completed the loading of the LLIsub1/sub.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>at block level (when GPDMA_CxBR1.BNDT[15:0] = 0): the complete (and the half) transfer event is generated at the (respectively half of the) end of a block.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>channel x (0 to 7, same as 00</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>at LLI level: the complete transfer event is generated at the end of the LLI transfer, including the update of the LLI if any. The half transfer event is generated at the half of the LLI data transfer.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>at channel level: the complete transfer event is generated at the end of the last LLI transfer. The half transfer event is generated at the half of the data transfer of the last LLI. The last LLI updates the link address GPDMA_CxLLR.LA[15:2] to zero and clears all the GPDMA_CxLLR update bits (UT1, UT2, UB1, USA, UDA and ULL). If the channel transfer is continuous/infinite, no event is generated.</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C7BR1</name>
          <displayName>GPDMA_C7BR1</displayName>
          <description>GPDMA channel 7 block register 1</description>
          <addressOffset>0x418</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BNDT</name>
              <description>block number of data bytes to transfer from the source
Block size transferred from the source. When the channel is enabled, this field becomes read-only and is decremented, indicating the remaining number of data items in the current source block to be transferred. BNDT[15:0] is programmed in number of bytes, maximum source block size is 64 Kbytes -1.
Once the last data transfer is completed (BNDT[15:0] = 0):
- if GPDMA_CxLLR.UB1 = 1, this field is updated by the LLI in the memory.
- if GPDMA_CxLLR.UB1 = 0 and if there is at least one non null Uxx update bit, this field is internally restored to the programmed value.
- if all GPDMA_CxLLR.Uxx = 0 and if GPDMA_CxLLR.LA[15:0] = 0, this field is internally restored to the programmed value (infinite/continuous last LLI).
- if GPDMA_CxLLR = 0, this field is kept as zero following the last LLI data transfer.
Note: A non-null source block size must be a multiple of the source data width (BNDT[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.
Note: When configured in packing mode (GPDMA_CxTR1.PAM[1] = 1 and destination data width different from source data width), a non-null source block size must be a multiple of the destination data width (BNDT[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C7SAR</name>
          <displayName>GPDMA_C7SAR</displayName>
          <description>GPDMA channel 7 source address register</description>
          <addressOffset>0x41C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SA</name>
              <description>source address
This field is the pointer to the address from which the next data is read.
During the channel activity, depending on the source addressing mode (GPDMA_CxTR1.SINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.SDW_LOG2[1:0]) after each burst source data, reflecting the next address from which data is read.
During the channel activity, this address is updated after each completed source burst, consequently to:
the programmed source burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.SINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.SBL_1[5:0] and GPDMA_CxTR1.SDW_LOG2[21:0]
the additional source incremented/decremented offset value as programmed by GPDMA_CxBR1.SDEC
In linked-list mode, after a LLI data transfer is completed, this register is automatically updated by GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.USA = 1.
Note: A source address must be aligned with the programmed data width of a source burst (SA[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C7DAR</name>
          <displayName>GPDMA_C7DAR</displayName>
          <description>GPDMA channel 7 destination address register</description>
          <addressOffset>0x420</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DA</name>
              <description>destination address
This field is the pointer to the address from which the next data is written.
During the channel activity, depending on the destination addressing mode (GPDMA_CxTR1.DINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.DDW_LOG2[21:0]) after each burst destination data, reflecting the next address from which data is written.
During the channel activity, this address is updated after each completed destination burst, consequently to:
the programmed destination burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.DINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.DBL_1[5:0] and GPDMA_CxTR1.DDW_LOG2[1:0]
the additional destination incremented/decremented offset value as programmed by GPDMA_CxBR1.DDEC.
In linked-list mode, after a LLI data transfer is completed, this register is automatically updated by the GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.UDA = 1.
Note: A destination address must be aligned with the programmed data width of a destination burst (DA[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPDMA_C7LLR</name>
          <displayName>GPDMA_C7LLR</displayName>
          <description>GPDMA channel 7 linked-list address register</description>
          <addressOffset>0x44C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LA</name>
              <description>pointer (16-bit low-significant address) to the next linked-list data structure
If UT1 = UT2 = UB1 = USA = UDA = ULL = 0 and if LA[15:20] = 0, the current LLI is the last one. The channel transfer is completed without any update of the linked-list GPDMA register file.
Else, this field is the pointer to the memory address offset from which the next linked-list data structure is automatically fetched from, once the data transfer is completed, in order to conditionally update the linked-list GPDMA internal register file (GPDMA_CxCTR1, GPDMA_CxTR2, GPDMA_CxBR1, GPDMA_CxSAR, GPDMA_CxDAR and GPDMA_CxLLR).
Note: The user must program the pointer to be 32-bit aligned. The two low-significant bits are write ignored.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>14</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ULL</name>
              <description>Update GPDMA_CxLLR register from memory
This bit is used to control the update of GPDMA_CxLLR from the memory during the link transfer.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no GPDMA_CxLLR update</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GPDMA_CxLLR update</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UDA</name>
              <description>Update GPDMA_CxDAR register from memory
This bit is used to control the update of GPDMA_CxDAR from the memory during the link transfer.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no GPDMA_CxDAR update</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GPDMA_CxDAR update</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>USA</name>
              <description>update GPDMA_CxSAR from memory
This bit controls the update of GPDMA_CxSAR from the memory during the link transfer.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no GPDMA_CxSAR update</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GPDMA_CxSAR update</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UB1</name>
              <description>Update GPDMA_CxBR1 from memory
This bit controls the update of GPDMA_CxBR1 from the memory during the link transfer. If UB1 = 0 and if GPDMA_CxLLR different 0, the linked-list is not completed. GPDMA_CxBR1.BNDT[15:0] is then restored to the programmed value after data transfer is completed and before the link transfer.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no GPDMA_CxBR1 update from memory (GPDMA_CxBR1.BNDT[15:0] restored if any link transfer)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GPDMA_CxBR1 update</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UT2</name>
              <description>Update GPDMA_CxTR2 from memory
This bit controls the update of GPDMA_CxTR2 from the memory during the link transfer.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no GPDMA_CxTR2 update</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GPDMA_CxTR2 update</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UT1</name>
              <description>Update GPDMA_CxTR1 from memory
This bit controls the update of GPDMA_CxTR1 from the memory during the link transfer.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no GPDMA_CxTR1 update</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GPDMA_CxTR1 update</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GPIOA</name>
      <description>General-purpose I/Os</description>
      <groupName>GPIO</groupName>
      <baseAddress>0x42020000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x400</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>GPIOA_MODER</name>
          <displayName>GPIOA_MODER</displayName>
          <description>GPIO port A mode register</description>
          <addressOffset>0x000</addressOffset>
          <size>0x20</size>
          <resetValue>0xABFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MODE0</name>
              <description>Port configuration I/O pin 0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE1</name>
              <description>Port configuration I/O pin 1</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE2</name>
              <description>Port configuration I/O pin 2</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE3</name>
              <description>Port configuration I/O pin 3</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE5</name>
              <description>Port configuration I/O pin 5</description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE6</name>
              <description>Port configuration I/O pin 6</description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE7</name>
              <description>Port configuration I/O pin 7</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE8</name>
              <description>Port configuration I/O pin 8</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE9</name>
              <description>Port configuration I/O pin 9</description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE10</name>
              <description>Port configuration I/O pin 10</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE11</name>
              <description>Port configuration I/O pin 11</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE12</name>
              <description>Port configuration I/O pin 12</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE13</name>
              <description>Port configuration I/O pin 13</description>
              <bitOffset>26</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE14</name>
              <description>Port configuration I/O pin 14</description>
              <bitOffset>28</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE15</name>
              <description>Port configuration I/O pin 15
These bits are written by software to configure the I/O mode.
Access can be protected by GPIOA SEC15.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Input mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>General purpose output mode</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>Alternate function mode</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>Analog mode (reset state)</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIOA_OTYPER</name>
          <displayName>GPIOA_OTYPER</displayName>
          <description>GPIO port A output type register</description>
          <addressOffset>0x004</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OT0</name>
              <description>Port configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOA SECy.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Output push-pull (reset state)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Output open-drain</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OT1</name>
              <description>Port configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOA SECy.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Output push-pull (reset state)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Output open-drain</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OT2</name>
              <description>Port configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOA SECy.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Output push-pull (reset state)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Output open-drain</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OT3</name>
              <description>Port configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOA SECy.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Output push-pull (reset state)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Output open-drain</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OT5</name>
              <description>Port configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOA SECy.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Output push-pull (reset state)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Output open-drain</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OT6</name>
              <description>Port configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOA SECy.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Output push-pull (reset state)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Output open-drain</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OT7</name>
              <description>Port configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOA SECy.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Output push-pull (reset state)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Output open-drain</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OT8</name>
              <description>Port configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOA SECy.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Output push-pull (reset state)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Output open-drain</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OT9</name>
              <description>Port configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOA SECy.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Output push-pull (reset state)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Output open-drain</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OT10</name>
              <description>Port configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOA SECy.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Output push-pull (reset state)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Output open-drain</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OT11</name>
              <description>Port configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOA SECy.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Output push-pull (reset state)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Output open-drain</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OT12</name>
              <description>Port configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOA SECy.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Output push-pull (reset state)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Output open-drain</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OT13</name>
              <description>Port configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOA SECy.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Output push-pull (reset state)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Output open-drain</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OT14</name>
              <description>Port configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOA SECy.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Output push-pull (reset state)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Output open-drain</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OT15</name>
              <description>Port configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOA SECy.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Output push-pull (reset state)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Output open-drain</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIOA_OSPEEDR</name>
          <displayName>GPIOA_OSPEEDR</displayName>
          <description>GPIO port A output speed register</description>
          <addressOffset>0x008</addressOffset>
          <size>0x20</size>
          <resetValue>0x08000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OSPEED0</name>
              <description>Port configuration I/O pin 0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OSPEED1</name>
              <description>Port configuration I/O pin 1</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OSPEED2</name>
              <description>Port configuration I/O pin 2</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OSPEED3</name>
              <description>Port configuration I/O pin 3</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OSPEED5</name>
              <description>Port configuration I/O pin 5</description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OSPEED6</name>
              <description>Port configuration I/O pin 6</description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OSPEED7</name>
              <description>Port configuration I/O pin 7</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OSPEED8</name>
              <description>Port configuration I/O pin 8</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OSPEED9</name>
              <description>Port configuration I/O pin 9</description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OSPEED10</name>
              <description>Port configuration I/O pin 10</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OSPEED11</name>
              <description>Port configuration I/O pin 11</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OSPEED12</name>
              <description>Port configuration I/O pin 12</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OSPEED13</name>
              <description>Port configuration I/O pin 13</description>
              <bitOffset>26</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OSPEED14</name>
              <description>Port configuration I/O pin 14</description>
              <bitOffset>28</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OSPEED15</name>
              <description>Port configuration I/O pin 15
These bits are written by software to configure the I/O output speed.
Access can be protected by GPIOA SEC15.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Low speed</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Medium speed</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>High speed</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIOA_PUPDR</name>
          <displayName>GPIOA_PUPDR</displayName>
          <description>GPIO port A pull-up/pull-down register</description>
          <addressOffset>0x00C</addressOffset>
          <size>0x20</size>
          <resetValue>0x64000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PUPD0</name>
              <description>Port configuration I/O pin 0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PUPD1</name>
              <description>Port configuration I/O pin 1</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PUPD2</name>
              <description>Port configuration I/O pin 2</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PUPD3</name>
              <description>Port configuration I/O pin 3</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PUPD5</name>
              <description>Port configuration I/O pin 5</description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PUPD6</name>
              <description>Port configuration I/O pin 6</description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PUPD7</name>
              <description>Port configuration I/O pin 7</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PUPD8</name>
              <description>Port configuration I/O pin 8</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PUPD9</name>
              <description>Port configuration I/O pin 9</description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PUPD10</name>
              <description>Port configuration I/O pin 10</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PUPD11</name>
              <description>Port configuration I/O pin 11</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PUPD12</name>
              <description>Port configuration I/O pin 12</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PUPD13</name>
              <description>Port configuration I/O pin 13</description>
              <bitOffset>26</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PUPD14</name>
              <description>Port configuration I/O pin 14</description>
              <bitOffset>28</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PUPD15</name>
              <description>Port configuration I/O pin 15
These bits are written by software to configure the I/O pull-up or pull-down
Access can be protected by GPIOA SEC15.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No pull-up, pull-down</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Pull-up</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>Pull-down</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIOA_IDR</name>
          <displayName>GPIOA_IDR</displayName>
          <description>GPIO port A input data register</description>
          <addressOffset>0x010</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFF0000</resetMask>
          <fields>
            <field>
              <name>ID0</name>
              <description>Port input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOA SECy.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ID1</name>
              <description>Port input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOA SECy.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ID2</name>
              <description>Port input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOA SECy.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ID3</name>
              <description>Port input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOA SECy.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ID5</name>
              <description>Port input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOA SECy.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ID6</name>
              <description>Port input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOA SECy.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ID7</name>
              <description>Port input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOA SECy.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ID8</name>
              <description>Port input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOA SECy.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ID9</name>
              <description>Port input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOA SECy.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ID10</name>
              <description>Port input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOA SECy.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ID11</name>
              <description>Port input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOA SECy.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ID12</name>
              <description>Port input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOA SECy.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ID13</name>
              <description>Port input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOA SECy.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ID14</name>
              <description>Port input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOA SECy.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ID15</name>
              <description>Port input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOA SECy.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIOA_ODR</name>
          <displayName>GPIOA_ODR</displayName>
          <description>GPIO port A output data register</description>
          <addressOffset>0x014</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OD0</name>
              <description>Port output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOA SECy.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOA_BSRR or GPIOA_BRR registers.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OD1</name>
              <description>Port output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOA SECy.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOA_BSRR or GPIOA_BRR registers.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OD2</name>
              <description>Port output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOA SECy.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOA_BSRR or GPIOA_BRR registers.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OD3</name>
              <description>Port output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOA SECy.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOA_BSRR or GPIOA_BRR registers.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OD5</name>
              <description>Port output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOA SECy.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOA_BSRR or GPIOA_BRR registers .</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OD6</name>
              <description>Port output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOA SECy.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOA_BSRR or GPIOA_BRR registers .</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OD7</name>
              <description>Port output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOA SECy.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOA_BSRR or GPIOA_BRR registers .</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OD8</name>
              <description>Port output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOA SECy.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOA_BSRR or GPIOA_BRR registers .</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OD9</name>
              <description>Port output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOA SECy.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOA_BSRR or GPIOA_BRR registers .</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OD10</name>
              <description>Port output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOA SECy.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOA_BSRR or GPIOA_BRR registers .</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OD11</name>
              <description>Port output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOA SECy.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOA_BSRR or GPIOA_BRR registers .</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OD12</name>
              <description>Port output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOA SECy.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOA_BSRR or GPIOA_BRR registers .</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OD13</name>
              <description>Port output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOA SECy.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOA_BSRR or GPIOA_BRR registers .</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OD14</name>
              <description>Port output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOA SECy.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOA_BSRR or GPIOA_BRR registers .</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OD15</name>
              <description>Port output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOA SECy.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOA_BSRR or GPIOA_BRR registers .</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIOA_BSRR</name>
          <displayName>GPIOA_BSRR</displayName>
          <description>GPIO port A bit set/reset register</description>
          <addressOffset>0x018</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BS0</name>
              <description>Port set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Sets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BS1</name>
              <description>Port set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Sets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BS2</name>
              <description>Port set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Sets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BS3</name>
              <description>Port set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Sets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BS5</name>
              <description>Port set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Sets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BS6</name>
              <description>Port set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Sets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BS7</name>
              <description>Port set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Sets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BS8</name>
              <description>Port set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Sets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BS9</name>
              <description>Port set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Sets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BS10</name>
              <description>Port set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Sets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BS11</name>
              <description>Port set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Sets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BS12</name>
              <description>Port set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Sets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BS13</name>
              <description>Port set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Sets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BS14</name>
              <description>Port set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Sets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BS15</name>
              <description>Port set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Sets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BR0</name>
              <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy.
Note: If both BSy and BRy are set, BSy has priority.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Resets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BR1</name>
              <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy.
Note: If both BSy and BRy are set, BSy has priority.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Resets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BR2</name>
              <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy.
Note: If both BSy and BRy are set, BSy has priority.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Resets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BR3</name>
              <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy.
Note: If both BSy and BRy are set, BSy has priority.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Resets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BR5</name>
              <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy.
Note: If both BSy and BRy are set, BSy has priority.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Resets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BR6</name>
              <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy.
Note: If both BSy and BRy are set, BSy has priority.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Resets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BR7</name>
              <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy.
Note: If both BSy and BRy are set, BSy has priority.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Resets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BR8</name>
              <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy.
Note: If both BSy and BRy are set, BSy has priority.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Resets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BR9</name>
              <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy.
Note: If both BSy and BRy are set, BSy has priority.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Resets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BR10</name>
              <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy.
Note: If both BSy and BRy are set, BSy has priority.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Resets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BR11</name>
              <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy.
Note: If both BSy and BRy are set, BSy has priority.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Resets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BR12</name>
              <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy.
Note: If both BSy and BRy are set, BSy has priority.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Resets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BR13</name>
              <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy.
Note: If both BSy and BRy are set, BSy has priority.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Resets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BR14</name>
              <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy.
Note: If both BSy and BRy are set, BSy has priority.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Resets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BR15</name>
              <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy.
Note: If both BSy and BRy are set, BSy has priority.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Resets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIOA_LCKR</name>
          <displayName>GPIOA_LCKR</displayName>
          <description>GPIO port A configuration lock register</description>
          <addressOffset>0x01C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LCK0</name>
              <description>Port lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0
Access can be protected by GPIOA SECy.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Port configuration not locked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Port configuration locked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LCK1</name>
              <description>Port lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0
Access can be protected by GPIOA SECy.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Port configuration not locked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Port configuration locked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LCK2</name>
              <description>Port lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0
Access can be protected by GPIOA SECy.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Port configuration not locked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Port configuration locked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LCK3</name>
              <description>Port lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0
Access can be protected by GPIOA SECy.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Port configuration not locked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Port configuration locked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LCK5</name>
              <description>Port lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0
Access can be protected by GPIOA SECy.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Port configuration not locked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Port configuration locked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LCK6</name>
              <description>Port lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0
Access can be protected by GPIOA SECy.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Port configuration not locked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Port configuration locked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LCK7</name>
              <description>Port lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0
Access can be protected by GPIOA SECy.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Port configuration not locked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Port configuration locked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LCK8</name>
              <description>Port lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0
Access can be protected by GPIOA SECy.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Port configuration not locked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Port configuration locked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LCK9</name>
              <description>Port lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0
Access can be protected by GPIOA SECy.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Port configuration not locked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Port configuration locked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LCK10</name>
              <description>Port lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0
Access can be protected by GPIOA SECy.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Port configuration not locked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Port configuration locked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LCK11</name>
              <description>Port lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0
Access can be protected by GPIOA SECy.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Port configuration not locked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Port configuration locked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LCK12</name>
              <description>Port lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0
Access can be protected by GPIOA SECy.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Port configuration not locked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Port configuration locked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LCK13</name>
              <description>Port lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0
Access can be protected by GPIOA SECy.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Port configuration not locked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Port configuration locked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LCK14</name>
              <description>Port lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0
Access can be protected by GPIOA SECy.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Port configuration not locked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Port configuration locked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LCK15</name>
              <description>Port lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0
Access can be protected by GPIOA SECy.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Port configuration not locked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Port configuration locked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LCKK</name>
              <description>Lock key
This bit can be read any time. It can only be modified using the lock key write sequence.
Access can be protected by any GPIOA SECy.
- LOCK key write sequence:
WR LCKR[16] = 1 + LCKR[15:0]
WR LCKR[16] = 0 + LCKR[15:0]
WR LCKR[16] = 1 + LCKR[15:0]
- LOCK key read
RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active)
Note: During the LOCK key write sequence, the value of LCKR[15:0] must not change.
Note: Any error in the lock sequence aborts the LOCK.
Note: After the first LOCK sequence on any bit of the port, any read access on the LCKK bit returns 1 until the next MCU reset or peripheral reset.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Port configuration lock key not active</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Port configuration lock key active. The GPIOx_LCKR register is locked until the next MCU reset or peripheral reset.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIOA_AFRL</name>
          <displayName>GPIOA_AFRL</displayName>
          <description>GPIO port A alternate function low register</description>
          <addressOffset>0x020</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AFSEL0</name>
              <description>Alternate function selection for port I/O pin 0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AFSEL1</name>
              <description>Alternate function selection for port I/O pin 1</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AFSEL2</name>
              <description>Alternate function selection for port I/O pin 2</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AFSEL3</name>
              <description>Alternate function selection for port I/O pin 3</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AFSEL5</name>
              <description>Alternate function selection for port I/O pin 5</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AFSEL6</name>
              <description>Alternate function selection for port I/O pin 6</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AFSEL7</name>
              <description>Alternate function selection for port I/O pin 7
These bits are written by software to configure alternate function I/Os.
Access can be protected by GPIOA SECy.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>AF0</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>AF1</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>AF2</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>AF3</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>AF4</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>AF5</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x6</name>
                  <description>AF6</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7</name>
                  <description>AF7</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x8</name>
                  <description>AF8</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x9</name>
                  <description>AF9</description>
                  <value>0x9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xA</name>
                  <description>AF10</description>
                  <value>0xA</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xB</name>
                  <description>AF11</description>
                  <value>0xB</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xC</name>
                  <description>AF12</description>
                  <value>0xC</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xD</name>
                  <description>AF13</description>
                  <value>0xD</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xE</name>
                  <description>AF14</description>
                  <value>0xE</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xF</name>
                  <description>AF15</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIOA_AFRH</name>
          <displayName>GPIOA_AFRH</displayName>
          <description>GPIO port A alternate function high register</description>
          <addressOffset>0x024</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AFSEL8</name>
              <description>Alternate function selection for port I/O pin 8</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AFSEL9</name>
              <description>Alternate function selection for port I/O pin 9</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AFSEL10</name>
              <description>Alternate function selection for port I/O pin 10</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AFSEL11</name>
              <description>Alternate function selection for port I/O pin 11</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AFSEL12</name>
              <description>Alternate function selection for port I/O pin 12</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AFSEL13</name>
              <description>Alternate function selection for port I/O pin 13</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AFSEL14</name>
              <description>Alternate function selection for port I/O pin 14</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AFSEL15</name>
              <description>Alternate function selection for port I/O pin 15
These bits are written by software to configure alternate function I/Os.
Access can be protected by GPIOA SEC15.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>AF0</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>AF1</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>AF2</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>AF3</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>AF4</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>AF5</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x6</name>
                  <description>AF6</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7</name>
                  <description>AF7</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x8</name>
                  <description>AF8</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x9</name>
                  <description>AF9</description>
                  <value>0x9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xA</name>
                  <description>AF10</description>
                  <value>0xA</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xB</name>
                  <description>AF11</description>
                  <value>0xB</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xC</name>
                  <description>AF12</description>
                  <value>0xC</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xD</name>
                  <description>AF13</description>
                  <value>0xD</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xE</name>
                  <description>AF14</description>
                  <value>0xE</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xF</name>
                  <description>AF15</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIOA_BRR</name>
          <displayName>GPIOA_BRR</displayName>
          <description>GPIO port A bit reset register</description>
          <addressOffset>0x028</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BR0</name>
              <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BR1</name>
              <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BR2</name>
              <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BR3</name>
              <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BR5</name>
              <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BR6</name>
              <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BR7</name>
              <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BR8</name>
              <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BR9</name>
              <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BR10</name>
              <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BR11</name>
              <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BR12</name>
              <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BR13</name>
              <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BR14</name>
              <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BR15</name>
              <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIOA_SECCFGR</name>
          <displayName>GPIOA_SECCFGR</displayName>
          <description>GPIO port A secure configuration register</description>
          <addressOffset>0x030</addressOffset>
          <size>0x20</size>
          <resetValue>0x0000FFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SEC0</name>
              <description>I/O pin of port secure bit enable y
These bits are written by software to enabled the security I/O port pin.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>The I/O pin is non-secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEC1</name>
              <description>I/O pin of port secure bit enable y
These bits are written by software to enabled the security I/O port pin.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>The I/O pin is non-secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEC2</name>
              <description>I/O pin of port secure bit enable y
These bits are written by software to enabled the security I/O port pin.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>The I/O pin is non-secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEC3</name>
              <description>I/O pin of port secure bit enable y
These bits are written by software to enabled the security I/O port pin.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>The I/O pin is non-secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEC5</name>
              <description>I/O pin of port secure bit enable y
These bits are written by software to enabled the security I/O port pin.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>The I/O pin is non-secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEC6</name>
              <description>I/O pin of port secure bit enable y
These bits are written by software to enabled the security I/O port pin.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>The I/O pin is non-secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEC7</name>
              <description>I/O pin of port secure bit enable y
These bits are written by software to enabled the security I/O port pin.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>The I/O pin is non-secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEC8</name>
              <description>I/O pin of port secure bit enable y
These bits are written by software to enabled the security I/O port pin.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>The I/O pin is non-secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEC9</name>
              <description>I/O pin of port secure bit enable y
These bits are written by software to enabled the security I/O port pin.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>The I/O pin is non-secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEC10</name>
              <description>I/O pin of port secure bit enable y
These bits are written by software to enabled the security I/O port pin.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>The I/O pin is non-secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEC11</name>
              <description>I/O pin of port secure bit enable y
These bits are written by software to enabled the security I/O port pin.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>The I/O pin is non-secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEC12</name>
              <description>I/O pin of port secure bit enable y
These bits are written by software to enabled the security I/O port pin.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>The I/O pin is non-secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEC13</name>
              <description>I/O pin of port secure bit enable y
These bits are written by software to enabled the security I/O port pin.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>The I/O pin is non-secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEC14</name>
              <description>I/O pin of port secure bit enable y
These bits are written by software to enabled the security I/O port pin.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>The I/O pin is non-secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEC15</name>
              <description>I/O pin of port secure bit enable y
These bits are written by software to enabled the security I/O port pin.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>The I/O pin is non-secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GPIOB</name>
      <description>General-purpose I/Os</description>
      <groupName>GPIO</groupName>
      <baseAddress>0x42020400</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x400</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>GPIOB_MODER</name>
          <displayName>GPIOB_MODER</displayName>
          <description>GPIO port B mode register</description>
          <addressOffset>0x000</addressOffset>
          <size>0x20</size>
          <resetValue>0xFFFFFEBF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MODE0</name>
              <description>Port configuration I/O pin 0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE1</name>
              <description>Port configuration I/O pin 1</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE2</name>
              <description>Port configuration I/O pin 2</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE3</name>
              <description>Port configuration I/O pin 3</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE4</name>
              <description>Port configuration I/O pin 4</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE5</name>
              <description>Port configuration I/O pin 5</description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE6</name>
              <description>Port configuration I/O pin 6</description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE7</name>
              <description>Port configuration I/O pin 7</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE8</name>
              <description>Port configuration I/O pin 8</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE9</name>
              <description>Port configuration I/O pin 9</description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE10</name>
              <description>Port configuration I/O pin 10
Note that bits 21:20 are reserved on STM32WBA55xx devices.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE11</name>
              <description>Port configuration I/O pin 11</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE12</name>
              <description>Port configuration I/O pin 12</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE13</name>
              <description>Port configuration I/O pin 13</description>
              <bitOffset>26</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE14</name>
              <description>Port configuration I/O pin 14</description>
              <bitOffset>28</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE15</name>
              <description>Port configuration I/O pin 15
These bits are written by software to configure the I/O mode.
Access can be protected by GPIOB SEC15.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Input mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>General purpose output mode</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>Alternate function mode</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>Analog mode (reset state)</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIOB_OTYPER</name>
          <displayName>GPIOB_OTYPER</displayName>
          <description>GPIO port B output type register</description>
          <addressOffset>0x004</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OT0</name>
              <description>Port configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Output push-pull (reset state)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Output open-drain</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OT1</name>
              <description>Port configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Output push-pull (reset state)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Output open-drain</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OT2</name>
              <description>Port configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Output push-pull (reset state)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Output open-drain</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OT3</name>
              <description>Port configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Output push-pull (reset state)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Output open-drain</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OT4</name>
              <description>Port configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Output push-pull (reset state)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Output open-drain</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OT5</name>
              <description>Port configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Output push-pull (reset state)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Output open-drain</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OT6</name>
              <description>Port configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Output push-pull (reset state)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Output open-drain</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OT7</name>
              <description>Port configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Output push-pull (reset state)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Output open-drain</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OT8</name>
              <description>Port configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Output push-pull (reset state)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Output open-drain</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OT9</name>
              <description>Port configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Output push-pull (reset state)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Output open-drain</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OT10</name>
              <description>Port configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Output push-pull (reset state)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Output open-drain</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OT11</name>
              <description>Port configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Output push-pull (reset state)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Output open-drain</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OT12</name>
              <description>Port configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Output push-pull (reset state)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Output open-drain</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OT13</name>
              <description>Port configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Output push-pull (reset state)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Output open-drain</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OT14</name>
              <description>Port configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Output push-pull (reset state)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Output open-drain</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OT15</name>
              <description>Port configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Output push-pull (reset state)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Output open-drain</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIOB_OSPEEDR</name>
          <displayName>GPIOB_OSPEEDR</displayName>
          <description>GPIO port B output speed register</description>
          <addressOffset>0x008</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000080</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OSPEED0</name>
              <description>Port configuration I/O pin 0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OSPEED1</name>
              <description>Port configuration I/O pin 1</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OSPEED2</name>
              <description>Port configuration I/O pin 2</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OSPEED3</name>
              <description>Port configuration I/O pin 3</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OSPEED4</name>
              <description>Port configuration I/O pin 4</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OSPEED5</name>
              <description>Port configuration I/O pin 5</description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OSPEED6</name>
              <description>Port configuration I/O pin 6</description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OSPEED7</name>
              <description>Port configuration I/O pin 7</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OSPEED8</name>
              <description>Port configuration I/O pin 8</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OSPEED9</name>
              <description>Port configuration I/O pin 9</description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OSPEED10</name>
              <description>Port configuration I/O pin 10
Note that bits 21:20 are reserved on STM32WBA55xx devices.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OSPEED11</name>
              <description>Port configuration I/O pin 11</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OSPEED12</name>
              <description>Port configuration I/O pin 12</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OSPEED13</name>
              <description>Port configuration I/O pin 13</description>
              <bitOffset>26</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OSPEED14</name>
              <description>Port configuration I/O pin 14</description>
              <bitOffset>28</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OSPEED15</name>
              <description>Port configuration I/O pin 15
These bits are written by software to configure the I/O output speed.
Access can be protected by GPIOB SEC15.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Low speed</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Medium speed</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>High speed</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIOB_PUPDR</name>
          <displayName>GPIOB_PUPDR</displayName>
          <description>GPIO port B pull-up/pull-down register</description>
          <addressOffset>0x00C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000100</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PUPD0</name>
              <description>Port configuration I/O pin 0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PUPD1</name>
              <description>Port configuration I/O pin 1</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PUPD2</name>
              <description>Port configuration I/O pin 2</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PUPD3</name>
              <description>Port configuration I/O pin 3</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PUPD4</name>
              <description>Port configuration I/O pin 4</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PUPD5</name>
              <description>Port configuration I/O pin 5</description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PUPD6</name>
              <description>Port configuration I/O pin 6</description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PUPD7</name>
              <description>Port configuration I/O pin 7</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PUPD8</name>
              <description>Port configuration I/O pin 8</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PUPD9</name>
              <description>Port configuration I/O pin 9</description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PUPD10</name>
              <description>Port configuration I/O pin 10
Note that bits 21:20 are reserved on STM32WBA55xx devices.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PUPD11</name>
              <description>Port configuration I/O pin 11</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PUPD12</name>
              <description>Port configuration I/O pin 12</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PUPD13</name>
              <description>Port configuration I/O pin 13</description>
              <bitOffset>26</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PUPD14</name>
              <description>Port configuration I/O pin 14</description>
              <bitOffset>28</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PUPD15</name>
              <description>Port configuration I/O pin 15
These bits are written by software to configure the I/O pull-up or pull-down
Access can be protected by GPIOB SEC15.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No pull-up, pull-down</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Pull-up</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>Pull-down</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIOB_IDR</name>
          <displayName>GPIOB_IDR</displayName>
          <description>GPIO port B input data register</description>
          <addressOffset>0x010</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFF0000</resetMask>
          <fields>
            <field>
              <name>ID0</name>
              <description>Port input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ID1</name>
              <description>Port input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ID2</name>
              <description>Port input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ID3</name>
              <description>Port input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ID4</name>
              <description>Port input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ID5</name>
              <description>Port input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ID6</name>
              <description>Port input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ID7</name>
              <description>Port input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ID8</name>
              <description>Port input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ID9</name>
              <description>Port input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ID10</name>
              <description>Port input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ID11</name>
              <description>Port input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ID12</name>
              <description>Port input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ID13</name>
              <description>Port input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ID14</name>
              <description>Port input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ID15</name>
              <description>Port input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIOB_ODR</name>
          <displayName>GPIOB_ODR</displayName>
          <description>GPIO port B output data register</description>
          <addressOffset>0x014</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OD0</name>
              <description>Port output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOB_BSRR or GPIOB_BRR registers.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OD1</name>
              <description>Port output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOB_BSRR or GPIOB_BRR registers.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OD2</name>
              <description>Port output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOB_BSRR or GPIOB_BRR registers.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OD3</name>
              <description>Port output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOB_BSRR or GPIOB_BRR registers.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OD4</name>
              <description>Port output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOB_BSRR or GPIOB_BRR registers.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OD5</name>
              <description>Port output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOB_BSRR or GPIOB_BRR registers.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OD6</name>
              <description>Port output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOB_BSRR or GPIOB_BRR registers.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OD7</name>
              <description>Port output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOB_BSRR or GPIOB_BRR registers.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OD8</name>
              <description>Port output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOB_BSRR or GPIOB_BRR registers.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OD9</name>
              <description>Port output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOB_BSRR or GPIOB_BRR registers.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OD10</name>
              <description>Port output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOB_BSRR or GPIOB_BRR registers.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OD11</name>
              <description>Port output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOB_BSRR or GPIOB_BRR registers.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OD12</name>
              <description>Port output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOB_BSRR or GPIOB_BRR registers.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OD13</name>
              <description>Port output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOB_BSRR or GPIOB_BRR registers.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OD14</name>
              <description>Port output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOB_BSRR or GPIOB_BRR registers.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OD15</name>
              <description>Port output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOB_BSRR or GPIOB_BRR registers.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIOB_BSRR</name>
          <displayName>GPIOB_BSRR</displayName>
          <description>GPIO port B bit set/reset register</description>
          <addressOffset>0x018</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BS0</name>
              <description>Port set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Sets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BS1</name>
              <description>Port set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Sets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BS2</name>
              <description>Port set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Sets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BS3</name>
              <description>Port set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Sets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BS4</name>
              <description>Port set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Sets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BS5</name>
              <description>Port set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Sets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BS6</name>
              <description>Port set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Sets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BS7</name>
              <description>Port set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Sets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BS8</name>
              <description>Port set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Sets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BS9</name>
              <description>Port set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Sets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BS10</name>
              <description>Port set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Sets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BS11</name>
              <description>Port set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Sets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BS12</name>
              <description>Port set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Sets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BS13</name>
              <description>Port set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Sets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BS14</name>
              <description>Port set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Sets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BS15</name>
              <description>Port set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Sets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BR0</name>
              <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 26 is reserved on STM32WBA55xx devices.
Note: If both BSy and BRy are set, BSy has priority.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Resets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BR1</name>
              <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 26 is reserved on STM32WBA55xx devices.
Note: If both BSy and BRy are set, BSy has priority.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Resets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BR2</name>
              <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 26 is reserved on STM32WBA55xx devices.
Note: If both BSy and BRy are set, BSy has priority.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Resets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BR3</name>
              <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 26 is reserved on STM32WBA55xx devices.
Note: If both BSy and BRy are set, BSy has priority.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Resets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BR4</name>
              <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 26 is reserved on STM32WBA55xx devices.
Note: If both BSy and BRy are set, BSy has priority.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Resets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BR5</name>
              <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 26 is reserved on STM32WBA55xx devices.
Note: If both BSy and BRy are set, BSy has priority.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Resets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BR6</name>
              <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 26 is reserved on STM32WBA55xx devices.
Note: If both BSy and BRy are set, BSy has priority.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Resets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BR7</name>
              <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 26 is reserved on STM32WBA55xx devices.
Note: If both BSy and BRy are set, BSy has priority.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Resets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BR8</name>
              <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 26 is reserved on STM32WBA55xx devices.
Note: If both BSy and BRy are set, BSy has priority.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Resets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BR9</name>
              <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 26 is reserved on STM32WBA55xx devices.
Note: If both BSy and BRy are set, BSy has priority.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Resets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BR10</name>
              <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 26 is reserved on STM32WBA55xx devices.
Note: If both BSy and BRy are set, BSy has priority.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Resets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BR11</name>
              <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 26 is reserved on STM32WBA55xx devices.
Note: If both BSy and BRy are set, BSy has priority.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Resets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BR12</name>
              <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 26 is reserved on STM32WBA55xx devices.
Note: If both BSy and BRy are set, BSy has priority.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Resets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BR13</name>
              <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 26 is reserved on STM32WBA55xx devices.
Note: If both BSy and BRy are set, BSy has priority.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Resets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BR14</name>
              <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 26 is reserved on STM32WBA55xx devices.
Note: If both BSy and BRy are set, BSy has priority.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Resets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BR15</name>
              <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 26 is reserved on STM32WBA55xx devices.
Note: If both BSy and BRy are set, BSy has priority.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Resets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIOB_LCKR</name>
          <displayName>GPIOB_LCKR</displayName>
          <description>GPIO port B configuration lock register</description>
          <addressOffset>0x01C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LCK0</name>
              <description>Port lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Port configuration not locked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Port configuration locked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LCK1</name>
              <description>Port lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Port configuration not locked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Port configuration locked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LCK2</name>
              <description>Port lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Port configuration not locked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Port configuration locked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LCK3</name>
              <description>Port lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Port configuration not locked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Port configuration locked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LCK4</name>
              <description>Port lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Port configuration not locked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Port configuration locked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LCK5</name>
              <description>Port lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Port configuration not locked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Port configuration locked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LCK6</name>
              <description>Port lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Port configuration not locked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Port configuration locked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LCK7</name>
              <description>Port lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Port configuration not locked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Port configuration locked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LCK8</name>
              <description>Port lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Port configuration not locked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Port configuration locked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LCK9</name>
              <description>Port lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Port configuration not locked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Port configuration locked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LCK10</name>
              <description>Port lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Port configuration not locked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Port configuration locked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LCK11</name>
              <description>Port lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Port configuration not locked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Port configuration locked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LCK12</name>
              <description>Port lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Port configuration not locked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Port configuration locked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LCK13</name>
              <description>Port lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Port configuration not locked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Port configuration locked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LCK14</name>
              <description>Port lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Port configuration not locked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Port configuration locked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LCK15</name>
              <description>Port lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Port configuration not locked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Port configuration locked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LCKK</name>
              <description>Lock key
This bit can be read any time. It can only be modified using the lock key write sequence.
Access can be protected by any GPIOB SECy.
- LOCK key write sequence:
WR LCKR[16] = 1 + LCKR[15:0]
WR LCKR[16] = 0 + LCKR[15:0]
WR LCKR[16] = 1 + LCKR[15:0]
- LOCK key read
RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active)
Note: During the LOCK key write sequence, the value of LCKR[15:0] must not change.
Note: Any error in the lock sequence aborts the LOCK.
Note: After the first LOCK sequence on any bit of the port, any read access on the LCKK bit returns 1 until the next MCU reset or peripheral reset.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Port configuration lock key not active</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Port configuration lock key active. The GPIOx_LCKR register is locked until the next MCU reset or peripheral reset.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIOB_AFRL</name>
          <displayName>GPIOB_AFRL</displayName>
          <description>GPIO port B alternate function low register</description>
          <addressOffset>0x020</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AFSEL0</name>
              <description>Alternate function selection for port I/O pin 0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AFSEL1</name>
              <description>Alternate function selection for port I/O pin 1</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AFSEL2</name>
              <description>Alternate function selection for port I/O pin 2</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AFSEL3</name>
              <description>Alternate function selection for port I/O pin 3</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AFSEL4</name>
              <description>Alternate function selection for port I/O pin 4</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AFSEL5</name>
              <description>Alternate function selection for port I/O pin 5</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AFSEL6</name>
              <description>Alternate function selection for port I/O pin 6</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AFSEL7</name>
              <description>Alternate function selection for port I/O pin 7
These bits are written by software to configure alternate function I/Os.
Access can be protected by GPIOB SEC7.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>AF0</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>AF1</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>AF2</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>AF3</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>AF4</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>AF5</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x6</name>
                  <description>AF6</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7</name>
                  <description>AF7</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x8</name>
                  <description>AF8</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x9</name>
                  <description>AF9</description>
                  <value>0x9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xA</name>
                  <description>AF10</description>
                  <value>0xA</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xB</name>
                  <description>AF11</description>
                  <value>0xB</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xC</name>
                  <description>AF12</description>
                  <value>0xC</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xD</name>
                  <description>AF13</description>
                  <value>0xD</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xE</name>
                  <description>AF14</description>
                  <value>0xE</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xF</name>
                  <description>AF15</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIOB_AFRH</name>
          <displayName>GPIOB_AFRH</displayName>
          <description>GPIO port B alternate function high register</description>
          <addressOffset>0x024</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AFSEL8</name>
              <description>Alternate function selection for port I/O pin 8</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AFSEL9</name>
              <description>Alternate function selection for port I/O pin 9</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AFSEL10</name>
              <description>Alternate function selection for port I/O pin 10
Note that bit 11:8 are reserved on STM32WBA55xx devices.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AFSEL11</name>
              <description>Alternate function selection for port I/O pin 11</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AFSEL12</name>
              <description>Alternate function selection for port I/O pin 12</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AFSEL13</name>
              <description>Alternate function selection for port I/O pin 13</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AFSEL14</name>
              <description>Alternate function selection for port I/O pin 14</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AFSEL15</name>
              <description>Alternate function selection for port I/O pin 15
These bits are written by software to configure alternate function I/Os.
Access can be protected by GPIOB SEC15.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>AF0</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>AF1</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>AF2</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>AF3</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>AF4</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>AF5</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x6</name>
                  <description>AF6</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7</name>
                  <description>AF7</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x8</name>
                  <description>AF8</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x9</name>
                  <description>AF9</description>
                  <value>0x9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xA</name>
                  <description>AF10</description>
                  <value>0xA</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xB</name>
                  <description>AF11</description>
                  <value>0xB</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xC</name>
                  <description>AF12</description>
                  <value>0xC</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xD</name>
                  <description>AF13</description>
                  <value>0xD</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xE</name>
                  <description>AF14</description>
                  <value>0xE</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xF</name>
                  <description>AF15</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIOB_BRR</name>
          <displayName>GPIOB_BRR</displayName>
          <description>GPIO port B bit reset register</description>
          <addressOffset>0x028</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BR0</name>
              <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BR1</name>
              <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BR2</name>
              <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BR3</name>
              <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BR4</name>
              <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BR5</name>
              <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BR6</name>
              <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BR7</name>
              <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BR8</name>
              <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BR9</name>
              <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BR10</name>
              <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BR11</name>
              <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BR12</name>
              <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BR13</name>
              <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BR14</name>
              <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BR15</name>
              <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIOB_SECCFGR</name>
          <displayName>GPIOB_SECCFGR</displayName>
          <description>GPIO port B secure configuration register</description>
          <addressOffset>0x030</addressOffset>
          <size>0x20</size>
          <resetValue>0x0000FFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SEC0</name>
              <description>I/O pin of port secure bit enable y
These bits are written by software to enabled the security I/O port pin. 
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>The I/O pin is non-secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEC1</name>
              <description>I/O pin of port secure bit enable y
These bits are written by software to enabled the security I/O port pin. 
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>The I/O pin is non-secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEC2</name>
              <description>I/O pin of port secure bit enable y
These bits are written by software to enabled the security I/O port pin. 
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>The I/O pin is non-secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEC3</name>
              <description>I/O pin of port secure bit enable y
These bits are written by software to enabled the security I/O port pin. 
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>The I/O pin is non-secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEC4</name>
              <description>I/O pin of port secure bit enable y
These bits are written by software to enabled the security I/O port pin. 
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>The I/O pin is non-secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEC5</name>
              <description>I/O pin of port secure bit enable y
These bits are written by software to enabled the security I/O port pin. 
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>The I/O pin is non-secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEC6</name>
              <description>I/O pin of port secure bit enable y
These bits are written by software to enabled the security I/O port pin. 
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>The I/O pin is non-secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEC7</name>
              <description>I/O pin of port secure bit enable y
These bits are written by software to enabled the security I/O port pin. 
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>The I/O pin is non-secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEC8</name>
              <description>I/O pin of port secure bit enable y
These bits are written by software to enabled the security I/O port pin. 
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>The I/O pin is non-secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEC9</name>
              <description>I/O pin of port secure bit enable y
These bits are written by software to enabled the security I/O port pin. 
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>The I/O pin is non-secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEC10</name>
              <description>I/O pin of port secure bit enable y
These bits are written by software to enabled the security I/O port pin. 
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>The I/O pin is non-secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEC11</name>
              <description>I/O pin of port secure bit enable y
These bits are written by software to enabled the security I/O port pin. 
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>The I/O pin is non-secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEC12</name>
              <description>I/O pin of port secure bit enable y
These bits are written by software to enabled the security I/O port pin. 
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>The I/O pin is non-secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEC13</name>
              <description>I/O pin of port secure bit enable y
These bits are written by software to enabled the security I/O port pin. 
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>The I/O pin is non-secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEC14</name>
              <description>I/O pin of port secure bit enable y
These bits are written by software to enabled the security I/O port pin. 
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>The I/O pin is non-secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEC15</name>
              <description>I/O pin of port secure bit enable y
These bits are written by software to enabled the security I/O port pin. 
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>The I/O pin is non-secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GPIOC</name>
      <description>General-purpose I/Os</description>
      <groupName>GPIO</groupName>
      <baseAddress>0x42020800</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x400</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>GPIOC_MODER</name>
          <displayName>GPIOC_MODER</displayName>
          <description>GPIO port C mode register</description>
          <addressOffset>0x000</addressOffset>
          <size>0x20</size>
          <resetValue>0xFC000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MODE13</name>
              <description>Port C configuration I/O pin 13</description>
              <bitOffset>26</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE14</name>
              <description>Port C configuration I/O pin 14</description>
              <bitOffset>28</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE15</name>
              <description>Port C configuration I/O pin 15
These bits are written by software to configure the I/O mode.
Access can be protected by GPIOC SEC15.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Input mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>General purpose output mode</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>Alternate function mode</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>Analog mode (reset state)</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIOC_OTYPER</name>
          <displayName>GPIOC_OTYPER</displayName>
          <description>GPIO port C output type register</description>
          <addressOffset>0x004</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OT13</name>
              <description>Port C configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOC SECy.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Output push-pull (reset state)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Output open-drain</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OT14</name>
              <description>Port C configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOC SECy.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Output push-pull (reset state)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Output open-drain</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OT15</name>
              <description>Port C configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOC SECy.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Output push-pull (reset state)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Output open-drain</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIOC_OSPEEDR</name>
          <displayName>GPIOC_OSPEEDR</displayName>
          <description>GPIOC port output speed register</description>
          <addressOffset>0x008</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OSPEED13</name>
              <description>Port C configuration I/O pin 13</description>
              <bitOffset>26</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OSPEED14</name>
              <description>Port C configuration I/O pin 14</description>
              <bitOffset>28</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OSPEED15</name>
              <description>Port C configuration I/O pin 15
These bits are written by software to configure the I/O output speed.
Access can be protected by GPIOC SEC15.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Low speed</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Medium speed</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>High speed</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIOC_PUPDR</name>
          <displayName>GPIOC_PUPDR</displayName>
          <description>GPIO port C pull-up/pull-down register</description>
          <addressOffset>0x00C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PUPD13</name>
              <description>Port C configuration I/O pin 13</description>
              <bitOffset>26</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PUPD14</name>
              <description>Port C configuration I/O pin 14</description>
              <bitOffset>28</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PUPD15</name>
              <description>Port C configuration I/O pin 15
These bits are written by software to configure the I/O pull-up or pull-down
Access can be protected by GPIOC SEC15.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No pull-up, pull-down</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Pull-up</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>Pull-down</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIOC_IDR</name>
          <displayName>GPIOC_IDR</displayName>
          <description>GPIO port C input data register</description>
          <addressOffset>0x010</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFF0FFF</resetMask>
          <fields>
            <field>
              <name>ID13</name>
              <description>Port C input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOC SECy.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ID14</name>
              <description>Port C input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOC SECy.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ID15</name>
              <description>Port C input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOC SECy.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIOC_ODR</name>
          <displayName>GPIOC_ODR</displayName>
          <description>GPIO port C output data register</description>
          <addressOffset>0x014</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OD13</name>
              <description>Port C output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOC SECy.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOC_BSRR or GPIOC_BRR registers.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OD14</name>
              <description>Port C output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOC SECy.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOC_BSRR or GPIOC_BRR registers.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OD15</name>
              <description>Port C output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOC SECy.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOC_BSRR or GPIOC_BRR registers.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIOC_BSRR</name>
          <displayName>GPIOC_BSRR</displayName>
          <description>GPIO port C bit set/reset register</description>
          <addressOffset>0x018</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BS13</name>
              <description>Port C set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOC SECy.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Sets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BS14</name>
              <description>Port C set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOC SECy.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Sets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BS15</name>
              <description>Port C set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOC SECy.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Sets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BR13</name>
              <description>Port C reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOC SECy.
Note: If both BSy and BRy are set, BSy has priority.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Resets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BR14</name>
              <description>Port C reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOC SECy.
Note: If both BSy and BRy are set, BSy has priority.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Resets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BR15</name>
              <description>Port C reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOC SECy.
Note: If both BSy and BRy are set, BSy has priority.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Resets the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIOC_LCKR</name>
          <displayName>GPIOC_LCKR</displayName>
          <description>GPIO port C configuration lock register</description>
          <addressOffset>0x01C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LCK13</name>
              <description>Port C lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0
Access can be protected by GPIOC SECy.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Port configuration not locked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Port configuration locked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LCK14</name>
              <description>Port C lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0
Access can be protected by GPIOC SECy.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Port configuration not locked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Port configuration locked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LCK15</name>
              <description>Port C lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0
Access can be protected by GPIOC SECy.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Port configuration not locked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Port configuration locked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LCKK</name>
              <description>Lock key
This bit can be read any time. It can only be modified using the lock key write sequence.
Access is protected by any GPIOC SECy.
- LOCK key write sequence:
WR LCKR[16] = 1 + LCKR[15:13]
WR LCKR[16] = 0 + LCKR[15:13]
WR LCKR[16] = 1 + LCKR[15:13]
- LOCK key read
RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active)
Note: During the LOCK key write sequence, the value of LCK[15:13] must not change.
Note: Any error in the lock sequence aborts the LOCK.
Note: After the first LOCK sequence on any bit of the port, any read access on the LCKK bit returns 1 until the next MCU reset or peripheral reset.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Port configuration lock key not active</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Port configuration lock key active. The GPIOC_LCKR register is locked until the next MCU reset or peripheral reset.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIOC_AFRH</name>
          <displayName>GPIOC_AFRH</displayName>
          <description>GPIO port C alternate function high register</description>
          <addressOffset>0x024</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AFSEL13</name>
              <description>Alternate function selection for port C I/O pin 13</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AFSEL14</name>
              <description>Alternate function selection for port C I/O pin 14</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AFSEL15</name>
              <description>Alternate function selection for port C I/O pin 15
These bits are written by software to configure alternate function I/Os.
Access can be protected by GPIOC SEC15.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>AF0</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>AF1</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>AF2</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>AF3</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>AF4</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>AF5</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x6</name>
                  <description>AF6</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7</name>
                  <description>AF7</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x8</name>
                  <description>AF8</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x9</name>
                  <description>AF9</description>
                  <value>0x9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xA</name>
                  <description>AF10</description>
                  <value>0xA</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xB</name>
                  <description>AF11</description>
                  <value>0xB</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xC</name>
                  <description>AF12</description>
                  <value>0xC</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xD</name>
                  <description>AF13</description>
                  <value>0xD</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xE</name>
                  <description>AF14</description>
                  <value>0xE</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xF</name>
                  <description>AF15</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIOC_BRR</name>
          <displayName>GPIOC_BRR</displayName>
          <description>GPIO port C bit reset register</description>
          <addressOffset>0x028</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BR13</name>
              <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOC SECy.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BR14</name>
              <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOC SECy.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BR15</name>
              <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOC SECy.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding ODy bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset the corresponding ODy bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIOC_SECCFGR</name>
          <displayName>GPIOC_SECCFGR</displayName>
          <description>GPIO port C secure configuration register</description>
          <addressOffset>0x030</addressOffset>
          <size>0x20</size>
          <resetValue>0x0000FFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SEC13</name>
              <description>I/O pin of port C secure bit enable y
These bits are written by software to enabled the security I/O port pin.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>The I/O pin is non-secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEC14</name>
              <description>I/O pin of port C secure bit enable y
These bits are written by software to enabled the security I/O port pin.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>The I/O pin is non-secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEC15</name>
              <description>I/O pin of port C secure bit enable y
These bits are written by software to enabled the security I/O port pin.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>The I/O pin is non-secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GPIOH</name>
      <description>General-purpose I/Os</description>
      <groupName>GPIO</groupName>
      <baseAddress>0x42021C00</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x400</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>GPIOH_MODER</name>
          <displayName>GPIOH_MODER</displayName>
          <description>GPIO port H mode register</description>
          <addressOffset>0x000</addressOffset>
          <size>0x20</size>
          <resetValue>0x0000C000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MODE3</name>
              <description>Port H configuration I/O pin 3
These bits are written by software to configure the I/O mode.
Access can be protected by GPIOH SEC3.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Input mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>General purpose output mode</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>Alternate function mode</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>Analog mode (reset state)</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIOH_OTYPER</name>
          <displayName>GPIOH_OTYPER</displayName>
          <description>GPIO port H output type register</description>
          <addressOffset>0x004</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OT3</name>
              <description>Port H configuration I/O pin 3
This bit is written by software to configure the I/O output type.
Access can be protected by GPIOH SEC3.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Output push-pull (reset state)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Output open-drain</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIOH_OSPEEDR</name>
          <displayName>GPIOH_OSPEEDR</displayName>
          <description>GPIO port H output speed register</description>
          <addressOffset>0x008</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OSPEED3</name>
              <description>Port H configuration I/O pin 3
These bits are written by software to configure the I/O output speed.
Access can be protected by GPIOH SEC3.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Low speed</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Medium speed</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>High speed</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIOH_PUPDR</name>
          <displayName>GPIOH_PUPDR</displayName>
          <description>GPIO port H pull-up/pull-down register</description>
          <addressOffset>0x00C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PUPD3</name>
              <description>Port H configuration I/O pin 3
These bits are written by software to configure the I/O pull-up or pull-down
Access can be protected by GPIOH SEC3.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No pull-up, pull-down</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Pull-up</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>Pull-down</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIOH_IDR</name>
          <displayName>GPIOH_IDR</displayName>
          <description>GPIO port H input data register</description>
          <addressOffset>0x010</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFF0000</resetMask>
          <fields>
            <field>
              <name>ID3</name>
              <description>Port H input data I/O pin 3
This bit is read-only. It contain the input value of the corresponding I/O port.
Access can be protected by GPIOH SEC3.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIOH_ODR</name>
          <displayName>GPIOH_ODR</displayName>
          <description>GPIO port H output data register</description>
          <addressOffset>0x014</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OD3</name>
              <description>Port H output data I/O pin 3
This bits can be read and written by software.
Access can be protected by GPIOH SEC3.
Note: For atomic bit set/reset, the OD bit can be individually set and/or reset by writing to the GPIOH_BSRR or GPIOH_BRR registers.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIOH_BSRR</name>
          <displayName>GPIOH_BSRR</displayName>
          <description>GPIO port H bit set/reset register</description>
          <addressOffset>0x018</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BS3</name>
              <description>Port H set I/O pin 3
This bit is write-only. A read to this bit returns the value 0.
Access can be protected by GPIOH SEC3.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding OD3 bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Sets the corresponding OD3 bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BR3</name>
              <description>Port H reset I/O pin 3
This bit is write-only. A read to this bit returns the value 0.
Access can be protected by GPIOH SEC3.
Note: If both BS3 and BR3 are set, BS3 has priority.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding OD3 bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Resets the corresponding OD3 bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIOH_LCKR</name>
          <displayName>GPIOH_LCKR</displayName>
          <description>GPIO port H configuration lock register</description>
          <addressOffset>0x01C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LCK3</name>
              <description>Port H lock I/O pin 3
This bit is read/write but can only be written when the LCKK bit is 0
Access can be protected by GPIOH SEC3.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Port configuration not locked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Port configuration locked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LCKK</name>
              <description>Lock key
This bit can be read any time. It can only be modified using the lock key write sequence.
Access is protected by GPIOH SEC3.
- LOCK key write sequence:
WR LCKR[16] = 1 + LCKR[3]
WR LCKR[16] = 0 + LCKR[3]
WR LCKR[16] = 1 + LCKR[3]
- LOCK key read
RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active)
Note: During the LOCK key write sequence, the value of LCK3 must not change.
Note: Any error in the lock sequence aborts the LOCK.
Note: After the first LOCK sequence on any bit of the port, any read access on the LCKK bit returns 1 until the next MCU reset or peripheral reset.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Port configuration lock key not active</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Port configuration lock key active. The GPIOH_LCKR register is locked until the next MCU reset or peripheral reset.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIOH_AFRL</name>
          <displayName>GPIOH_AFRL</displayName>
          <description>GPIO port H alternate function low register</description>
          <addressOffset>0x020</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AFSEL3</name>
              <description>Alternate function selection for port H I/O pin 3
These bits are written by software to configure alternate function I/Os.
Access can be protected by GPIOH SEC3.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>AF0</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>AF1</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>AF2</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>AF3</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>AF4</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>AF5</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x6</name>
                  <description>AF6</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7</name>
                  <description>AF7</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x8</name>
                  <description>AF8</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x9</name>
                  <description>AF9</description>
                  <value>0x9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xA</name>
                  <description>AF10</description>
                  <value>0xA</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xB</name>
                  <description>AF11</description>
                  <value>0xB</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xC</name>
                  <description>AF12</description>
                  <value>0xC</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xD</name>
                  <description>AF13</description>
                  <value>0xD</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xE</name>
                  <description>AF14</description>
                  <value>0xE</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xF</name>
                  <description>AF15</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIOH_BRR</name>
          <displayName>GPIOH_BRR</displayName>
          <description>GPIO port H bit reset register</description>
          <addressOffset>0x028</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BR3</name>
              <description>Port H reset I/O pin 3
This bit is write-only. A read to this bit returns the value 0.
Access can be protected by GPIOH SEC3.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action on the corresponding OD3 bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset the corresponding OD3 bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIOH_SECCFGR</name>
          <displayName>GPIOH_SECCFGR</displayName>
          <description>GPIO port H secure configuration register</description>
          <addressOffset>0x030</addressOffset>
          <size>0x20</size>
          <resetValue>0x0000FFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SEC3</name>
              <description>I/O pin of port H secure bit enable 3
This bit is written by software to enabled the security I/O port pin.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>The I/O pin is non-secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>HASH</name>
      <description>HASH register block</description>
      <groupName>HASH</groupName>
      <baseAddress>0x420C0400</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x400</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>HASH</name>
        <description>HASH interrupt</description>
        <value>61</value>
      </interrupt>
      <registers>
        <register>
          <name>HASH_CR</name>
          <displayName>HASH_CR</displayName>
          <description>HASH control register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INIT</name>
              <description>Initialize message digest calculation

Writing this bit to 1 resets the hash processor core, so that the HASH is ready to compute the message digest of a new message.

Writing this bit to 0 has no effect. Reading this bit always return 0.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DMAE</name>
              <description>DMA enable

After this bit is set it is cleared by hardware while the last data of the message is written into the hash processor.

Setting this bit to 0 while a DMA transfer is ongoing is not aborting this current transfer. Instead, the DMA interface of the IP remains internally enabled until the transfer is completed or INIT is written to 1.

Setting INIT bit to 1 does not clear DMAE bit.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>DMA transfers disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>DMA transfers enabled. A DMA request is sent as soon as the HASH core is ready to receive data.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DATATYPE</name>
              <description>Data type selection

Defines the format of the data entered into the HASH_DIN register:</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>32-bit data. The data written into HASH_DIN are directly used by the HASH processing, without reordering.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>16-bit data, or half-word. The data written into HASH_DIN are considered as two half-words, and are swapped before being used by the HASH processing.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>8-bit data, or bytes. The data written into HASH_DIN are considered as four bytes, and are swapped before being used by the HASH processing.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>bit data, or bit-string. The data written into HASH_DIN are considered as 32 bits (1st bit of the string at position 0), and are swapped before being used by the HASH processing (1st bit of the string at position 31).</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MODE</name>
              <description>Mode selection

This bit selects the HASH or HMAC mode for the selected algorithm:

This selection is only taken into account when the INIT bit is set. Changing this bit during a computation has no effect.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Hash mode selected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>HMAC mode selected. LKEY must be set if the key being used is longer than 64 bytes.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NBW</name>
              <description>Number of words already pushed

Refer to NBWP[3:0] bitfield of HASH_SR for the description.

This bitfield is read-only.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DINNE</name>
              <description>DIN not empty

Refer to DINNE bit of HASH_SR for the description.

This bit is read-only.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MDMAT</name>
              <description>Multiple DMA transfers 

This bit is set when hashing large files when multiple DMA transfers are needed.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>DCAL is automatically set at the end of a DMA transfer.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>DCAL is not automatically set at the end of a DMA transfer.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LKEY</name>
              <description>Long key selection

This bit selects between short key (less than or equal 64 bytes) or long key ( 64 bytes) in HMAC mode.

This selection is only taken into account when the INIT and MODE bits are both set. Changing this bit during a computation has no effect.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>the HMAC key is shorter or equal to 64 bytes. The actual key value written to HASH_DIN is used during the HMAC computation.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>the HMAC key is longer than 64 bytes. The hash of the key is used instead of the real key during the HMAC computation.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ALGO</name>
              <description>Algorithm selection

These bits select the hash algorithm. 

This selection is only taken into account when the INIT bit is set. Changing this bitfield during a computation has no effect. 

When ALGO bitfield is updated and INIT bit is set, NBWE in HASH_SR is automatically updated to 0x11.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>SHA-1</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>MD5</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>SHA2-224</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>SHA2-256</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_DIN</name>
          <displayName>HASH_DIN</displayName>
          <description>HASH data input register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATAIN</name>
              <description>Data input

Writing this register pushes the current register content into the IN FIFO, and the register takes the new value presented on the AHB databus.

Reading this register returns zeros.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_STR</name>
          <displayName>HASH_STR</displayName>
          <description>HASH start register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NBLW</name>
              <description>Number of valid bits in the last word

When the last word of the message bit string is written in HASH_DIN register, the hash processor takes only the valid bits specified as below, after internal data swapping:

...

The above mechanism is valid only if DCAL = 0. If NBLW[4:0] bitfield is written while DCAL is set to 1, the NBLW[4:0] bitfield remains unchanged. In other words it is not possible to configure NBLW[4:0] and set DCAL at the same time.

Reading NBLW[4:0] bitfield returns the last value written to NBLW[4:0].</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x00</name>
                  <description>All 32 bits of the last data written are valid message bits that is M[31:0]</description>
                  <value>0x00</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x01</name>
                  <description>Only one bit of the last data written (after swapping) is valid that is M[0]</description>
                  <value>0x01</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x02</name>
                  <description>Only two bits of the last data written (after swapping) are valid that is M[1:0]</description>
                  <value>0x02</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x03</name>
                  <description>Only three bits of the last data written (after swapping) are valid that is M[2:0]</description>
                  <value>0x03</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1F</name>
                  <description>Only 31 bits of the last data written (after swapping) are valid that is M[30:0]</description>
                  <value>0x1F</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DCAL</name>
              <description>Digest calculation

Writing this bit to 1 starts the message padding, using the previously written value of NBLW[4:0], and starts the calculation of the final message digest with all data words written to the input FIFO since the INIT bit was last written to 1.

Reading this bit returns 0.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_HRA0</name>
          <displayName>HASH_HRA0</displayName>
          <description>HASH aliased digest register 0</description>
          <addressOffset>0xC</addressOffset>
          <size>0x20</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>H0</name>
              <description>Hash data x

Refer to Section 25.7.4: HASH digest registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_HRA1</name>
          <displayName>HASH_HRA1</displayName>
          <description>HASH aliased digest register 1</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>H1</name>
              <description>Hash data x

Refer to Section 25.7.4: HASH digest registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_HRA2</name>
          <displayName>HASH_HRA2</displayName>
          <description>HASH aliased digest register 2</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>H2</name>
              <description>Hash data x

Refer to Section 25.7.4: HASH digest registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_HRA3</name>
          <displayName>HASH_HRA3</displayName>
          <description>HASH aliased digest register 3</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>H3</name>
              <description>Hash data x

Refer to Section 25.7.4: HASH digest registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_HRA4</name>
          <displayName>HASH_HRA4</displayName>
          <description>HASH aliased digest register 4</description>
          <addressOffset>0x1C</addressOffset>
          <size>0x20</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>H4</name>
              <description>Hash data x

Refer to Section 25.7.4: HASH digest registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_IMR</name>
          <displayName>HASH_IMR</displayName>
          <description>HASH interrupt enable register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DINIE</name>
              <description>Data input interrupt enable</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Data input interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Data input interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DCIE</name>
              <description>Digest calculation completion interrupt enable</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Digest calculation completion interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Digest calculation completion interrupt enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_SR</name>
          <displayName>HASH_SR</displayName>
          <description>HASH status register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DINIS</name>
              <description>Data input interrupt status

This bit is set by hardware when the FIFO is ready to get a new block (16 locations are free). It is cleared by writing it to 0 or by writing the HASH_DIN register.

When DINIS=0, HASH_CSRx registers reads as zero.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Less than 16 locations are free in the input buffer</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>A new block can be entered into the input buffer. An interrupt is generated if the DINIE bit is set in the HASH_IMR register.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DCIS</name>
              <description>Digest calculation completion interrupt status

This bit is set by hardware when a digest becomes ready (the whole message has been processed). It is cleared by writing it to 0 or by writing the INIT bit to 1 in the HASH_CR register.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No digest available in the HASH_HRx registers (zeros are returned)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Digest calculation complete, a digest is available in the HASH_HRx registers. An interrupt is generated if the DCIE bit is set in the HASH_IMR register.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DMAS</name>
              <description>DMA Status

This bit provides information on the DMA interface activity. It is set with DMAE and cleared when DMAE = 0 and no DMA transfer is ongoing. No interrupt is associated with this bit.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>DMA interface is disabled (DMAE = 0) and no transfer is ongoing</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>DMA interface is enabled (DMAE = 1) or a transfer is ongoing</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BUSY</name>
              <description>Busy bit</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No block is currently being processed</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The hash core is processing a block of data</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NBWP</name>
              <description>Number of words already pushed

This bitfield is the exact number of words in the message that have already been pushed into the FIFO. NBWP is incremented by one when a write access is performed to the HASH_DIN register. 

When a digest calculation starts, NBWP is updated to NBWP- block size (in words), and NBWP goes to zero when the INIT bit is written to 1.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DINNE</name>
              <description>DIN not empty

This bit is set when the HASH_DIN register holds valid data (that is after being written at least once). It is cleared when either the INIT bit (initialization) or the DCAL bit (completion of the previous message processing) is written to 1.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No data are present in the data input buffer</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The input buffer contains at least one word of data</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NBWE</name>
              <description>Number of words expected

This bitfield reflects the number of words in the message that must be pushed into the FIFO to trigger a partial computation. NBWE is decremented by 1 when a write access is performed to the HASH_DIN register.

NBWE is set to the expected block size +1 in words (0x11) when INIT bit is set in HASH_CR, and it is set to the expected block size when partial digest calculation ends.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_CSR0</name>
          <displayName>HASH_CSR0</displayName>
          <description>HASH context swap register 0</description>
          <addressOffset>0xF8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CS0</name>
              <description>Context swap x

Refer to Section 25.7.7: HASH context swap registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_CSR1</name>
          <displayName>HASH_CSR1</displayName>
          <description>HASH context swap register 1</description>
          <addressOffset>0xFC</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CS1</name>
              <description>Context swap x

Refer to Section 25.7.7: HASH context swap registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_CSR2</name>
          <displayName>HASH_CSR2</displayName>
          <description>HASH context swap register 2</description>
          <addressOffset>0x100</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CS2</name>
              <description>Context swap x

Refer to Section 25.7.7: HASH context swap registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_CSR3</name>
          <displayName>HASH_CSR3</displayName>
          <description>HASH context swap register 3</description>
          <addressOffset>0x104</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CS3</name>
              <description>Context swap x

Refer to Section 25.7.7: HASH context swap registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_CSR4</name>
          <displayName>HASH_CSR4</displayName>
          <description>HASH context swap register 4</description>
          <addressOffset>0x108</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CS4</name>
              <description>Context swap x

Refer to Section 25.7.7: HASH context swap registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_CSR5</name>
          <displayName>HASH_CSR5</displayName>
          <description>HASH context swap register 5</description>
          <addressOffset>0x10C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CS5</name>
              <description>Context swap x

Refer to Section 25.7.7: HASH context swap registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_CSR6</name>
          <displayName>HASH_CSR6</displayName>
          <description>HASH context swap register 6</description>
          <addressOffset>0x110</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CS6</name>
              <description>Context swap x

Refer to Section 25.7.7: HASH context swap registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_CSR7</name>
          <displayName>HASH_CSR7</displayName>
          <description>HASH context swap register 7</description>
          <addressOffset>0x114</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CS7</name>
              <description>Context swap x

Refer to Section 25.7.7: HASH context swap registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_CSR8</name>
          <displayName>HASH_CSR8</displayName>
          <description>HASH context swap register 8</description>
          <addressOffset>0x118</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CS8</name>
              <description>Context swap x

Refer to Section 25.7.7: HASH context swap registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_CSR9</name>
          <displayName>HASH_CSR9</displayName>
          <description>HASH context swap register 9</description>
          <addressOffset>0x11C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CS9</name>
              <description>Context swap x

Refer to Section 25.7.7: HASH context swap registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_CSR10</name>
          <displayName>HASH_CSR10</displayName>
          <description>HASH context swap register 10</description>
          <addressOffset>0x120</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CS10</name>
              <description>Context swap x

Refer to Section 25.7.7: HASH context swap registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_CSR11</name>
          <displayName>HASH_CSR11</displayName>
          <description>HASH context swap register 11</description>
          <addressOffset>0x124</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CS11</name>
              <description>Context swap x

Refer to Section 25.7.7: HASH context swap registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_CSR12</name>
          <displayName>HASH_CSR12</displayName>
          <description>HASH context swap register 12</description>
          <addressOffset>0x128</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CS12</name>
              <description>Context swap x

Refer to Section 25.7.7: HASH context swap registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_CSR13</name>
          <displayName>HASH_CSR13</displayName>
          <description>HASH context swap register 13</description>
          <addressOffset>0x12C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CS13</name>
              <description>Context swap x

Refer to Section 25.7.7: HASH context swap registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_CSR14</name>
          <displayName>HASH_CSR14</displayName>
          <description>HASH context swap register 14</description>
          <addressOffset>0x130</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CS14</name>
              <description>Context swap x

Refer to Section 25.7.7: HASH context swap registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_CSR15</name>
          <displayName>HASH_CSR15</displayName>
          <description>HASH context swap register 15</description>
          <addressOffset>0x134</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CS15</name>
              <description>Context swap x

Refer to Section 25.7.7: HASH context swap registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_CSR16</name>
          <displayName>HASH_CSR16</displayName>
          <description>HASH context swap register 16</description>
          <addressOffset>0x138</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CS16</name>
              <description>Context swap x

Refer to Section 25.7.7: HASH context swap registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_CSR17</name>
          <displayName>HASH_CSR17</displayName>
          <description>HASH context swap register 17</description>
          <addressOffset>0x13C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CS17</name>
              <description>Context swap x

Refer to Section 25.7.7: HASH context swap registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_CSR18</name>
          <displayName>HASH_CSR18</displayName>
          <description>HASH context swap register 18</description>
          <addressOffset>0x140</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CS18</name>
              <description>Context swap x

Refer to Section 25.7.7: HASH context swap registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_CSR19</name>
          <displayName>HASH_CSR19</displayName>
          <description>HASH context swap register 19</description>
          <addressOffset>0x144</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CS19</name>
              <description>Context swap x

Refer to Section 25.7.7: HASH context swap registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_CSR20</name>
          <displayName>HASH_CSR20</displayName>
          <description>HASH context swap register 20</description>
          <addressOffset>0x148</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CS20</name>
              <description>Context swap x

Refer to Section 25.7.7: HASH context swap registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_CSR21</name>
          <displayName>HASH_CSR21</displayName>
          <description>HASH context swap register 21</description>
          <addressOffset>0x14C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CS21</name>
              <description>Context swap x

Refer to Section 25.7.7: HASH context swap registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_CSR22</name>
          <displayName>HASH_CSR22</displayName>
          <description>HASH context swap register 22</description>
          <addressOffset>0x150</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CS22</name>
              <description>Context swap x

Refer to Section 25.7.7: HASH context swap registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_CSR23</name>
          <displayName>HASH_CSR23</displayName>
          <description>HASH context swap register 23</description>
          <addressOffset>0x154</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CS23</name>
              <description>Context swap x

Refer to Section 25.7.7: HASH context swap registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_CSR24</name>
          <displayName>HASH_CSR24</displayName>
          <description>HASH context swap register 24</description>
          <addressOffset>0x158</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CS24</name>
              <description>Context swap x

Refer to Section 25.7.7: HASH context swap registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_CSR25</name>
          <displayName>HASH_CSR25</displayName>
          <description>HASH context swap register 25</description>
          <addressOffset>0x15C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CS25</name>
              <description>Context swap x

Refer to Section 25.7.7: HASH context swap registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_CSR26</name>
          <displayName>HASH_CSR26</displayName>
          <description>HASH context swap register 26</description>
          <addressOffset>0x160</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CS26</name>
              <description>Context swap x

Refer to Section 25.7.7: HASH context swap registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_CSR27</name>
          <displayName>HASH_CSR27</displayName>
          <description>HASH context swap register 27</description>
          <addressOffset>0x164</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CS27</name>
              <description>Context swap x

Refer to Section 25.7.7: HASH context swap registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_CSR28</name>
          <displayName>HASH_CSR28</displayName>
          <description>HASH context swap register 28</description>
          <addressOffset>0x168</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CS28</name>
              <description>Context swap x

Refer to Section 25.7.7: HASH context swap registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_CSR29</name>
          <displayName>HASH_CSR29</displayName>
          <description>HASH context swap register 29</description>
          <addressOffset>0x16C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CS29</name>
              <description>Context swap x

Refer to Section 25.7.7: HASH context swap registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_CSR30</name>
          <displayName>HASH_CSR30</displayName>
          <description>HASH context swap register 30</description>
          <addressOffset>0x170</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CS30</name>
              <description>Context swap x

Refer to Section 25.7.7: HASH context swap registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_CSR31</name>
          <displayName>HASH_CSR31</displayName>
          <description>HASH context swap register 31</description>
          <addressOffset>0x174</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CS31</name>
              <description>Context swap x

Refer to Section 25.7.7: HASH context swap registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_CSR32</name>
          <displayName>HASH_CSR32</displayName>
          <description>HASH context swap register 32</description>
          <addressOffset>0x178</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CS32</name>
              <description>Context swap x

Refer to Section 25.7.7: HASH context swap registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_CSR33</name>
          <displayName>HASH_CSR33</displayName>
          <description>HASH context swap register 33</description>
          <addressOffset>0x17C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CS33</name>
              <description>Context swap x

Refer to Section 25.7.7: HASH context swap registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_CSR34</name>
          <displayName>HASH_CSR34</displayName>
          <description>HASH context swap register 34</description>
          <addressOffset>0x180</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CS34</name>
              <description>Context swap x

Refer to Section 25.7.7: HASH context swap registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_CSR35</name>
          <displayName>HASH_CSR35</displayName>
          <description>HASH context swap register 35</description>
          <addressOffset>0x184</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CS35</name>
              <description>Context swap x

Refer to Section 25.7.7: HASH context swap registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_CSR36</name>
          <displayName>HASH_CSR36</displayName>
          <description>HASH context swap register 36</description>
          <addressOffset>0x188</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CS36</name>
              <description>Context swap x

Refer to Section 25.7.7: HASH context swap registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_CSR37</name>
          <displayName>HASH_CSR37</displayName>
          <description>HASH context swap register 37</description>
          <addressOffset>0x18C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CS37</name>
              <description>Context swap x

Refer to Section 25.7.7: HASH context swap registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_CSR38</name>
          <displayName>HASH_CSR38</displayName>
          <description>HASH context swap register 38</description>
          <addressOffset>0x190</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CS38</name>
              <description>Context swap x

Refer to Section 25.7.7: HASH context swap registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_CSR39</name>
          <displayName>HASH_CSR39</displayName>
          <description>HASH context swap register 39</description>
          <addressOffset>0x194</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CS39</name>
              <description>Context swap x

Refer to Section 25.7.7: HASH context swap registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_CSR40</name>
          <displayName>HASH_CSR40</displayName>
          <description>HASH context swap register 40</description>
          <addressOffset>0x198</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CS40</name>
              <description>Context swap x

Refer to Section 25.7.7: HASH context swap registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_CSR41</name>
          <displayName>HASH_CSR41</displayName>
          <description>HASH context swap register 41</description>
          <addressOffset>0x19C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CS41</name>
              <description>Context swap x

Refer to Section 25.7.7: HASH context swap registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_CSR42</name>
          <displayName>HASH_CSR42</displayName>
          <description>HASH context swap register 42</description>
          <addressOffset>0x1A0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CS42</name>
              <description>Context swap x

Refer to Section 25.7.7: HASH context swap registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_CSR43</name>
          <displayName>HASH_CSR43</displayName>
          <description>HASH context swap register 43</description>
          <addressOffset>0x1A4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CS43</name>
              <description>Context swap x

Refer to Section 25.7.7: HASH context swap registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_CSR44</name>
          <displayName>HASH_CSR44</displayName>
          <description>HASH context swap register 44</description>
          <addressOffset>0x1A8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CS44</name>
              <description>Context swap x

Refer to Section 25.7.7: HASH context swap registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_CSR45</name>
          <displayName>HASH_CSR45</displayName>
          <description>HASH context swap register 45</description>
          <addressOffset>0x1AC</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CS45</name>
              <description>Context swap x

Refer to Section 25.7.7: HASH context swap registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_CSR46</name>
          <displayName>HASH_CSR46</displayName>
          <description>HASH context swap register 46</description>
          <addressOffset>0x1B0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CS46</name>
              <description>Context swap x

Refer to Section 25.7.7: HASH context swap registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_CSR47</name>
          <displayName>HASH_CSR47</displayName>
          <description>HASH context swap register 47</description>
          <addressOffset>0x1B4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CS47</name>
              <description>Context swap x

Refer to Section 25.7.7: HASH context swap registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_CSR48</name>
          <displayName>HASH_CSR48</displayName>
          <description>HASH context swap register 48</description>
          <addressOffset>0x1B8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CS48</name>
              <description>Context swap x

Refer to Section 25.7.7: HASH context swap registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_CSR49</name>
          <displayName>HASH_CSR49</displayName>
          <description>HASH context swap register 49</description>
          <addressOffset>0x1BC</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CS49</name>
              <description>Context swap x

Refer to Section 25.7.7: HASH context swap registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_CSR50</name>
          <displayName>HASH_CSR50</displayName>
          <description>HASH context swap register 50</description>
          <addressOffset>0x1C0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CS50</name>
              <description>Context swap x

Refer to Section 25.7.7: HASH context swap registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_CSR51</name>
          <displayName>HASH_CSR51</displayName>
          <description>HASH context swap register 51</description>
          <addressOffset>0x1C4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CS51</name>
              <description>Context swap x

Refer to Section 25.7.7: HASH context swap registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_CSR52</name>
          <displayName>HASH_CSR52</displayName>
          <description>HASH context swap register 52</description>
          <addressOffset>0x1C8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CS52</name>
              <description>Context swap x

Refer to Section 25.7.7: HASH context swap registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_CSR53</name>
          <displayName>HASH_CSR53</displayName>
          <description>HASH context swap register 53</description>
          <addressOffset>0x1CC</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CS53</name>
              <description>Context swap x

Refer to Section 25.7.7: HASH context swap registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_HR0</name>
          <displayName>HASH_HR0</displayName>
          <description>HASH digest register 0</description>
          <addressOffset>0x310</addressOffset>
          <size>0x20</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>H0</name>
              <description>Hash data x

Refer to Section 25.7.4: HASH digest registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_HR1</name>
          <displayName>HASH_HR1</displayName>
          <description>HASH digest register 1</description>
          <addressOffset>0x314</addressOffset>
          <size>0x20</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>H1</name>
              <description>Hash data x

Refer to Section 25.7.4: HASH digest registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_HR2</name>
          <displayName>HASH_HR2</displayName>
          <description>HASH digest register 2</description>
          <addressOffset>0x318</addressOffset>
          <size>0x20</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>H2</name>
              <description>Hash data x

Refer to Section 25.7.4: HASH digest registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_HR3</name>
          <displayName>HASH_HR3</displayName>
          <description>HASH digest register 3</description>
          <addressOffset>0x31C</addressOffset>
          <size>0x20</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>H3</name>
              <description>Hash data x

Refer to Section 25.7.4: HASH digest registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_HR4</name>
          <displayName>HASH_HR4</displayName>
          <description>HASH digest register 4</description>
          <addressOffset>0x320</addressOffset>
          <size>0x20</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>H4</name>
              <description>Hash data x

Refer to Section 25.7.4: HASH digest registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_HR5</name>
          <displayName>HASH_HR5</displayName>
          <description>HASH supplementary digest register 5</description>
          <addressOffset>0x324</addressOffset>
          <size>0x20</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>H5</name>
              <description>Hash data x

Refer to Section 25.7.4: HASH digest registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_HR6</name>
          <displayName>HASH_HR6</displayName>
          <description>HASH supplementary digest register 6</description>
          <addressOffset>0x328</addressOffset>
          <size>0x20</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>H6</name>
              <description>Hash data x

Refer to Section 25.7.4: HASH digest registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_HR7</name>
          <displayName>HASH_HR7</displayName>
          <description>HASH supplementary digest register 7</description>
          <addressOffset>0x32C</addressOffset>
          <size>0x20</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>H7</name>
              <description>Hash data x

Refer to Section 25.7.4: HASH digest registers introduction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>HSEM</name>
      <description>Hardware semaphore</description>
      <groupName>HSEM</groupName>
      <baseAddress>0x420C1C00</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x400</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>HSEM</name>
        <description>HSEM non-secure interrupt</description>
        <value>68</value>
      </interrupt>
      <interrupt>
        <name>HSEM_S</name>
        <description>HSEM secure interrupt</description>
        <value>69</value>
      </interrupt>
      <registers>
        <register>
          <name>HSEM_R0</name>
          <displayName>HSEM_R0</displayName>
          <description>HSEM register semaphore 0</description>
          <addressOffset>0x000</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PROCID</name>
              <description>Semaphore PROCID
Written by software
-When the semaphore is free and the LOCK is written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition, PROCID is set to the written data.
- When the semaphore is unlocked, LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the PROCID is cleared to 0.
- When the semaphore is unlocked, LOCK bit written to 0 and AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match the AHB bus master definition, the PROCID is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the PROCID is not affected.
- An authorized read returns the stored PROCID value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCKID</name>
              <description>Semaphore LOCKID
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1 and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master protection.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the LOCKID is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 or AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match AHB bus master protection, the LOCKID is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the LOCKID is not affected.
- An authorized read returns the stored LOCKID value.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEC</name>
              <description>Semaphore secure
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the SEC is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the SEC is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the SEC is not affected.
- An authorized read returns the stored SEC value.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Semaphore free or locked by non-secure compartment.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Semaphore locked by secure compartment.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIV</name>
              <description>Semaphore privilege
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the PRIV is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the PRIV is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the PRIV is not affected.
- An authorized read returns the stored PRIV value.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Semaphore free or locked by unprivileged compartment.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Semaphore locked by privilege compartment.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LOCK</name>
              <description>Lock indication
This bit can be written and read by software.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>On write free semaphore (only when LOCKID and PROCID match), on read semaphore is free.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>On write try to lock semaphore, on read semaphore is locked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>HSEM_R1</name>
          <displayName>HSEM_R1</displayName>
          <description>HSEM register semaphore 1</description>
          <addressOffset>0x4</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PROCID</name>
              <description>Semaphore PROCID
Written by software
-When the semaphore is free and the LOCK is written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition, PROCID is set to the written data.
- When the semaphore is unlocked, LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the PROCID is cleared to 0.
- When the semaphore is unlocked, LOCK bit written to 0 and AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match the AHB bus master definition, the PROCID is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the PROCID is not affected.
- An authorized read returns the stored PROCID value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCKID</name>
              <description>Semaphore LOCKID
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1 and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master protection.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the LOCKID is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 or AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match AHB bus master protection, the LOCKID is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the LOCKID is not affected.
- An authorized read returns the stored LOCKID value.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEC</name>
              <description>Semaphore secure
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the SEC is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the SEC is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the SEC is not affected.
- An authorized read returns the stored SEC value.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Semaphore free or locked by non-secure compartment.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Semaphore locked by secure compartment.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIV</name>
              <description>Semaphore privilege
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the PRIV is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the PRIV is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the PRIV is not affected.
- An authorized read returns the stored PRIV value.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Semaphore free or locked by unprivileged compartment.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Semaphore locked by privilege compartment.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LOCK</name>
              <description>Lock indication
This bit can be written and read by software.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>On write free semaphore (only when LOCKID and PROCID match), on read semaphore is free.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>On write try to lock semaphore, on read semaphore is locked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>HSEM_R2</name>
          <displayName>HSEM_R2</displayName>
          <description>HSEM register semaphore 2</description>
          <addressOffset>0x8</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PROCID</name>
              <description>Semaphore PROCID
Written by software
-When the semaphore is free and the LOCK is written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition, PROCID is set to the written data.
- When the semaphore is unlocked, LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the PROCID is cleared to 0.
- When the semaphore is unlocked, LOCK bit written to 0 and AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match the AHB bus master definition, the PROCID is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the PROCID is not affected.
- An authorized read returns the stored PROCID value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCKID</name>
              <description>Semaphore LOCKID
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1 and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master protection.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the LOCKID is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 or AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match AHB bus master protection, the LOCKID is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the LOCKID is not affected.
- An authorized read returns the stored LOCKID value.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEC</name>
              <description>Semaphore secure
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the SEC is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the SEC is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the SEC is not affected.
- An authorized read returns the stored SEC value.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Semaphore free or locked by non-secure compartment.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Semaphore locked by secure compartment.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIV</name>
              <description>Semaphore privilege
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the PRIV is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the PRIV is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the PRIV is not affected.
- An authorized read returns the stored PRIV value.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Semaphore free or locked by unprivileged compartment.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Semaphore locked by privilege compartment.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LOCK</name>
              <description>Lock indication
This bit can be written and read by software.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>On write free semaphore (only when LOCKID and PROCID match), on read semaphore is free.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>On write try to lock semaphore, on read semaphore is locked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>HSEM_R3</name>
          <displayName>HSEM_R3</displayName>
          <description>HSEM register semaphore 3</description>
          <addressOffset>0xC</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PROCID</name>
              <description>Semaphore PROCID
Written by software
-When the semaphore is free and the LOCK is written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition, PROCID is set to the written data.
- When the semaphore is unlocked, LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the PROCID is cleared to 0.
- When the semaphore is unlocked, LOCK bit written to 0 and AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match the AHB bus master definition, the PROCID is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the PROCID is not affected.
- An authorized read returns the stored PROCID value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCKID</name>
              <description>Semaphore LOCKID
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1 and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master protection.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the LOCKID is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 or AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match AHB bus master protection, the LOCKID is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the LOCKID is not affected.
- An authorized read returns the stored LOCKID value.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEC</name>
              <description>Semaphore secure
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the SEC is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the SEC is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the SEC is not affected.
- An authorized read returns the stored SEC value.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Semaphore free or locked by non-secure compartment.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Semaphore locked by secure compartment.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIV</name>
              <description>Semaphore privilege
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the PRIV is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the PRIV is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the PRIV is not affected.
- An authorized read returns the stored PRIV value.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Semaphore free or locked by unprivileged compartment.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Semaphore locked by privilege compartment.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LOCK</name>
              <description>Lock indication
This bit can be written and read by software.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>On write free semaphore (only when LOCKID and PROCID match), on read semaphore is free.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>On write try to lock semaphore, on read semaphore is locked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>HSEM_R4</name>
          <displayName>HSEM_R4</displayName>
          <description>HSEM register semaphore 4</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PROCID</name>
              <description>Semaphore PROCID
Written by software
-When the semaphore is free and the LOCK is written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition, PROCID is set to the written data.
- When the semaphore is unlocked, LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the PROCID is cleared to 0.
- When the semaphore is unlocked, LOCK bit written to 0 and AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match the AHB bus master definition, the PROCID is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the PROCID is not affected.
- An authorized read returns the stored PROCID value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCKID</name>
              <description>Semaphore LOCKID
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1 and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master protection.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the LOCKID is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 or AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match AHB bus master protection, the LOCKID is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the LOCKID is not affected.
- An authorized read returns the stored LOCKID value.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEC</name>
              <description>Semaphore secure
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the SEC is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the SEC is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the SEC is not affected.
- An authorized read returns the stored SEC value.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Semaphore free or locked by non-secure compartment.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Semaphore locked by secure compartment.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIV</name>
              <description>Semaphore privilege
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the PRIV is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the PRIV is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the PRIV is not affected.
- An authorized read returns the stored PRIV value.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Semaphore free or locked by unprivileged compartment.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Semaphore locked by privilege compartment.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LOCK</name>
              <description>Lock indication
This bit can be written and read by software.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>On write free semaphore (only when LOCKID and PROCID match), on read semaphore is free.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>On write try to lock semaphore, on read semaphore is locked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>HSEM_R5</name>
          <displayName>HSEM_R5</displayName>
          <description>HSEM register semaphore 5</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PROCID</name>
              <description>Semaphore PROCID
Written by software
-When the semaphore is free and the LOCK is written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition, PROCID is set to the written data.
- When the semaphore is unlocked, LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the PROCID is cleared to 0.
- When the semaphore is unlocked, LOCK bit written to 0 and AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match the AHB bus master definition, the PROCID is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the PROCID is not affected.
- An authorized read returns the stored PROCID value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCKID</name>
              <description>Semaphore LOCKID
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1 and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master protection.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the LOCKID is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 or AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match AHB bus master protection, the LOCKID is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the LOCKID is not affected.
- An authorized read returns the stored LOCKID value.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEC</name>
              <description>Semaphore secure
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the SEC is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the SEC is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the SEC is not affected.
- An authorized read returns the stored SEC value.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Semaphore free or locked by non-secure compartment.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Semaphore locked by secure compartment.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIV</name>
              <description>Semaphore privilege
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the PRIV is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the PRIV is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the PRIV is not affected.
- An authorized read returns the stored PRIV value.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Semaphore free or locked by unprivileged compartment.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Semaphore locked by privilege compartment.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LOCK</name>
              <description>Lock indication
This bit can be written and read by software.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>On write free semaphore (only when LOCKID and PROCID match), on read semaphore is free.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>On write try to lock semaphore, on read semaphore is locked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>HSEM_R6</name>
          <displayName>HSEM_R6</displayName>
          <description>HSEM register semaphore 6</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PROCID</name>
              <description>Semaphore PROCID
Written by software
-When the semaphore is free and the LOCK is written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition, PROCID is set to the written data.
- When the semaphore is unlocked, LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the PROCID is cleared to 0.
- When the semaphore is unlocked, LOCK bit written to 0 and AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match the AHB bus master definition, the PROCID is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the PROCID is not affected.
- An authorized read returns the stored PROCID value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCKID</name>
              <description>Semaphore LOCKID
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1 and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master protection.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the LOCKID is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 or AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match AHB bus master protection, the LOCKID is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the LOCKID is not affected.
- An authorized read returns the stored LOCKID value.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEC</name>
              <description>Semaphore secure
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the SEC is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the SEC is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the SEC is not affected.
- An authorized read returns the stored SEC value.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Semaphore free or locked by non-secure compartment.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Semaphore locked by secure compartment.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIV</name>
              <description>Semaphore privilege
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the PRIV is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the PRIV is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the PRIV is not affected.
- An authorized read returns the stored PRIV value.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Semaphore free or locked by unprivileged compartment.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Semaphore locked by privilege compartment.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LOCK</name>
              <description>Lock indication
This bit can be written and read by software.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>On write free semaphore (only when LOCKID and PROCID match), on read semaphore is free.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>On write try to lock semaphore, on read semaphore is locked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>HSEM_R7</name>
          <displayName>HSEM_R7</displayName>
          <description>HSEM register semaphore 7</description>
          <addressOffset>0x1C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PROCID</name>
              <description>Semaphore PROCID
Written by software
-When the semaphore is free and the LOCK is written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition, PROCID is set to the written data.
- When the semaphore is unlocked, LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the PROCID is cleared to 0.
- When the semaphore is unlocked, LOCK bit written to 0 and AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match the AHB bus master definition, the PROCID is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the PROCID is not affected.
- An authorized read returns the stored PROCID value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCKID</name>
              <description>Semaphore LOCKID
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1 and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master protection.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the LOCKID is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 or AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match AHB bus master protection, the LOCKID is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the LOCKID is not affected.
- An authorized read returns the stored LOCKID value.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEC</name>
              <description>Semaphore secure
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the SEC is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the SEC is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the SEC is not affected.
- An authorized read returns the stored SEC value.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Semaphore free or locked by non-secure compartment.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Semaphore locked by secure compartment.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIV</name>
              <description>Semaphore privilege
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the PRIV is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the PRIV is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the PRIV is not affected.
- An authorized read returns the stored PRIV value.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Semaphore free or locked by unprivileged compartment.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Semaphore locked by privilege compartment.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LOCK</name>
              <description>Lock indication
This bit can be written and read by software.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>On write free semaphore (only when LOCKID and PROCID match), on read semaphore is free.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>On write try to lock semaphore, on read semaphore is locked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>HSEM_R8</name>
          <displayName>HSEM_R8</displayName>
          <description>HSEM register semaphore 8</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PROCID</name>
              <description>Semaphore PROCID
Written by software
-When the semaphore is free and the LOCK is written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition, PROCID is set to the written data.
- When the semaphore is unlocked, LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the PROCID is cleared to 0.
- When the semaphore is unlocked, LOCK bit written to 0 and AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match the AHB bus master definition, the PROCID is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the PROCID is not affected.
- An authorized read returns the stored PROCID value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCKID</name>
              <description>Semaphore LOCKID
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1 and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master protection.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the LOCKID is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 or AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match AHB bus master protection, the LOCKID is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the LOCKID is not affected.
- An authorized read returns the stored LOCKID value.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEC</name>
              <description>Semaphore secure
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the SEC is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the SEC is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the SEC is not affected.
- An authorized read returns the stored SEC value.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Semaphore free or locked by non-secure compartment.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Semaphore locked by secure compartment.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIV</name>
              <description>Semaphore privilege
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the PRIV is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the PRIV is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the PRIV is not affected.
- An authorized read returns the stored PRIV value.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Semaphore free or locked by unprivileged compartment.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Semaphore locked by privilege compartment.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LOCK</name>
              <description>Lock indication
This bit can be written and read by software.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>On write free semaphore (only when LOCKID and PROCID match), on read semaphore is free.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>On write try to lock semaphore, on read semaphore is locked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>HSEM_R9</name>
          <displayName>HSEM_R9</displayName>
          <description>HSEM register semaphore 9</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PROCID</name>
              <description>Semaphore PROCID
Written by software
-When the semaphore is free and the LOCK is written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition, PROCID is set to the written data.
- When the semaphore is unlocked, LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the PROCID is cleared to 0.
- When the semaphore is unlocked, LOCK bit written to 0 and AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match the AHB bus master definition, the PROCID is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the PROCID is not affected.
- An authorized read returns the stored PROCID value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCKID</name>
              <description>Semaphore LOCKID
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1 and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master protection.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the LOCKID is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 or AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match AHB bus master protection, the LOCKID is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the LOCKID is not affected.
- An authorized read returns the stored LOCKID value.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEC</name>
              <description>Semaphore secure
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the SEC is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the SEC is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the SEC is not affected.
- An authorized read returns the stored SEC value.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Semaphore free or locked by non-secure compartment.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Semaphore locked by secure compartment.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIV</name>
              <description>Semaphore privilege
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the PRIV is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the PRIV is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the PRIV is not affected.
- An authorized read returns the stored PRIV value.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Semaphore free or locked by unprivileged compartment.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Semaphore locked by privilege compartment.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LOCK</name>
              <description>Lock indication
This bit can be written and read by software.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>On write free semaphore (only when LOCKID and PROCID match), on read semaphore is free.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>On write try to lock semaphore, on read semaphore is locked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>HSEM_R10</name>
          <displayName>HSEM_R10</displayName>
          <description>HSEM register semaphore 10</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PROCID</name>
              <description>Semaphore PROCID
Written by software
-When the semaphore is free and the LOCK is written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition, PROCID is set to the written data.
- When the semaphore is unlocked, LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the PROCID is cleared to 0.
- When the semaphore is unlocked, LOCK bit written to 0 and AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match the AHB bus master definition, the PROCID is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the PROCID is not affected.
- An authorized read returns the stored PROCID value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCKID</name>
              <description>Semaphore LOCKID
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1 and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master protection.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the LOCKID is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 or AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match AHB bus master protection, the LOCKID is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the LOCKID is not affected.
- An authorized read returns the stored LOCKID value.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEC</name>
              <description>Semaphore secure
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the SEC is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the SEC is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the SEC is not affected.
- An authorized read returns the stored SEC value.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Semaphore free or locked by non-secure compartment.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Semaphore locked by secure compartment.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIV</name>
              <description>Semaphore privilege
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the PRIV is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the PRIV is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the PRIV is not affected.
- An authorized read returns the stored PRIV value.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Semaphore free or locked by unprivileged compartment.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Semaphore locked by privilege compartment.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LOCK</name>
              <description>Lock indication
This bit can be written and read by software.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>On write free semaphore (only when LOCKID and PROCID match), on read semaphore is free.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>On write try to lock semaphore, on read semaphore is locked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>HSEM_R11</name>
          <displayName>HSEM_R11</displayName>
          <description>HSEM register semaphore 11</description>
          <addressOffset>0x2C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PROCID</name>
              <description>Semaphore PROCID
Written by software
-When the semaphore is free and the LOCK is written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition, PROCID is set to the written data.
- When the semaphore is unlocked, LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the PROCID is cleared to 0.
- When the semaphore is unlocked, LOCK bit written to 0 and AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match the AHB bus master definition, the PROCID is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the PROCID is not affected.
- An authorized read returns the stored PROCID value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCKID</name>
              <description>Semaphore LOCKID
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1 and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master protection.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the LOCKID is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 or AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match AHB bus master protection, the LOCKID is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the LOCKID is not affected.
- An authorized read returns the stored LOCKID value.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEC</name>
              <description>Semaphore secure
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the SEC is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the SEC is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the SEC is not affected.
- An authorized read returns the stored SEC value.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Semaphore free or locked by non-secure compartment.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Semaphore locked by secure compartment.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIV</name>
              <description>Semaphore privilege
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the PRIV is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the PRIV is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the PRIV is not affected.
- An authorized read returns the stored PRIV value.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Semaphore free or locked by unprivileged compartment.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Semaphore locked by privilege compartment.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LOCK</name>
              <description>Lock indication
This bit can be written and read by software.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>On write free semaphore (only when LOCKID and PROCID match), on read semaphore is free.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>On write try to lock semaphore, on read semaphore is locked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>HSEM_R12</name>
          <displayName>HSEM_R12</displayName>
          <description>HSEM register semaphore 12</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PROCID</name>
              <description>Semaphore PROCID
Written by software
-When the semaphore is free and the LOCK is written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition, PROCID is set to the written data.
- When the semaphore is unlocked, LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the PROCID is cleared to 0.
- When the semaphore is unlocked, LOCK bit written to 0 and AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match the AHB bus master definition, the PROCID is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the PROCID is not affected.
- An authorized read returns the stored PROCID value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCKID</name>
              <description>Semaphore LOCKID
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1 and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master protection.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the LOCKID is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 or AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match AHB bus master protection, the LOCKID is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the LOCKID is not affected.
- An authorized read returns the stored LOCKID value.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEC</name>
              <description>Semaphore secure
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the SEC is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the SEC is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the SEC is not affected.
- An authorized read returns the stored SEC value.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Semaphore free or locked by non-secure compartment.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Semaphore locked by secure compartment.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIV</name>
              <description>Semaphore privilege
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the PRIV is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the PRIV is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the PRIV is not affected.
- An authorized read returns the stored PRIV value.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Semaphore free or locked by unprivileged compartment.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Semaphore locked by privilege compartment.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LOCK</name>
              <description>Lock indication
This bit can be written and read by software.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>On write free semaphore (only when LOCKID and PROCID match), on read semaphore is free.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>On write try to lock semaphore, on read semaphore is locked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>HSEM_R13</name>
          <displayName>HSEM_R13</displayName>
          <description>HSEM register semaphore 13</description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PROCID</name>
              <description>Semaphore PROCID
Written by software
-When the semaphore is free and the LOCK is written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition, PROCID is set to the written data.
- When the semaphore is unlocked, LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the PROCID is cleared to 0.
- When the semaphore is unlocked, LOCK bit written to 0 and AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match the AHB bus master definition, the PROCID is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the PROCID is not affected.
- An authorized read returns the stored PROCID value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCKID</name>
              <description>Semaphore LOCKID
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1 and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master protection.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the LOCKID is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 or AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match AHB bus master protection, the LOCKID is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the LOCKID is not affected.
- An authorized read returns the stored LOCKID value.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEC</name>
              <description>Semaphore secure
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the SEC is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the SEC is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the SEC is not affected.
- An authorized read returns the stored SEC value.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Semaphore free or locked by non-secure compartment.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Semaphore locked by secure compartment.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIV</name>
              <description>Semaphore privilege
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the PRIV is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the PRIV is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the PRIV is not affected.
- An authorized read returns the stored PRIV value.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Semaphore free or locked by unprivileged compartment.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Semaphore locked by privilege compartment.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LOCK</name>
              <description>Lock indication
This bit can be written and read by software.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>On write free semaphore (only when LOCKID and PROCID match), on read semaphore is free.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>On write try to lock semaphore, on read semaphore is locked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>HSEM_R14</name>
          <displayName>HSEM_R14</displayName>
          <description>HSEM register semaphore 14</description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PROCID</name>
              <description>Semaphore PROCID
Written by software
-When the semaphore is free and the LOCK is written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition, PROCID is set to the written data.
- When the semaphore is unlocked, LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the PROCID is cleared to 0.
- When the semaphore is unlocked, LOCK bit written to 0 and AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match the AHB bus master definition, the PROCID is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the PROCID is not affected.
- An authorized read returns the stored PROCID value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCKID</name>
              <description>Semaphore LOCKID
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1 and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master protection.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the LOCKID is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 or AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match AHB bus master protection, the LOCKID is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the LOCKID is not affected.
- An authorized read returns the stored LOCKID value.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEC</name>
              <description>Semaphore secure
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the SEC is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the SEC is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the SEC is not affected.
- An authorized read returns the stored SEC value.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Semaphore free or locked by non-secure compartment.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Semaphore locked by secure compartment.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIV</name>
              <description>Semaphore privilege
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the PRIV is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the PRIV is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the PRIV is not affected.
- An authorized read returns the stored PRIV value.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Semaphore free or locked by unprivileged compartment.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Semaphore locked by privilege compartment.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LOCK</name>
              <description>Lock indication
This bit can be written and read by software.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>On write free semaphore (only when LOCKID and PROCID match), on read semaphore is free.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>On write try to lock semaphore, on read semaphore is locked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>HSEM_R15</name>
          <displayName>HSEM_R15</displayName>
          <description>HSEM register semaphore 15</description>
          <addressOffset>0x3C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PROCID</name>
              <description>Semaphore PROCID
Written by software
-When the semaphore is free and the LOCK is written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition, PROCID is set to the written data.
- When the semaphore is unlocked, LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the PROCID is cleared to 0.
- When the semaphore is unlocked, LOCK bit written to 0 and AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match the AHB bus master definition, the PROCID is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the PROCID is not affected.
- An authorized read returns the stored PROCID value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCKID</name>
              <description>Semaphore LOCKID
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1 and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master protection.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the LOCKID is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 or AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match AHB bus master protection, the LOCKID is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the LOCKID is not affected.
- An authorized read returns the stored LOCKID value.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEC</name>
              <description>Semaphore secure
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the SEC is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the SEC is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the SEC is not affected.
- An authorized read returns the stored SEC value.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Semaphore free or locked by non-secure compartment.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Semaphore locked by secure compartment.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIV</name>
              <description>Semaphore privilege
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the PRIV is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the PRIV is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the PRIV is not affected.
- An authorized read returns the stored PRIV value.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Semaphore free or locked by unprivileged compartment.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Semaphore locked by privilege compartment.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LOCK</name>
              <description>Lock indication
This bit can be written and read by software.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>On write free semaphore (only when LOCKID and PROCID match), on read semaphore is free.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>On write try to lock semaphore, on read semaphore is locked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>HSEM_RLR0</name>
          <displayName>HSEM_RLR0</displayName>
          <description>HSEM read lock register semaphore 0</description>
          <addressOffset>0x80</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PROCID</name>
              <description>Semaphore processor ID
This field is read only by software at this address.
- On a read when the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PROCID to 0.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the PROCID of the AHB bus master that has locked the semaphore.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LOCKID</name>
              <description>Semaphore LOCKID
This field is read only by software at this address.
On a read, when the semaphore is free, the hardware sets the LOCKID to the AHB bus master ID reading the semaphore. The LOCKID of the AHB bus master locking the semaphore is read.
On a read when the semaphore is locked, this field returns the LOCKID of the AHB bus master that has locked the semaphore.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SEC</name>
              <description>Semaphore secure.
This field is read only by software at this address.
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the SEC to the valid AHB bus master security definition.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the SEC of the AHB bus master that has locked the semaphore.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Semaphore free or locked by non-secure compartment.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Semaphore locked by secure compartment.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIV</name>
              <description>Semaphore privilege
This field is read only by software at this address.
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PRIV to the valid AHB bus master privileged definition.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the PRIV of the AHB bus master that has locked the semaphore.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Semaphore free or locked by unprivileged compartment.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Semaphore locked by privileged compartment.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LOCK</name>
              <description>Lock indication
This bit is read only by software at this address. 
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and returns 1.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns 1 (the LOCKID and SEC and PRIV and PROCID reflect the already locked semaphore information).</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HSEM_RLR1</name>
          <displayName>HSEM_RLR1</displayName>
          <description>HSEM read lock register semaphore 1</description>
          <addressOffset>0x84</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PROCID</name>
              <description>Semaphore processor ID
This field is read only by software at this address.
- On a read when the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PROCID to 0.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the PROCID of the AHB bus master that has locked the semaphore.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LOCKID</name>
              <description>Semaphore LOCKID
This field is read only by software at this address.
On a read, when the semaphore is free, the hardware sets the LOCKID to the AHB bus master ID reading the semaphore. The LOCKID of the AHB bus master locking the semaphore is read.
On a read when the semaphore is locked, this field returns the LOCKID of the AHB bus master that has locked the semaphore.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SEC</name>
              <description>Semaphore secure.
This field is read only by software at this address.
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the SEC to the valid AHB bus master security definition.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the SEC of the AHB bus master that has locked the semaphore.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Semaphore free or locked by non-secure compartment.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Semaphore locked by secure compartment.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIV</name>
              <description>Semaphore privilege
This field is read only by software at this address.
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PRIV to the valid AHB bus master privileged definition.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the PRIV of the AHB bus master that has locked the semaphore.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Semaphore free or locked by unprivileged compartment.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Semaphore locked by privileged compartment.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LOCK</name>
              <description>Lock indication
This bit is read only by software at this address. 
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and returns 1.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns 1 (the LOCKID and SEC and PRIV and PROCID reflect the already locked semaphore information).</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HSEM_RLR2</name>
          <displayName>HSEM_RLR2</displayName>
          <description>HSEM read lock register semaphore 2</description>
          <addressOffset>0x88</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PROCID</name>
              <description>Semaphore processor ID
This field is read only by software at this address.
- On a read when the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PROCID to 0.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the PROCID of the AHB bus master that has locked the semaphore.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LOCKID</name>
              <description>Semaphore LOCKID
This field is read only by software at this address.
On a read, when the semaphore is free, the hardware sets the LOCKID to the AHB bus master ID reading the semaphore. The LOCKID of the AHB bus master locking the semaphore is read.
On a read when the semaphore is locked, this field returns the LOCKID of the AHB bus master that has locked the semaphore.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SEC</name>
              <description>Semaphore secure.
This field is read only by software at this address.
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the SEC to the valid AHB bus master security definition.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the SEC of the AHB bus master that has locked the semaphore.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Semaphore free or locked by non-secure compartment.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Semaphore locked by secure compartment.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIV</name>
              <description>Semaphore privilege
This field is read only by software at this address.
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PRIV to the valid AHB bus master privileged definition.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the PRIV of the AHB bus master that has locked the semaphore.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Semaphore free or locked by unprivileged compartment.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Semaphore locked by privileged compartment.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LOCK</name>
              <description>Lock indication
This bit is read only by software at this address. 
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and returns 1.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns 1 (the LOCKID and SEC and PRIV and PROCID reflect the already locked semaphore information).</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HSEM_RLR3</name>
          <displayName>HSEM_RLR3</displayName>
          <description>HSEM read lock register semaphore 3</description>
          <addressOffset>0x8C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PROCID</name>
              <description>Semaphore processor ID
This field is read only by software at this address.
- On a read when the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PROCID to 0.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the PROCID of the AHB bus master that has locked the semaphore.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LOCKID</name>
              <description>Semaphore LOCKID
This field is read only by software at this address.
On a read, when the semaphore is free, the hardware sets the LOCKID to the AHB bus master ID reading the semaphore. The LOCKID of the AHB bus master locking the semaphore is read.
On a read when the semaphore is locked, this field returns the LOCKID of the AHB bus master that has locked the semaphore.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SEC</name>
              <description>Semaphore secure.
This field is read only by software at this address.
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the SEC to the valid AHB bus master security definition.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the SEC of the AHB bus master that has locked the semaphore.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Semaphore free or locked by non-secure compartment.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Semaphore locked by secure compartment.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIV</name>
              <description>Semaphore privilege
This field is read only by software at this address.
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PRIV to the valid AHB bus master privileged definition.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the PRIV of the AHB bus master that has locked the semaphore.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Semaphore free or locked by unprivileged compartment.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Semaphore locked by privileged compartment.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LOCK</name>
              <description>Lock indication
This bit is read only by software at this address. 
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and returns 1.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns 1 (the LOCKID and SEC and PRIV and PROCID reflect the already locked semaphore information).</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HSEM_RLR4</name>
          <displayName>HSEM_RLR4</displayName>
          <description>HSEM read lock register semaphore 4</description>
          <addressOffset>0x90</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PROCID</name>
              <description>Semaphore processor ID
This field is read only by software at this address.
- On a read when the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PROCID to 0.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the PROCID of the AHB bus master that has locked the semaphore.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LOCKID</name>
              <description>Semaphore LOCKID
This field is read only by software at this address.
On a read, when the semaphore is free, the hardware sets the LOCKID to the AHB bus master ID reading the semaphore. The LOCKID of the AHB bus master locking the semaphore is read.
On a read when the semaphore is locked, this field returns the LOCKID of the AHB bus master that has locked the semaphore.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SEC</name>
              <description>Semaphore secure.
This field is read only by software at this address.
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the SEC to the valid AHB bus master security definition.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the SEC of the AHB bus master that has locked the semaphore.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Semaphore free or locked by non-secure compartment.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Semaphore locked by secure compartment.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIV</name>
              <description>Semaphore privilege
This field is read only by software at this address.
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PRIV to the valid AHB bus master privileged definition.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the PRIV of the AHB bus master that has locked the semaphore.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Semaphore free or locked by unprivileged compartment.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Semaphore locked by privileged compartment.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LOCK</name>
              <description>Lock indication
This bit is read only by software at this address. 
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and returns 1.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns 1 (the LOCKID and SEC and PRIV and PROCID reflect the already locked semaphore information).</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HSEM_RLR5</name>
          <displayName>HSEM_RLR5</displayName>
          <description>HSEM read lock register semaphore 5</description>
          <addressOffset>0x94</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PROCID</name>
              <description>Semaphore processor ID
This field is read only by software at this address.
- On a read when the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PROCID to 0.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the PROCID of the AHB bus master that has locked the semaphore.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LOCKID</name>
              <description>Semaphore LOCKID
This field is read only by software at this address.
On a read, when the semaphore is free, the hardware sets the LOCKID to the AHB bus master ID reading the semaphore. The LOCKID of the AHB bus master locking the semaphore is read.
On a read when the semaphore is locked, this field returns the LOCKID of the AHB bus master that has locked the semaphore.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SEC</name>
              <description>Semaphore secure.
This field is read only by software at this address.
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the SEC to the valid AHB bus master security definition.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the SEC of the AHB bus master that has locked the semaphore.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Semaphore free or locked by non-secure compartment.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Semaphore locked by secure compartment.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIV</name>
              <description>Semaphore privilege
This field is read only by software at this address.
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PRIV to the valid AHB bus master privileged definition.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the PRIV of the AHB bus master that has locked the semaphore.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Semaphore free or locked by unprivileged compartment.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Semaphore locked by privileged compartment.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LOCK</name>
              <description>Lock indication
This bit is read only by software at this address. 
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and returns 1.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns 1 (the LOCKID and SEC and PRIV and PROCID reflect the already locked semaphore information).</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HSEM_RLR6</name>
          <displayName>HSEM_RLR6</displayName>
          <description>HSEM read lock register semaphore 6</description>
          <addressOffset>0x98</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PROCID</name>
              <description>Semaphore processor ID
This field is read only by software at this address.
- On a read when the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PROCID to 0.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the PROCID of the AHB bus master that has locked the semaphore.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LOCKID</name>
              <description>Semaphore LOCKID
This field is read only by software at this address.
On a read, when the semaphore is free, the hardware sets the LOCKID to the AHB bus master ID reading the semaphore. The LOCKID of the AHB bus master locking the semaphore is read.
On a read when the semaphore is locked, this field returns the LOCKID of the AHB bus master that has locked the semaphore.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SEC</name>
              <description>Semaphore secure.
This field is read only by software at this address.
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the SEC to the valid AHB bus master security definition.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the SEC of the AHB bus master that has locked the semaphore.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Semaphore free or locked by non-secure compartment.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Semaphore locked by secure compartment.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIV</name>
              <description>Semaphore privilege
This field is read only by software at this address.
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PRIV to the valid AHB bus master privileged definition.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the PRIV of the AHB bus master that has locked the semaphore.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Semaphore free or locked by unprivileged compartment.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Semaphore locked by privileged compartment.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LOCK</name>
              <description>Lock indication
This bit is read only by software at this address. 
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and returns 1.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns 1 (the LOCKID and SEC and PRIV and PROCID reflect the already locked semaphore information).</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HSEM_RLR7</name>
          <displayName>HSEM_RLR7</displayName>
          <description>HSEM read lock register semaphore 7</description>
          <addressOffset>0x9C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PROCID</name>
              <description>Semaphore processor ID
This field is read only by software at this address.
- On a read when the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PROCID to 0.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the PROCID of the AHB bus master that has locked the semaphore.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LOCKID</name>
              <description>Semaphore LOCKID
This field is read only by software at this address.
On a read, when the semaphore is free, the hardware sets the LOCKID to the AHB bus master ID reading the semaphore. The LOCKID of the AHB bus master locking the semaphore is read.
On a read when the semaphore is locked, this field returns the LOCKID of the AHB bus master that has locked the semaphore.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SEC</name>
              <description>Semaphore secure.
This field is read only by software at this address.
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the SEC to the valid AHB bus master security definition.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the SEC of the AHB bus master that has locked the semaphore.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Semaphore free or locked by non-secure compartment.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Semaphore locked by secure compartment.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIV</name>
              <description>Semaphore privilege
This field is read only by software at this address.
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PRIV to the valid AHB bus master privileged definition.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the PRIV of the AHB bus master that has locked the semaphore.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Semaphore free or locked by unprivileged compartment.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Semaphore locked by privileged compartment.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LOCK</name>
              <description>Lock indication
This bit is read only by software at this address. 
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and returns 1.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns 1 (the LOCKID and SEC and PRIV and PROCID reflect the already locked semaphore information).</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HSEM_RLR8</name>
          <displayName>HSEM_RLR8</displayName>
          <description>HSEM read lock register semaphore 8</description>
          <addressOffset>0xA0</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PROCID</name>
              <description>Semaphore processor ID
This field is read only by software at this address.
- On a read when the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PROCID to 0.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the PROCID of the AHB bus master that has locked the semaphore.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LOCKID</name>
              <description>Semaphore LOCKID
This field is read only by software at this address.
On a read, when the semaphore is free, the hardware sets the LOCKID to the AHB bus master ID reading the semaphore. The LOCKID of the AHB bus master locking the semaphore is read.
On a read when the semaphore is locked, this field returns the LOCKID of the AHB bus master that has locked the semaphore.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SEC</name>
              <description>Semaphore secure.
This field is read only by software at this address.
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the SEC to the valid AHB bus master security definition.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the SEC of the AHB bus master that has locked the semaphore.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Semaphore free or locked by non-secure compartment.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Semaphore locked by secure compartment.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIV</name>
              <description>Semaphore privilege
This field is read only by software at this address.
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PRIV to the valid AHB bus master privileged definition.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the PRIV of the AHB bus master that has locked the semaphore.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Semaphore free or locked by unprivileged compartment.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Semaphore locked by privileged compartment.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LOCK</name>
              <description>Lock indication
This bit is read only by software at this address. 
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and returns 1.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns 1 (the LOCKID and SEC and PRIV and PROCID reflect the already locked semaphore information).</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HSEM_RLR9</name>
          <displayName>HSEM_RLR9</displayName>
          <description>HSEM read lock register semaphore 9</description>
          <addressOffset>0xA4</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PROCID</name>
              <description>Semaphore processor ID
This field is read only by software at this address.
- On a read when the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PROCID to 0.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the PROCID of the AHB bus master that has locked the semaphore.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LOCKID</name>
              <description>Semaphore LOCKID
This field is read only by software at this address.
On a read, when the semaphore is free, the hardware sets the LOCKID to the AHB bus master ID reading the semaphore. The LOCKID of the AHB bus master locking the semaphore is read.
On a read when the semaphore is locked, this field returns the LOCKID of the AHB bus master that has locked the semaphore.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SEC</name>
              <description>Semaphore secure.
This field is read only by software at this address.
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the SEC to the valid AHB bus master security definition.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the SEC of the AHB bus master that has locked the semaphore.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Semaphore free or locked by non-secure compartment.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Semaphore locked by secure compartment.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIV</name>
              <description>Semaphore privilege
This field is read only by software at this address.
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PRIV to the valid AHB bus master privileged definition.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the PRIV of the AHB bus master that has locked the semaphore.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Semaphore free or locked by unprivileged compartment.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Semaphore locked by privileged compartment.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LOCK</name>
              <description>Lock indication
This bit is read only by software at this address. 
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and returns 1.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns 1 (the LOCKID and SEC and PRIV and PROCID reflect the already locked semaphore information).</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HSEM_RLR10</name>
          <displayName>HSEM_RLR10</displayName>
          <description>HSEM read lock register semaphore 10</description>
          <addressOffset>0xA8</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PROCID</name>
              <description>Semaphore processor ID
This field is read only by software at this address.
- On a read when the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PROCID to 0.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the PROCID of the AHB bus master that has locked the semaphore.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LOCKID</name>
              <description>Semaphore LOCKID
This field is read only by software at this address.
On a read, when the semaphore is free, the hardware sets the LOCKID to the AHB bus master ID reading the semaphore. The LOCKID of the AHB bus master locking the semaphore is read.
On a read when the semaphore is locked, this field returns the LOCKID of the AHB bus master that has locked the semaphore.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SEC</name>
              <description>Semaphore secure.
This field is read only by software at this address.
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the SEC to the valid AHB bus master security definition.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the SEC of the AHB bus master that has locked the semaphore.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Semaphore free or locked by non-secure compartment.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Semaphore locked by secure compartment.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIV</name>
              <description>Semaphore privilege
This field is read only by software at this address.
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PRIV to the valid AHB bus master privileged definition.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the PRIV of the AHB bus master that has locked the semaphore.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Semaphore free or locked by unprivileged compartment.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Semaphore locked by privileged compartment.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LOCK</name>
              <description>Lock indication
This bit is read only by software at this address. 
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and returns 1.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns 1 (the LOCKID and SEC and PRIV and PROCID reflect the already locked semaphore information).</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HSEM_RLR11</name>
          <displayName>HSEM_RLR11</displayName>
          <description>HSEM read lock register semaphore 11</description>
          <addressOffset>0xAC</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PROCID</name>
              <description>Semaphore processor ID
This field is read only by software at this address.
- On a read when the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PROCID to 0.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the PROCID of the AHB bus master that has locked the semaphore.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LOCKID</name>
              <description>Semaphore LOCKID
This field is read only by software at this address.
On a read, when the semaphore is free, the hardware sets the LOCKID to the AHB bus master ID reading the semaphore. The LOCKID of the AHB bus master locking the semaphore is read.
On a read when the semaphore is locked, this field returns the LOCKID of the AHB bus master that has locked the semaphore.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SEC</name>
              <description>Semaphore secure.
This field is read only by software at this address.
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the SEC to the valid AHB bus master security definition.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the SEC of the AHB bus master that has locked the semaphore.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Semaphore free or locked by non-secure compartment.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Semaphore locked by secure compartment.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIV</name>
              <description>Semaphore privilege
This field is read only by software at this address.
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PRIV to the valid AHB bus master privileged definition.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the PRIV of the AHB bus master that has locked the semaphore.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Semaphore free or locked by unprivileged compartment.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Semaphore locked by privileged compartment.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LOCK</name>
              <description>Lock indication
This bit is read only by software at this address. 
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and returns 1.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns 1 (the LOCKID and SEC and PRIV and PROCID reflect the already locked semaphore information).</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HSEM_RLR12</name>
          <displayName>HSEM_RLR12</displayName>
          <description>HSEM read lock register semaphore 12</description>
          <addressOffset>0xB0</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PROCID</name>
              <description>Semaphore processor ID
This field is read only by software at this address.
- On a read when the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PROCID to 0.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the PROCID of the AHB bus master that has locked the semaphore.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LOCKID</name>
              <description>Semaphore LOCKID
This field is read only by software at this address.
On a read, when the semaphore is free, the hardware sets the LOCKID to the AHB bus master ID reading the semaphore. The LOCKID of the AHB bus master locking the semaphore is read.
On a read when the semaphore is locked, this field returns the LOCKID of the AHB bus master that has locked the semaphore.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SEC</name>
              <description>Semaphore secure.
This field is read only by software at this address.
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the SEC to the valid AHB bus master security definition.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the SEC of the AHB bus master that has locked the semaphore.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Semaphore free or locked by non-secure compartment.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Semaphore locked by secure compartment.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIV</name>
              <description>Semaphore privilege
This field is read only by software at this address.
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PRIV to the valid AHB bus master privileged definition.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the PRIV of the AHB bus master that has locked the semaphore.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Semaphore free or locked by unprivileged compartment.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Semaphore locked by privileged compartment.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LOCK</name>
              <description>Lock indication
This bit is read only by software at this address. 
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and returns 1.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns 1 (the LOCKID and SEC and PRIV and PROCID reflect the already locked semaphore information).</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HSEM_RLR13</name>
          <displayName>HSEM_RLR13</displayName>
          <description>HSEM read lock register semaphore 13</description>
          <addressOffset>0xB4</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PROCID</name>
              <description>Semaphore processor ID
This field is read only by software at this address.
- On a read when the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PROCID to 0.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the PROCID of the AHB bus master that has locked the semaphore.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LOCKID</name>
              <description>Semaphore LOCKID
This field is read only by software at this address.
On a read, when the semaphore is free, the hardware sets the LOCKID to the AHB bus master ID reading the semaphore. The LOCKID of the AHB bus master locking the semaphore is read.
On a read when the semaphore is locked, this field returns the LOCKID of the AHB bus master that has locked the semaphore.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SEC</name>
              <description>Semaphore secure.
This field is read only by software at this address.
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the SEC to the valid AHB bus master security definition.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the SEC of the AHB bus master that has locked the semaphore.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Semaphore free or locked by non-secure compartment.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Semaphore locked by secure compartment.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIV</name>
              <description>Semaphore privilege
This field is read only by software at this address.
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PRIV to the valid AHB bus master privileged definition.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the PRIV of the AHB bus master that has locked the semaphore.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Semaphore free or locked by unprivileged compartment.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Semaphore locked by privileged compartment.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LOCK</name>
              <description>Lock indication
This bit is read only by software at this address. 
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and returns 1.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns 1 (the LOCKID and SEC and PRIV and PROCID reflect the already locked semaphore information).</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HSEM_RLR14</name>
          <displayName>HSEM_RLR14</displayName>
          <description>HSEM read lock register semaphore 14</description>
          <addressOffset>0xB8</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PROCID</name>
              <description>Semaphore processor ID
This field is read only by software at this address.
- On a read when the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PROCID to 0.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the PROCID of the AHB bus master that has locked the semaphore.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LOCKID</name>
              <description>Semaphore LOCKID
This field is read only by software at this address.
On a read, when the semaphore is free, the hardware sets the LOCKID to the AHB bus master ID reading the semaphore. The LOCKID of the AHB bus master locking the semaphore is read.
On a read when the semaphore is locked, this field returns the LOCKID of the AHB bus master that has locked the semaphore.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SEC</name>
              <description>Semaphore secure.
This field is read only by software at this address.
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the SEC to the valid AHB bus master security definition.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the SEC of the AHB bus master that has locked the semaphore.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Semaphore free or locked by non-secure compartment.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Semaphore locked by secure compartment.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIV</name>
              <description>Semaphore privilege
This field is read only by software at this address.
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PRIV to the valid AHB bus master privileged definition.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the PRIV of the AHB bus master that has locked the semaphore.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Semaphore free or locked by unprivileged compartment.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Semaphore locked by privileged compartment.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LOCK</name>
              <description>Lock indication
This bit is read only by software at this address. 
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and returns 1.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns 1 (the LOCKID and SEC and PRIV and PROCID reflect the already locked semaphore information).</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HSEM_RLR15</name>
          <displayName>HSEM_RLR15</displayName>
          <description>HSEM read lock register semaphore 15</description>
          <addressOffset>0xBC</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PROCID</name>
              <description>Semaphore processor ID
This field is read only by software at this address.
- On a read when the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PROCID to 0.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the PROCID of the AHB bus master that has locked the semaphore.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LOCKID</name>
              <description>Semaphore LOCKID
This field is read only by software at this address.
On a read, when the semaphore is free, the hardware sets the LOCKID to the AHB bus master ID reading the semaphore. The LOCKID of the AHB bus master locking the semaphore is read.
On a read when the semaphore is locked, this field returns the LOCKID of the AHB bus master that has locked the semaphore.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SEC</name>
              <description>Semaphore secure.
This field is read only by software at this address.
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the SEC to the valid AHB bus master security definition.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the SEC of the AHB bus master that has locked the semaphore.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Semaphore free or locked by non-secure compartment.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Semaphore locked by secure compartment.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIV</name>
              <description>Semaphore privilege
This field is read only by software at this address.
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PRIV to the valid AHB bus master privileged definition.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the PRIV of the AHB bus master that has locked the semaphore.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Semaphore free or locked by unprivileged compartment.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Semaphore locked by privileged compartment.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LOCK</name>
              <description>Lock indication
This bit is read only by software at this address. 
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and returns 1.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns 1 (the LOCKID and SEC and PRIV and PROCID reflect the already locked semaphore information).</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HSEM_IER</name>
          <displayName>HSEM_IER</displayName>
          <description>HSEM non-secure interrupt enable register</description>
          <addressOffset>0x100</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ISE</name>
              <description>Non-secure Interrupt semaphore x enable bit
This bit is read and written by software.
When semaphore x SECx is disabled, bit x can be accessed with secure and non-secure access.
When semaphore x SECx is enabled, bit x is forced to 0 and cannot be accessed, write to this bit is discarded and a read returns 0.
When semaphore x PRIVx is disabled, bit x can be accessed with privilege and unprivileged access.
When semaphore x PRIVx is enabled, bit x can be accessed only with privileged access. Unprivileged write to this bit is discarded, unprivileged read returns 0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Non-secure Interrupt generation for semaphore x disabled (masked)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Non-secure Interrupt generation for semaphore x enabled (not masked)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>HSEM_ICR</name>
          <displayName>HSEM_ICR</displayName>
          <description>HSEM non-secure interrupt clear register</description>
          <addressOffset>0x104</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ISC</name>
              <description>Non-secure Interrupt semaphore x clear bit
This bit is written by software, and is always read 0.
When semaphore x SECx is disabled, bit x can be accessed with secure and non-secure access.
When semaphore x SECx is enabled, bit x cannot be accessed, write to this bit is discarded.
When semaphore x PRIVx is disabled, bit x can be accessed with privileged and unprivileged access.
When semaphore x PRIVx is enabled, bit x can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>non-secure Interrupt semaphore x status ISFx and masked status MISFx not affected.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>non-secure Interrupt semaphore x status ISFx and masked status MISFx cleared.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>HSEM_ISR</name>
          <displayName>HSEM_ISR</displayName>
          <description>HSEM non-secure interrupt status register</description>
          <addressOffset>0x108</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ISF</name>
              <description>Interrupt semaphore x status bit before enable (mask)
This bit is set by hardware, and reset only by software. This bit is cleared by software writing the corresponding HSEM_ICR bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Interrupt semaphore x status, no interrupt pending</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Interrupt semaphore x status, interrupt pending</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>HSEM_MISR</name>
          <displayName>HSEM_MISR</displayName>
          <description>HSEM non-secure interrupt status register</description>
          <addressOffset>0x10C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MISF</name>
              <description>Masked non-secure interrupt semaphore x status bit after enable (mask)
This bit is set by hardware and read only by software. This bit is cleared by software writing the corresponding HSEM_ICR bit. This bit is read as 0 when semaphore x status is masked in HSEM_IER bit x.
When semaphore x SECx is disabled, bit x can be accessed with secure and non-secure access.
When semaphore x SECx is enabled, bit x cannot be accessed, read returns 0.
When semaphore x PRIVx is disabled, bit x can be accessed with privileged and unprivileged access.
When semaphore x PRIVx is enabled, bit x can be accessed only with privileged access. Unprivileged read returns 0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>non-secure interrupt semaphore x status after masking not pending</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>non-secure interrupt semaphore x status after masking pending</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>HSEM_SIER</name>
          <displayName>HSEM_SIER</displayName>
          <description>HSEM secure interrupt enable register</description>
          <addressOffset>0x180</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SISE</name>
              <description>Secure interrupt semaphore x enable bit
This bit is read and written by software.
When semaphore x PRIVx is disabled, bit x can be accessed with secure privilege and secure unprivileged access.
When semaphore x PRIVx is enabled, bit x can be accessed only with secure privilege access. secure unprivileged write to this bit is discarded, secure unprivileged read return 0 value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Secure interrupt generation for semaphore x is disabled (masked).</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Secure interrupt generation for semaphore x is enabled (not masked).</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>HSEM_SICR</name>
          <displayName>HSEM_SICR</displayName>
          <description>HSEM secure interrupt clear register</description>
          <addressOffset>0x184</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SISC</name>
              <description>Secure interrupt semaphore x clear bit
This bit is written by software, and is always read 0.
When semaphore x PRIVx is disabled, bit x can be accessed with secure privilege and secure unprivileged access.
When semaphore x PRIVx is enabled, bit x can be accessed only with secure privilege access. Secure unprivileged write to this bit is discarded.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Secure interrupt semaphore x status ISFx and masked status MISFx not affected.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Secure interrupt semaphore x status ISFx and masked status MISFx cleared.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>HSEM_SISR</name>
          <displayName>HSEM_SISR</displayName>
          <description>HSEM secure interrupt status register</description>
          <addressOffset>0x188</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SISF</name>
              <description>Secure interrupt semaphore x status bit before enable (mask)
This bit is set by hardware and read only by software.
Bit is cleared by software writing the corresponding HSEM_SCnICR bit x.
When semaphore x PRIVx is disabled, bit x can be accessed with secure privilege and secure unprivileged access.
When semaphore x PRIVx is enabled, bit x can be accessed only with secure privilege access. Secure unprivileged read return 0 value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Secure interrupt semaphore x status, no interrupt pending.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Secure interrupt semaphore x status, interrupt pending.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>HSEM_MSISR</name>
          <displayName>HSEM_MSISR</displayName>
          <description>HSEM secure masked interrupt status register</description>
          <addressOffset>0x18C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SMISF</name>
              <description>Secure masked interrupt semaphore x status bit after enable (mask)
This bit is set by hardware and read only by software.
Bit is cleared by software writing the corresponding HSEM_SCnICR bit x.
Bit is read as 0 when semaphore x status is masked in HSEM_SCnIER bit x.
When semaphore x PRIVx is disabled, bit x can be accessed with secure privilege and secure unprivileged access.
When semaphore x PRIVx is enabled, bit x can be accessed only with secure privilege access. Secure unprivileged read return 0 value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Secure interrupt semaphore x status after masking not pending.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Secure interrupt semaphore x status after masking pending.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>HSEM_SECCFGR</name>
          <displayName>HSEM_SECCFGR</displayName>
          <description>HSEM security configuration register</description>
          <addressOffset>0x200</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SEC</name>
              <description>Semaphore x security attribute
This bit is set and cleared by software.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Semaphore x non-security, can be accessed by both secure and non-secure processors. When unlocking semaphore x both a secure and non-secure interrupt can be generated.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Semaphore x security, can be accessed only by secure processors. When unlocking semaphore x only a secure interrupt can be generated.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>HSEM_PRIVCFGR</name>
          <displayName>HSEM_PRIVCFGR</displayName>
          <description>HSEM privilege configuration register</description>
          <addressOffset>0x210</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRIV</name>
              <description>Semaphore x privilege attribute
This bit is set and cleared by software.
When semaphore x SECx is disabled, bit x can be write accessed with secure privileged and non-secure privileged access.
When semaphore x SECx is enabled, bit x can only be write accessed with secure privilege access. Non-secure privileged write access is discarded. Both secure and non-secure read return the register bit x value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Semaphore x unprivileged, can be accessed by both privileged and unprivileged processors.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Semaphore x privileged, can be accessed only by privileged processors.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>HSEM_CR</name>
          <displayName>HSEM_CR</displayName>
          <description>HSEM clear register</description>
          <addressOffset>0x230</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LOCKID</name>
              <description>LOCKID of semaphores to be cleared
This field can be written by software and is always read 0.
This field indicates the LOCKID for which the semaphores are cleared when writing the HSEM_CR.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SEC</name>
              <description>SEC value of semaphores to be cleared.
This field can be written by software, is always read 0.
Indicates the SEC for which the CID semaphores are cleared when writing the HSEM_CR</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>PRIV</name>
              <description>PRIV value of semaphores to be cleared.
This field can be written by software, is always read 0.
Indicates the PRIV for which the CID semaphores are cleared when writing the HSEM_CR.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>KEY</name>
              <description>Semaphore clear key
This field can be written by software and is always read 0.
If this key value does not match HSEM_KEYR.KEY, semaphores are not affected.
If this key value matches HSEM_KEYR.KEY, all semaphores matching the LOCKID are cleared to the free state.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HSEM_KEYR</name>
          <displayName>HSEM_KEYR</displayName>
          <description>HSEM interrupt clear register</description>
          <addressOffset>0x234</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>KEY</name>
              <description>Semaphore clear key
This field can be written and read by software.
Key value to match when clearing semaphores.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>ICACHE</name>
      <description>Instruction cache</description>
      <groupName>ICACHE</groupName>
      <baseAddress>0x40030400</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x400</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>ICACHE</name>
        <description>Instruction cache global interrupt</description>
        <value>64</value>
      </interrupt>
      <registers>
        <register>
          <name>ICACHE_CR</name>
          <displayName>ICACHE_CR</displayName>
          <description>ICACHE control register</description>
          <addressOffset>0x000</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000004</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>enable</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>cache disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>cache enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CACHEINV</name>
              <description>cache invalidation
Set by software and cleared by hardware when the BUSYF flag is set (during cache maintenance operation). Writing 0 has no effect.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>invalidate entire cache (all cache lines valid bit = 0)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAYSEL</name>
              <description>cache associativity mode selection
This bit allows user to choose ICACHE set-associativity. It can be written by software only when cache is disabled (EN=0).</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>direct mapped cache (1-way cache)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>n-way set associative cache (reset value)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HITMEN</name>
              <description>hit monitor enable</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>cache hit monitor switched off. Stopping the monitor does not reset it.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>cache hit monitor enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MISSMEN</name>
              <description>miss monitor enable</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>cache miss monitor switched off. Stopping the monitor does not reset it.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>cache miss monitor enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HITMRST</name>
              <description>hit monitor reset</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>reset cache hit monitor</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MISSMRST</name>
              <description>miss monitor reset</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>reset cache miss monitor</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ICACHE_SR</name>
          <displayName>ICACHE_SR</displayName>
          <description>ICACHE status register</description>
          <addressOffset>0x004</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BUSYF</name>
              <description>busy flag</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>cache not busy on a CACHEINV operation</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>cache executing a full invalidate CACHEINV operation</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BSYENDF</name>
              <description>busy end flag</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>cache busy</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>full invalidate CACHEINV operation finished</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ERRF</name>
              <description>cache error flag</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>an error occurred during the operation (cacheable write)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ICACHE_IER</name>
          <displayName>ICACHE_IER</displayName>
          <description>ICACHE interrupt enable register</description>
          <addressOffset>0x008</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BSYENDIE</name>
              <description>interrupt enable on busy end
Set by software to enable an interrupt generation at the end of a cache invalidate operation.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>interrupt disabled on busy end</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>interrupt enabled on busy end</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ERRIE</name>
              <description>interrupt enable on cache error
Set by software to enable an interrupt generation in case of cache functional error (cacheable write access)</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>interrupt disabled on error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>interrupt enabled on error</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ICACHE_FCR</name>
          <displayName>ICACHE_FCR</displayName>
          <description>ICACHE flag clear register</description>
          <addressOffset>0x00C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CBSYENDF</name>
              <description>clear busy end flag
Set by software.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>clears BSYENDF flag in ICACHE_SR.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CERRF</name>
              <description>clear cache error flag
Set by software.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>clears ERRF flag in ICACHE_SR</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ICACHE_HMONR</name>
          <displayName>ICACHE_HMONR</displayName>
          <description>ICACHE hit monitor register</description>
          <addressOffset>0x010</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HITMON</name>
              <description>cache hit monitor counter</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ICACHE_MMONR</name>
          <displayName>ICACHE_MMONR</displayName>
          <description>ICACHE miss monitor register</description>
          <addressOffset>0x014</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MISSMON</name>
              <description>cache miss monitor counter</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ICACHE_CRR0</name>
          <displayName>ICACHE_CRR0</displayName>
          <description>ICACHE region 0 configuration register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000200</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BASEADDR</name>
              <description>base address for region x
This alias address is replaced by REMAPADDR field.
The only useful bits are [28:RI], where 21 less than or equal RI less than or equal 27 is the number of bits of RSIZE (see Section 18.4.7). If the programmed value has more LSBs, the useless bits are ignored.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RSIZE</name>
              <description>size for region x</description>
              <bitOffset>9</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>2Mbytes</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>4Mbytes</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>8Mbytes</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>16Mbytes</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>32Mbytes</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x6</name>
                  <description>64Mbytes</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7</name>
                  <description>128Mbytes</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>REN</name>
              <description>enable for region x</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>REMAPADDR</name>
              <description>remapped address for region x
This field replaces the alias address defined by BASEADDR field.
The only useful bits are [31:RI], where 21 less than or equal RI less than or equal 27 is the number of bits of RSIZE (see Section 18.4.7). If the programmed value has more LSBs, the useless bits are ignored.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>11</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSTSEL</name>
              <description>AHB cache master selection for region x</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no action (master1 selected by default)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>master2 selected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HBURST</name>
              <description>output burst type for region x</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>WRAP</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>INCR</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ICACHE_CRR1</name>
          <displayName>ICACHE_CRR1</displayName>
          <description>ICACHE region 1 configuration register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000200</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BASEADDR</name>
              <description>base address for region x
This alias address is replaced by REMAPADDR field.
The only useful bits are [28:RI], where 21 less than or equal RI less than or equal 27 is the number of bits of RSIZE (see Section 18.4.7). If the programmed value has more LSBs, the useless bits are ignored.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RSIZE</name>
              <description>size for region x</description>
              <bitOffset>9</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>2Mbytes</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>4Mbytes</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>8Mbytes</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>16Mbytes</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>32Mbytes</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x6</name>
                  <description>64Mbytes</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7</name>
                  <description>128Mbytes</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>REN</name>
              <description>enable for region x</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>REMAPADDR</name>
              <description>remapped address for region x
This field replaces the alias address defined by BASEADDR field.
The only useful bits are [31:RI], where 21 less than or equal RI less than or equal 27 is the number of bits of RSIZE (see Section 18.4.7). If the programmed value has more LSBs, the useless bits are ignored.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>11</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSTSEL</name>
              <description>AHB cache master selection for region x</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no action (master1 selected by default)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>master2 selected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HBURST</name>
              <description>output burst type for region x</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>WRAP</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>INCR</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ICACHE_CRR2</name>
          <displayName>ICACHE_CRR2</displayName>
          <description>ICACHE region 2 configuration register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000200</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BASEADDR</name>
              <description>base address for region x
This alias address is replaced by REMAPADDR field.
The only useful bits are [28:RI], where 21 less than or equal RI less than or equal 27 is the number of bits of RSIZE (see Section 18.4.7). If the programmed value has more LSBs, the useless bits are ignored.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RSIZE</name>
              <description>size for region x</description>
              <bitOffset>9</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>2Mbytes</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>4Mbytes</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>8Mbytes</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>16Mbytes</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>32Mbytes</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x6</name>
                  <description>64Mbytes</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7</name>
                  <description>128Mbytes</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>REN</name>
              <description>enable for region x</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>REMAPADDR</name>
              <description>remapped address for region x
This field replaces the alias address defined by BASEADDR field.
The only useful bits are [31:RI], where 21 less than or equal RI less than or equal 27 is the number of bits of RSIZE (see Section 18.4.7). If the programmed value has more LSBs, the useless bits are ignored.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>11</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSTSEL</name>
              <description>AHB cache master selection for region x</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no action (master1 selected by default)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>master2 selected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HBURST</name>
              <description>output burst type for region x</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>WRAP</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>INCR</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ICACHE_CRR3</name>
          <displayName>ICACHE_CRR3</displayName>
          <description>ICACHE region 3 configuration register</description>
          <addressOffset>0x2C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000200</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BASEADDR</name>
              <description>base address for region x
This alias address is replaced by REMAPADDR field.
The only useful bits are [28:RI], where 21 less than or equal RI less than or equal 27 is the number of bits of RSIZE (see Section 18.4.7). If the programmed value has more LSBs, the useless bits are ignored.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RSIZE</name>
              <description>size for region x</description>
              <bitOffset>9</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>2Mbytes</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>4Mbytes</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>8Mbytes</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>16Mbytes</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>32Mbytes</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x6</name>
                  <description>64Mbytes</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7</name>
                  <description>128Mbytes</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>REN</name>
              <description>enable for region x</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>REMAPADDR</name>
              <description>remapped address for region x
This field replaces the alias address defined by BASEADDR field.
The only useful bits are [31:RI], where 21 less than or equal RI less than or equal 27 is the number of bits of RSIZE (see Section 18.4.7). If the programmed value has more LSBs, the useless bits are ignored.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>11</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSTSEL</name>
              <description>AHB cache master selection for region x</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no action (master1 selected by default)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>master2 selected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HBURST</name>
              <description>output burst type for region x</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>WRAP</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>INCR</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>IWDG</name>
      <description>Independent watchdog</description>
      <groupName>IWDG</groupName>
      <baseAddress>0x40003000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x400</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>IWDG_KR</name>
          <displayName>IWDG_KR</displayName>
          <description>IWDG key register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>KEY</name>
              <description>Key value (write only, read 0x0000)
These bits must be written by software at regular intervals with the key value 0xAAAA, otherwise the watchdog generates a reset when the counter reaches 0.
Writing the key value 0x5555 to enable access to the IWDG_PR, IWDG_RLR and IWDG_WINR registers (see Section 29.4.6: Register access protection)
Writing the key value 0xCCCC starts the watchdog (except if the hardware watchdog option is selected)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IWDG_PR</name>
          <displayName>IWDG_PR</displayName>
          <description>IWDG prescaler register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PR</name>
              <description>Prescaler divider 
These bits are write access protected see Section 29.4.6: Register access protection. They are written by software to select the prescaler divider feeding the counter clock. PVU bit of the IWDG status register (IWDG_SR) must be reset in order to be able to change the prescaler divider.
Others: divider / 1024
Note: Reading this register returns the prescaler value from the VsubDD/sub voltage domain. This value may not be up to date/valid if a write operation to this register is ongoing. For this reason the value read from this register is valid only when the PVU bit in the IWDG status register (IWDG_SR) is reset.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>divider / 4</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>divider / 8</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>divider / 16</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>divider / 32</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>divider / 64</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>divider / 128</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x6</name>
                  <description>divider / 256</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7</name>
                  <description>divider / 512</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>IWDG_RLR</name>
          <displayName>IWDG_RLR</displayName>
          <description>IWDG reload register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000FFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RL</name>
              <description>Watchdog counter reload value 
These bits are write access protected see Register access protection. They are written by software to define the value to be loaded in the watchdog counter each time the value 0xAAAA is written in the IWDG key register (IWDG_KR). The watchdog counter counts down from this value. The timeout period is a function of this value and the prescaler.clock. It is not recommended to set RL[11:0] to a value lower than 2.
The RVU bit in the IWDG status register (IWDG_SR) must be reset to be able to change the reload value.
Note: Reading this register returns the reload value from the VsubDD/sub voltage domain. This value may not be up to date/valid if a write operation to this register is ongoing on it. For this reason the value read from this register is valid only when the RVU bit in the IWDG status register (IWDG_SR) is reset.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IWDG_SR</name>
          <displayName>IWDG_SR</displayName>
          <description>IWDG status register</description>
          <addressOffset>0x0C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PVU</name>
              <description>Watchdog prescaler value update
This bit is set by hardware to indicate that an update of the prescaler value is ongoing. It is reset by hardware when the prescaler update operation is completed in the VsubDD/sub voltage domain (takes up to three periods of the IWDG kernel clock iwdg_ker_ck).
The prescaler value can be updated only when PVU bit is reset.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RVU</name>
              <description>Watchdog counter reload value update
This bit is set by hardware to indicate that an update of the reload value is ongoing. It is reset by hardware when the reload value update operation is completed in the VsubDD/sub voltage domain (takes up to three periods of the IWDG kernel clock iwdg_ker_ck).
The reload value can be updated only when RVU bit is reset.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WVU</name>
              <description>Watchdog counter window value update
This bit is set by hardware to indicate that an update of the window value is ongoing. It is reset by hardware when the reload value update operation is completed in the VsubDD/sub voltage domain (takes up to three periods of the IWDG kernel clock iwdg_ker_ck).
The window value can be updated only when WVU bit is reset.
This bit is generated only if generic 'window' = 1</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>EWU</name>
              <description>Watchdog interrupt comparator value update 
This bit is set by hardware to indicate that an update of the interrupt comparator value (EWIT[11:0]) or an update of the EWIE is ongoing. It is reset by hardware when the update operation is completed in the VsubDD/sub voltage domain (takes up to three periods of the IWDG kernel clock iwdg_ker_ck).
The EWIT[11:0] and EWIE fields can be updated only when EWU bit is reset.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ONF</name>
              <description>Watchdog enable status bit
Set to '1' by hardware as soon as the IWDG is started, remains to '1' until the IWDG is reset.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>The IWDG is not activated</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The IWDG is activated and needs to be refreshed regularly by the application</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EWIF</name>
              <description>Watchdog early interrupt flag
This bit is set to '1' by hardware in order to indicate that an early interrupt is pending. This bit must be cleared by the software by writing the bit EWIC of IWDG_EWCR register to '1'.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IWDG_WINR</name>
          <displayName>IWDG_WINR</displayName>
          <description>IWDG window register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000FFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WIN</name>
              <description>Watchdog counter window value 
These bits are write access protected, see Section 29.4.6, they contain the high limit of the window value to be compared with the downcounter.
To prevent a reset, the IWDCNT downcounter must be reloaded when its value is lower than WIN[11:0]+1 and greater than 1.
The WVU bit in the IWDG status register (IWDG_SR) must be reset to be able to change the reload value.
Note: Reading this register returns the reload value from the VsubDD/sub voltage domain. This value may not be valid if a write operation to this register is ongoing. For this reason the value read from this register is valid only when the WVU bit in the IWDG status register (IWDG_SR) is reset.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IWDG_EWCR</name>
          <displayName>IWDG_EWCR</displayName>
          <description>IWDG early wakeup interrupt register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EWIT</name>
              <description>Watchdog counter window value 
These bits are write access protected (see Section 29.4.6). They are written by software to define at which position of the IWDCNT down-counter the early wakeup interrupt must be generated. The early interrupt is generated when the IWDCNT is lower or equal to EWIT[11:0] - 1.
EWIT[11:0] must be bigger than 1.
An interrupt is generated only if EWIE = 1.
The EWU bit in the IWDG status register (IWDG_SR) must be reset to be able to change the reload value.
Note: Reading this register returns the Early wakeup comparator value and the Interrupt enable bit from the VsubDD/sub voltage domain. This value may not be up to date/valid if a write operation to this register is ongoing, hence the value read from this register is valid only when the EWU bit in the IWDG status register (IWDG_SR) is reset.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EWIC</name>
              <description>Watchdog early interrupt acknowledge 
The software must write a 1 into this bit in order to acknowledge the early wakeup interrupt and to clear the EWIF flag. Writing 0 has not effect, reading this flag returns a 0.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>EWIE</name>
              <description>Watchdog early interrupt enable
Set and reset by software.
The EWU bit in the IWDG status register (IWDG_SR) must be reset to be able to change the value of this bit.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>The early interrupt interface is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The early interrupt interface is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>I2C3</name>
      <description>Inter-integrated circuit</description>
      <groupName>I2C</groupName>
      <baseAddress>0x46002800</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x400</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>I2C3_EV</name>
        <description>I2C3 event interrupt</description>
        <value>54</value>
      </interrupt>
      <interrupt>
        <name>I2C3_ER</name>
        <description>I2C3 error interrupt</description>
        <value>55</value>
      </interrupt>
      <registers>
        <register>
          <name>I2C_CR1</name>
          <displayName>I2C_CR1</displayName>
          <description>I2C control register 1</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PE</name>
              <description>Peripheral enable
Note: When PE = 0, the I2C SCL and SDA lines are released. Internal state machines and status bits are put back to their reset value. When cleared, PE must be kept low for at least 3 APB clock cycles.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Peripheral disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Peripheral enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXIE</name>
              <description>TX Interrupt enable</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Transmit (TXIS) interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Transmit (TXIS) interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXIE</name>
              <description>RX Interrupt enable</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Receive (RXNE) interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Receive (RXNE) interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADDRIE</name>
              <description>Address match Interrupt enable (slave only)</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Address match (ADDR) interrupts disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Address match (ADDR) interrupts enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NACKIE</name>
              <description>Not acknowledge received Interrupt enable</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Not acknowledge (NACKF) received interrupts disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Not acknowledge (NACKF) received interrupts enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>STOPIE</name>
              <description>Stop detection Interrupt enable</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Stop detection (STOPF) interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Stop detection (STOPF) interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TCIE</name>
              <description>Transfer Complete interrupt enable 
Note: Any of these events generate an interrupt:
Note: Transfer Complete (TC)
Note: Transfer Complete Reload (TCR)</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Transfer Complete interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Transfer Complete interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ERRIE</name>
              <description>Error interrupts enable
Note: Any of these errors generate an interrupt:
Note: Arbitration Loss (ARLO)
Note: Bus Error detection (BERR)
Note: Overrun/Underrun (OVR)
Note: Timeout detection (TIMEOUT)
Note: PEC error detection (PECERR)
Note: Alert pin event detection (ALERT)</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Error detection interrupts disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Error detection interrupts enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DNF</name>
              <description>Digital noise filter
These bits are used to configure the digital noise filter on SDA and SCL input. The digital filter, filters spikes with a length of up to DNF[3:0] * tsubI2CCLK/sub
sub.../sub
Note: If the analog filter is also enabled, the digital filter is added to the analog filter. 
Note: This filter can only be programmed when the I2C is disabled (PE = 0).</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Digital filter disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Digital filter enabled and filtering capability up to 1 tsubI2CCLK/sub</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xF</name>
                  <description>digital filter enabled and filtering capability up to15 tsubI2CCLK/sub</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ANFOFF</name>
              <description>Analog noise filter OFF
Note: This bit can only be programmed when the I2C is disabled (PE = 0).</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Analog noise filter enabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Analog noise filter disabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXDMAEN</name>
              <description>DMA transmission requests enable</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>DMA mode disabled for transmission</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>DMA mode enabled for transmission</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXDMAEN</name>
              <description>DMA reception requests enable</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>DMA mode disabled for reception</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>DMA mode enabled for reception</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SBC</name>
              <description>Slave byte control
This bit is used to enable hardware byte control in slave mode.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Slave byte control disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Slave byte control enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NOSTRETCH</name>
              <description>Clock stretching disable 
This bit is used to disable clock stretching in slave mode. It must be kept cleared in master mode.
Note: This bit can only be programmed when the I2C is disabled (PE = 0).</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Clock stretching enabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Clock stretching disabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WUPEN</name>
              <description>Wakeup from Stop mode enable
Note: If the Wakeup from Stop mode feature is not supported, this bit is reserved and forced by hardware to '0'. Refer to Section 52.3: FMPI2C implementation.
Note: WUPEN can be set only when DNF = '0000'</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Wakeup from Stop mode disable.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Wakeup from Stop mode enable.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>GCEN</name>
              <description>General call enable</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>General call disabled. Address 0b00000000 is NACKed.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>General call enabled. Address 0b00000000 is ACKed.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SMBHEN</name>
              <description>SMBus host address enable
Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to '0'. Refer to Section 52.3: FMPI2C implementation.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Host address disabled. Address 0b0001000x is NACKed.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Host address enabled. Address 0b0001000x is ACKed.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SMBDEN</name>
              <description>SMBus device default address enable
Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to '0'. Refer to Section 52.3: FMPI2C implementation.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Device default address disabled. Address 0b1100001x is NACKed.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Device default address enabled. Address 0b1100001x is ACKed.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ALERTEN</name>
              <description>SMBus alert enable
Note: When ALERTEN=0, the SMBA pin can be used as a standard GPIO.
Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to '0'. Refer to Section 52.3: FMPI2C implementation.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>The SMBus alert pin (SMBA) is not supported in host mode (SMBHEN=1). In device mode (SMBHEN=0), the SMBA pin is released and the Alert Response Address header is disabled (0001100x followed by NACK).</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The SMBus alert pin is supported in host mode (SMBHEN=1). In device mode (SMBHEN=0), the SMBA pin is driven low and the Alert Response Address header is enabled (0001100x followed by ACK).</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PECEN</name>
              <description>PEC enable
Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to '0'. Refer to Section 52.3: FMPI2C implementation.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>PEC calculation disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>PEC calculation enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FMP</name>
              <description>Fast-mode Plus 20 mA drive enable</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>20 mA I/O drive disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>20 mA I/O drive enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADDRACLR</name>
              <description>Address match flag (ADDR) automatic clear</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>ADDR flag is set by hardware and cleared by software by setting ADDRCF bit.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>ADDR flag remains cleared by hardware. This mode can be used in slave mode, to avoid the ADDR clock stretching if the I2C enables only one slave address. This allows a slave data management by DMA only, without any interrupt from peripheral.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>STOPFACLR</name>
              <description>STOP detection flag (STOPF) automatic clear</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>STOPF flag is set by hardware and cleared by software by setting STOPCF bit.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>STOPF flag remains cleared by hardware. This mode can be used in NOSTRETCH slave mode, to avoid the overrun error if the STOPF flag is not cleared before next data transmission. This allows a slave data management by DMA only, without any interrupt from peripheral.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_CR2</name>
          <displayName>I2C_CR2</displayName>
          <description>I2C control register 2</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SADD</name>
              <description>Slave address (master mode)
In 7-bit addressing mode (ADD10 = 0):
SADD[7:1] should be written with the 7-bit slave address to be sent. The bits SADD[9], SADD[8] and SADD[0] are don't care.
In 10-bit addressing mode (ADD10 = 1):
SADD[9:0] should be written with the 10-bit slave address to be sent.
Note: Changing these bits when the START bit is set is not allowed.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RD_WRN</name>
              <description>Transfer direction (master mode)
Note: Changing this bit when the START bit is set is not allowed.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Master requests a write transfer.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Master requests a read transfer.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADD10</name>
              <description>10-bit addressing mode (master mode)
Note: Changing this bit when the START bit is set is not allowed.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>The master operates in 7-bit addressing mode,</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The master operates in 10-bit addressing mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HEAD10R</name>
              <description>10-bit address header only read direction (master receiver mode)
Note: Changing this bit when the START bit is set is not allowed.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>The master sends the complete 10 bit slave address read sequence: Start + 2 bytes 10bit address in write direction + Restart + 1st 7 bits of the 10 bit address in read direction.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The master only sends the 1st 7 bits of the 10 bit address, followed by Read direction.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>START</name>
              <description>Start generation
This bit is set by software, and cleared by hardware after the Start followed by the address sequence is sent, by an arbitration loss, by an address matched in slave mode, by a timeout error detection, or when PE = 0.
If the I2C is already in master mode with AUTOEND = 0, setting this bit generates a Repeated Start condition when RELOAD=0, after the end of the NBYTES transfer. 
Otherwise setting this bit generates a START condition once the bus is free.
Note: Writing '0' to this bit has no effect.
Note: The START bit can be set even if the bus is BUSY or I2C is in slave mode.
Note: This bit has no effect when RELOAD is set.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No Start generation.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Restart/Start generation:</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>STOP</name>
              <description>Stop generation (master mode)
The bit is set by software, cleared by hardware when a STOP condition is detected, or when PE = 0.
In Master Mode:
Note: Writing '0' to this bit has no effect.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No Stop generation.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Stop generation after current byte transfer.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NACK</name>
              <description>NACK generation (slave mode)
The bit is set by software, cleared by hardware when the NACK is sent, or when a STOP condition or an Address matched is received, or when PE = 0.
Note: Writing '0' to this bit has no effect.
Note: This bit is used in slave mode only: in master receiver mode, NACK is automatically generated after last byte preceding STOP or RESTART condition, whatever the NACK bit value.
Note: When an overrun occurs in slave receiver NOSTRETCH mode, a NACK is automatically generated whatever the NACK bit value.
Note: When hardware PEC checking is enabled (PECBYTE=1), the PEC acknowledge value does not depend on the NACK value.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>an ACK is sent after current received byte.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>a NACK is sent after current received byte.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NBYTES</name>
              <description>Number of bytes
The number of bytes to be transmitted/received is programmed there. This field is don't care in slave mode with SBC=0.
Note: Changing these bits when the START bit is set is not allowed.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RELOAD</name>
              <description>NBYTES reload mode
This bit is set and cleared by software.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>The transfer is completed after the NBYTES data transfer (STOP or RESTART follows).</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The transfer is not completed after the NBYTES data transfer (NBYTES is reloaded). TCR flag is set when NBYTES data are transferred, stretching SCL low.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AUTOEND</name>
              <description>Automatic end mode (master mode)
This bit is set and cleared by software.
Note: This bit has no effect in slave mode or when the RELOAD bit is set.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>software end mode: TC flag is set when NBYTES data are transferred, stretching SCL low.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Automatic end mode: a STOP condition is automatically sent when NBYTES data are transferred.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PECBYTE</name>
              <description>Packet error checking byte
This bit is set by software, and cleared by hardware when the PEC is transferred, or when a STOP condition or an Address matched is received, also when PE = 0.
Note: Writing '0' to this bit has no effect.
Note: This bit has no effect when RELOAD is set.
Note: This bit has no effect is slave mode when SBC=0.
Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to '0'. Refer to Section 52.3: FMPI2C implementation.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No PEC transfer.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>PEC transmission/reception is requested</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_OAR1</name>
          <displayName>I2C_OAR1</displayName>
          <description>I2C own address 1 register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OA1</name>
              <description>Interface own slave address
7-bit addressing mode: OA1[7:1] contains the 7-bit own slave address. The bits OA1[9], OA1[8] and OA1[0] are don't care. 
10-bit addressing mode: OA1[9:0] contains the 10-bit own slave address.
Note: These bits can be written only when OA1EN=0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1MODE</name>
              <description>Own Address 1 10-bit mode
Note: This bit can be written only when OA1EN=0.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Own address 1 is a 7-bit address.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Own address 1 is a 10-bit address.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OA1EN</name>
              <description>Own Address 1 enable</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Own address 1 disabled. The received slave address OA1 is NACKed.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Own address 1 enabled. The received slave address OA1 is ACKed.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_OAR2</name>
          <displayName>I2C_OAR2</displayName>
          <description>I2C own address 2 register</description>
          <addressOffset>0x0C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OA2</name>
              <description>Interface address
7-bit addressing mode: 7-bit address
Note: These bits can be written only when OA2EN=0.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OA2MSK</name>
              <description>Own Address 2 masks
Note: These bits can be written only when OA2EN=0.
Note: As soon as OA2MSK is not equal to 0, the reserved I2C addresses (0b0000xxx and 0b1111xxx) are not acknowledged even if the comparison matches.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No mask</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>OA2[1] is masked and don't care. Only OA2[7:2] are compared.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>OA2[2:1] are masked and don't care. Only OA2[7:3] are compared.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>OA2[3:1] are masked and don't care. Only OA2[7:4] are compared.</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>OA2[4:1] are masked and don't care. Only OA2[7:5] are compared.</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>OA2[5:1] are masked and don't care. Only OA2[7:6] are compared.</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x6</name>
                  <description>OA2[6:1] are masked and don't care. Only OA2[7] is compared.</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7</name>
                  <description>OA2[7:1] are masked and don't care. No comparison is done, and all (except reserved) 7-bit received addresses are acknowledged.</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OA2EN</name>
              <description>Own Address 2 enable</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Own address 2 disabled. The received slave address OA2 is NACKed.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Own address 2 enabled. The received slave address OA2 is ACKed.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_TIMINGR</name>
          <displayName>I2C_TIMINGR</displayName>
          <description>I2C timing register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCLL</name>
              <description>SCL low period (master mode)
This field is used to generate the SCL low period in master mode.
tsubSCLL /sub= (SCLL+1) x tsubPRESC/sub
Note: SCLL is also used to generate tsubBUF /suband tsubSU:STA /subtimings.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SCLH</name>
              <description>SCL high period (master mode)
This field is used to generate the SCL high period in master mode.
tsubSCLH /sub= (SCLH+1) x tsubPRESC/sub
Note: SCLH is also used to generate tsubSU:STO /suband tsubHD:STA /subtiming.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SDADEL</name>
              <description>Data hold time
This field is used to generate the delay tsubSDADEL /subbetween SCL falling edge and SDA edge. In master mode and in slave mode with NOSTRETCH = 0, the SCL line is stretched low during tsubSDADEL/sub.
tsubSDADEL/sub= SDADEL x tsubPRESC/sub
Note: SDADEL is used to generate tsubHD:DAT /subtiming.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SCLDEL</name>
              <description>Data setup time
This field is used to generate a delay tsubSCLDEL /subbetween SDA edge and SCL rising edge. In master mode and in slave mode with NOSTRETCH = 0, the SCL line is stretched low during tsubSCLDEL/sub.
tsubSCLDEL /sub= (SCLDEL+1) x tsubPRESC/sub
Note: tsubSCLDEL/sub is used to generate tsubSU:DAT /subtiming.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESC</name>
              <description>Timing prescaler
This field is used to prescale i2c_ker_ck in order to generate the clock period tsubPRESC /subused for data setup and hold counters (refer to FMPI2C timings on page 1928) and for SCL high and low level counters (refer to FMPI2C master initialization on page 1951).
tsubPRESC /sub= (PRESC+1) x tsubI2CCLK/sub</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_TIMEOUTR</name>
          <displayName>I2C_TIMEOUTR</displayName>
          <description>I2C timeout register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIMEOUTA</name>
              <description>Bus Timeout A
This field is used to configure:
The SCL low timeout condition tsubTIMEOUT/sub when TIDLE=0
tsubTIMEOUT/sub= (TIMEOUTA+1) x 2048 x tsubI2CCLK/sub
The bus idle condition (both SCL and SDA high) when TIDLE=1 
tsubIDLE/sub= (TIMEOUTA+1) x 4 x tsubI2CCLK/sub
Note: These bits can be written only when TIMOUTEN=0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TIDLE</name>
              <description>Idle clock timeout detection 
Note: This bit can be written only when TIMOUTEN=0.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>TIMEOUTA is used to detect SCL low timeout</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>TIMEOUTA is used to detect both SCL and SDA high timeout (bus idle condition)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TIMOUTEN</name>
              <description>Clock timeout enable</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>SCL timeout detection is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>SCL timeout detection is enabled: when SCL is low for more than tsubTIMEOUT/sub (TIDLE=0) or high for more than tsubIDLE /sub(TIDLE=1), a timeout error is detected (TIMEOUT=1).</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TIMEOUTB</name>
              <description>Bus timeout B
This field is used to configure the cumulative clock extension timeout:
In master mode, the master cumulative clock low extend time (tsubLOW:MEXT/sub) is detected
In slave mode, the slave cumulative clock low extend time (tsubLOW:SEXT/sub) is detected
tsubLOW:EXT/sub= (TIMEOUTB+1) x 2048 x tsubI2CCLK/sub
Note: These bits can be written only when TEXTEN=0.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TEXTEN</name>
              <description>Extended clock timeout enable</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Extended clock timeout detection is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Extended clock timeout detection is enabled. When a cumulative SCL stretch for more than tsubLOW:EXT /subis done by the I2C interface, a timeout error is detected (TIMEOUT=1).</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_ISR</name>
          <displayName>I2C_ISR</displayName>
          <description>I2C interrupt and status register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXE</name>
              <description>Transmit data register empty (transmitters) 
This bit is set by hardware when the I2C_TXDR register is empty. It is cleared when the next data to be sent is written in the I2C_TXDR register. 
This bit can be written to '1' by software in order to flush the transmit data register I2C_TXDR.
Note: This bit is set by hardware when PE = 0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXIS</name>
              <description>Transmit interrupt status (transmitters) 
This bit is set by hardware when the I2C_TXDR register is empty and the data to be transmitted must be written in the I2C_TXDR register. It is cleared when the next data to be sent is written in the I2C_TXDR register. 
This bit can be written to '1' by software when NOSTRETCH = 1 only, in order to generate a TXIS event (interrupt if TXIE=1 or DMA request if TXDMAEN = 1).
Note: This bit is cleared by hardware when PE = 0.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXNE</name>
              <description>Receive data register not empty (receivers)
This bit is set by hardware when the received data is copied into the I2C_RXDR register, and is ready to be read. It is cleared when I2C_RXDR is read. 
Note: This bit is cleared by hardware when PE = 0.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ADDR</name>
              <description>Address matched (slave mode)
This bit is set by hardware as soon as the received slave address matched with one of the enabled slave addresses. It is cleared by software by setting ADDRCF bit.
Note: This bit is cleared by hardware when PE = 0.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>NACKF</name>
              <description>Not Acknowledge received flag 
This flag is set by hardware when a NACK is received after a byte transmission. It is cleared by software by setting the NACKCF bit.
Note: This bit is cleared by hardware when PE = 0.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>STOPF</name>
              <description>Stop detection flag
This flag is set by hardware when a STOP condition is detected on the bus and the peripheral is involved in this transfer:
either as a master, provided that the STOP condition is generated by the peripheral.
or as a slave, provided that the peripheral has been addressed previously during this transfer.
It is cleared by software by setting the STOPCF bit.
Note: This bit is cleared by hardware when PE = 0.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TC</name>
              <description>Transfer Complete (master mode)
This flag is set by hardware when RELOAD=0, AUTOEND=0 and NBYTES data have been transferred. It is cleared by software when START bit or STOP bit is set.
Note: This bit is cleared by hardware when PE = 0.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TCR</name>
              <description>Transfer Complete Reload
This flag is set by hardware when RELOAD=1 and NBYTES data have been transferred. It is cleared by software when NBYTES is written to a non-zero value.
Note: This bit is cleared by hardware when PE = 0.
Note: This flag is only for master mode, or for slave mode when the SBC bit is set.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BERR</name>
              <description>Bus error 
This flag is set by hardware when a misplaced Start or STOP condition is detected whereas the peripheral is involved in the transfer. The flag is not set during the address phase in slave mode. It is cleared by software by setting BERRCF bit.
Note: This bit is cleared by hardware when PE = 0.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ARLO</name>
              <description>Arbitration lost 
This flag is set by hardware in case of arbitration loss. It is cleared by software by setting the ARLOCF bit.
Note: This bit is cleared by hardware when PE = 0.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>OVR</name>
              <description>Overrun/Underrun (slave mode)
This flag is set by hardware in slave mode with NOSTRETCH = 1, when an overrun/underrun error occurs. It is cleared by software by setting the OVRCF bit.
Note: This bit is cleared by hardware when PE = 0.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PECERR</name>
              <description>PEC Error in reception
This flag is set by hardware when the received PEC does not match with the PEC register content. A NACK is automatically sent after the wrong PEC reception. It is cleared by software by setting the PECCF bit.
Note: This bit is cleared by hardware when PE = 0.
Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to '0'. Refer to Section 52.3: FMPI2C implementation.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TIMEOUT</name>
              <description>Timeout or tsubLOW/sub detection flag
This flag is set by hardware when a timeout or extended clock timeout occurred. It is cleared by software by setting the TIMEOUTCF bit.
Note: This bit is cleared by hardware when PE = 0.
Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to '0'. Refer to Section 52.3: FMPI2C implementation.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ALERT</name>
              <description>SMBus alert 
This flag is set by hardware when SMBHEN=1 (SMBus host configuration), ALERTEN=1 and a SMBALERT event (falling edge) is detected on SMBA pin. It is cleared by software by setting the ALERTCF bit.
Note: This bit is cleared by hardware when PE = 0.
Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to '0'. Refer to Section 52.3: FMPI2C implementation.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BUSY</name>
              <description>Bus busy
This flag indicates that a communication is in progress on the bus. It is set by hardware when a START condition is detected. It is cleared by hardware when a STOP condition is detected, or when PE = 0.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DIR</name>
              <description>Transfer direction (Slave mode)
This flag is updated when an address match event occurs (ADDR = 1).</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Write transfer, slave enters receiver mode.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Read transfer, slave enters transmitter mode.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADDCODE</name>
              <description>Address match code (Slave mode) 
These bits are updated with the received address when an address match event occurs (ADDR = 1).
In the case of a 10-bit address, ADDCODE provides the 10-bit header followed by the 2 MSBs of the address.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_ICR</name>
          <displayName>I2C_ICR</displayName>
          <description>I2C interrupt clear register</description>
          <addressOffset>0x1C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDRCF</name>
              <description>Address matched flag clear 
Writing 1 to this bit clears the ADDR flag in the I2C_ISR register. Writing 1 to this bit also clears the START bit in the I2C_CR2 register.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>NACKCF</name>
              <description>Not Acknowledge flag clear
Writing 1 to this bit clears the NACKF flag in I2C_ISR register.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>STOPCF</name>
              <description>STOP detection flag clear 
Writing 1 to this bit clears the STOPF flag in the I2C_ISR register.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>BERRCF</name>
              <description>Bus error flag clear
Writing 1 to this bit clears the BERRF flag in the I2C_ISR register.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ARLOCF</name>
              <description>Arbitration lost flag clear
Writing 1 to this bit clears the ARLO flag in the I2C_ISR register.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>OVRCF</name>
              <description>Overrun/Underrun flag clear
Writing 1 to this bit clears the OVR flag in the I2C_ISR register.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>PECCF</name>
              <description>PEC Error flag clear
Writing 1 to this bit clears the PECERR flag in the I2C_ISR register.
Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to '0'. Refer to Section 52.3: FMPI2C implementation.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>TIMOUTCF</name>
              <description>Timeout detection flag clear
Writing 1 to this bit clears the TIMEOUT flag in the I2C_ISR register.
Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to '0'. Refer to Section 52.3: FMPI2C implementation.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ALERTCF</name>
              <description>Alert flag clear
Writing 1 to this bit clears the ALERT flag in the I2C_ISR register.
Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to '0'. Refer to Section 52.3: FMPI2C implementation.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_PECR</name>
          <displayName>I2C_PECR</displayName>
          <description>I2C PEC register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PEC</name>
              <description>Packet error checking register
This field contains the internal PEC when PECEN=1.
The PEC is cleared by hardware when PE = 0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_RXDR</name>
          <displayName>I2C_RXDR</displayName>
          <description>I2C receive data register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXDATA</name>
              <description>8-bit receive data
Data byte received from the Isup2/supC bus</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_TXDR</name>
          <displayName>I2C_TXDR</displayName>
          <description>I2C transmit data register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXDATA</name>
              <description>8-bit transmit data
Data byte to be transmitted to the Isup2/supC bus
Note: These bits can be written only when TXE = 1.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_AUTOCR</name>
          <displayName>I2C_AUTOCR</displayName>
          <description>I2C Autonomous mode control register</description>
          <addressOffset>0x2C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TCDMAEN</name>
              <description>DMA request enable on Transfer Complete event</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>DMA request not generated on Transfer Complete event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>DMA request generated on Transfer Complete event</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TCRDMAEN</name>
              <description>DMA request enable on Transfer Complete Reload event</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>DMA request not generated on Transfer Complete Reload event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>DMA request generated on Transfer Complete Reload event</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TRIGSEL</name>
              <description>Trigger selection (refer to Section 52.4.3: FMPI2C pins and internal signals I2C interconnections tables).
...
Note: This bit can be written only when PE = 0</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>i2c_trg0 selected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>i2c_trg1 selected</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xF</name>
                  <description>i2c_trg15 selected</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TRIGPOL</name>
              <description>Trigger polarity
Note: This bit can be written only when PE = 0</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Trigger active on rising edge</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Trigger active on falling edge</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TRIGEN</name>
              <description>Trigger enable
When a trigger is detected, a START condition is sent and the transfer is launched as defined in I2C_CR2.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Trigger disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Trigger enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>LPTIM1</name>
      <description>Low power timer</description>
      <groupName>LPTIM</groupName>
      <baseAddress>0x46004400</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x400</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>LPTIM1</name>
        <description>LPTIM1 global interrupt</description>
        <value>49</value>
      </interrupt>
      <registers>
        <register>
          <name>LPTIM1_ISR_output</name>
          <displayName>LPTIM1_ISR_output</displayName>
          <description>LPTIM1 interrupt and status register [alternate]</description>
          <addressOffset>0x000</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CC1IF</name>
              <description>Compare 1 interrupt flag
If channel CC1 is configured as output:
The CC1IF flag is set by hardware to inform application that LPTIM_CNT register value matches the compare register's value. CC1IF flag can be cleared by writing 1 to the CC1CF bit in the LPTIM_ICR register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No match</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The content of the counter LPTIM_CNT register value has matched the LPTIM_CCR1 register's value</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ARRM</name>
              <description>Autoreload match
ARRM is set by hardware to inform application that LPTIM_CNT register's value reached the LPTIM_ARR register's value. ARRM flag can be cleared by writing 1 to the ARRMCF bit in the LPTIM_ICR register.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>EXTTRIG</name>
              <description>External trigger edge event
EXTTRIG is set by hardware to inform application that a valid edge on the selected external trigger input has occurred. If the trigger is ignored because the timer has already started, then this flag is not set. EXTTRIG flag can be cleared by writing 1 to the EXTTRIGCF bit in the LPTIM_ICR register.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CMP1OK</name>
              <description>Compare register 1 update OK
CMP1OK is set by hardware to inform application that the APB bus write operation to the LPTIM_CCR1 register has been successfully completed. CMP1OK flag can be cleared by writing 1 to the CMP1OKCF bit in the LPTIM_ICR register.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ARROK</name>
              <description>Autoreload register update OK
ARROK is set by hardware to inform application that the APB bus write operation to the LPTIM_ARR register has been successfully completed. ARROK flag can be cleared by writing 1 to the ARROKCF bit in the LPTIM_ICR register.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>UP</name>
              <description>Counter direction change down to up
In Encoder mode, UP bit is set by hardware to inform application that the counter direction has changed from down to up. UP flag can be cleared by writing 1 to the UPCF bit in the LPTIM_ICR register.
Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section69.3.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DOWN</name>
              <description>Counter direction change up to down
In Encoder mode, DOWN bit is set by hardware to inform application that the counter direction has changed from up to down. DOWN flag can be cleared by writing 1 to the DOWNCF bit in the LPTIM_ICR register.
Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section69.3.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>UE</name>
              <description>LPTIM update event occurred
UE is set by hardware to inform application that an update event was generated. The corresponding interrupt or DMA request is generated if enabled. UE flag can be cleared by writing 1 to the UECF bit in the LPTIM_ICR register. The UE flag is automatically cleared by hardware once the LPTIM_ARR register is written by any bus master like CPU or DMA.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>REPOK</name>
              <description>Repetition register update OK
REPOK is set by hardware to inform application that the APB bus write operation to the LPTIM_RCR register has been successfully completed. REPOK flag can be cleared by writing 1 to the REPOKCF bit in the LPTIM_ICR register.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CC2IF</name>
              <description>Compare 2 interrupt flag
If channel CC2 is configured as output:
The CC2IF flag is set by hardware to inform application that LPTIM_CNT register value matches the
compare register's value. CC2IF flag can be cleared by writing 1 to the CC2CF bit in the LPTIM_ICR register.
Note: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section69.3.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No match</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The content of the counter LPTIM_CNT register value has matched the LPTIM_CCR2 register's value</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMP2OK</name>
              <description>Compare register 2 update OK
CMP2OK is set by hardware to inform application that the APB bus write operation to the LPTIM_CCR2 register has been successfully completed. CMP2OK flag can be cleared by writing 1 to the CMP2OKCF bit in the LPTIM_ICR register.
Note: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section69.3.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DIEROK</name>
              <description>Interrupt enable register update OK
DIEROK is set by hardware to inform application that the APB bus write operation to the LPTIM_DIER register has been successfully completed. DIEROK flag can be cleared by writing 1 to the DIEROKCF bit in the LPTIM_ICR register.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LPTIM1_ISR_intput</name>
          <displayName>LPTIM1_ISR_intput</displayName>
          <description>Interrupt and Status Register (intput mode)</description>
          <alternateRegister>LPTIM1_ISR_output</alternateRegister>
          <addressOffset>0x0</addressOffset>
          <size>0x20</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>CC1IF</name>
              <description>capture 1 interrupt flag
	If channel CC1 is configured as input:
	CC1IF is set by hardware to inform application that the current value of the counter is captured in LPTIM_CCR1 register. The corresponding interrupt or DMA request is generated if enabled. The CC1OF flag is set if the CC1IF flag was already high.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No input capture occurred</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The counter value has been captured in the LPTIM_CCR1 register. (An edge has been detected on IC1 which matches the selected polarity). The CC1IF flag is automatically cleared by hardware once the captured value is read (CPU or DMA).CC1IF flag can be cleared by writing 1 to the CC1CF bit in the LPTIM_ICR register.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ARRM</name>
              <description>Autoreload match
	ARRM is set by hardware to inform application that LPTIM_CNT register's value reached the LPTIM_ARR register's value. ARRM flag can be cleared by writing 1 to the ARRMCF bit in the LPTIM_ICR register.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>EXTTRIG</name>
              <description>External trigger edge event
	EXTTRIG is set by hardware to inform application that a valid edge on the selected external trigger input has occurred. If the trigger is ignored because the timer has already started, then this flag is not set. EXTTRIG flag can be cleared by writing 1 to the EXTTRIGCF bit in the LPTIM_ICR register.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ARROK</name>
              <description>Autoreload register update OK
	ARROK is set by hardware to inform application that the APB bus write operation to the LPTIM_ARR register has been successfully completed. ARROK flag can be cleared by writing 1 to the ARROKCF bit in the LPTIM_ICR register.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>UP</name>
              <description>Counter direction change down to up
	In Encoder mode, UP bit is set by hardware to inform application that the counter direction has changed from down to up. UP flag can be cleared by writing 1 to the UPCF bit in the LPTIM_ICR register.
	Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section69.3.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DOWN</name>
              <description>Counter direction change up to down
	In Encoder mode, DOWN bit is set by hardware to inform application that the counter direction has changed from up to down. DOWN flag can be cleared by writing 1 to the DOWNCF bit in the LPTIM_ICR register.
	Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section69.3.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>UE</name>
              <description>LPTIM update event occurred
	UE is set by hardware to inform application that an update event was generated. UE flag can be cleared by writing 1 to the UECF bit in the LPTIM_ICR register.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>REPOK</name>
              <description>Repetition register update OK
	REPOK is set by hardware to inform application that the APB bus write operation to the LPTIM_RCR register has been successfully completed. REPOK flag can be cleared by writing 1 to the REPOKCF bit in the LPTIM_ICR register.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CC2IF</name>
              <description>Capture 2 interrupt flag
	If channel CC2 is configured as input:
	CC2IF is set by hardware to inform application that the current value of the counter is captured in LPTIM_CCR2 register. The corresponding interrupt or DMA request is generated if enabled. The CC2OF flag is set if the CC2IF flag was already high.
	Note: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section69.3.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No input capture occurred</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The counter value has been captured in the LPTIM_CCR2 register. (An edge has been detected on IC2 which matches the selected polarity). The CC2IF flag is automatically cleared by hardware once the captured value is read (CPU or DMA). The CC2IF flag can be cleared by writing 1 to the CC2CF bit in the LPTIM_ICR register.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CC1OF</name>
              <description>Capture 1 over-capture flag
	This flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing 1 to the CC1OCF bit in the LPTIM_ICR register.
	Note: If LPTIM does not implement at least 1 channel this bit is reserved. Refer to Section69.3.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No over-capture has been detected.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The counter value has been captured in LPTIM_CCR1 register while CC1IF flag was already set.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CC2OF</name>
              <description>Capture 2 over-capture flag
	This flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing 1 to the CC2OCF bit in the LPTIM_ICR register.
	Note: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section69.3.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No over-capture has been detected.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The counter value has been captured in LPTIM_CCR2 register while CC2IF flag was already set.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIEROK</name>
              <description>Interrupt enable register update OK
	DIEROK is set by hardware to inform application that the APB bus write operation to the LPTIM_DIER register has been successfully completed. DIEROK flag can be cleared by writing 1 to the DIEROKCF bit in the LPTIM_ICR register.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LPTIM1_ICR_output</name>
          <displayName>LPTIM1_ICR_output</displayName>
          <description>LPTIM1 interrupt clear register [alternate]</description>
          <addressOffset>0x004</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CC1CF</name>
              <description>Capture/compare 1 clear flag
Writing 1 to this bit clears the CC1IF flag in the LPTIM_ISR register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ARRMCF</name>
              <description>Autoreload match clear flag
Writing 1 to this bit clears the ARRM flag in the LPTIM_ISR register</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>EXTTRIGCF</name>
              <description>External trigger valid edge clear flag
Writing 1 to this bit clears the EXTTRIG flag in the LPTIM_ISR register</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CMP1OKCF</name>
              <description>Compare register 1 update OK clear flag
Writing 1 to this bit clears the CMP1OK flag in the LPTIM_ISR register.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ARROKCF</name>
              <description>Autoreload register update OK clear flag
Writing 1 to this bit clears the ARROK flag in the LPTIM_ISR register</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>UPCF</name>
              <description>Direction change to UP clear flag
Writing 1 to this bit clear the UP flag in the LPTIM_ISR register.
Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section69.3.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DOWNCF</name>
              <description>Direction change to down clear flag
Writing 1 to this bit clear the DOWN flag in the LPTIM_ISR register.
Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section69.3.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>UECF</name>
              <description>Update event clear flag
Writing 1 to this bit clear the UE flag in the LPTIM_ISR register.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>REPOKCF</name>
              <description>Repetition register update OK clear flag
Writing 1 to this bit clears the REPOK flag in the LPTIM_ISR register.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CC2CF</name>
              <description>Capture/compare 2 clear flag
Writing 1 to this bit clears the CC2IF flag in the LPTIM_ISR register.
Note: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section69.3.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CMP2OKCF</name>
              <description>Compare register 2 update OK clear flag
Writing 1 to this bit clears the CMP2OK flag in the LPTIM_ISR register.
Note: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section69.3.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DIEROKCF</name>
              <description>Interrupt enable register update OK clear flag
Writing 1 to this bit clears the DIEROK flag in the LPTIM_ISR register.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LPTIM1_ICR_intput</name>
          <displayName>LPTIM1_ICR_intput</displayName>
          <description>Interrupt Clear Register (intput mode)</description>
          <alternateRegister>LPTIM1_ICR_output</alternateRegister>
          <addressOffset>0x4</addressOffset>
          <size>0x20</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>CC1CF</name>
              <description>Capture/compare 1 clear flag
	Writing 1 to this bit clears the CC1IF flag in the LPTIM_ISR register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ARRMCF</name>
              <description>Autoreload match clear flag
	Writing 1 to this bit clears the ARRM flag in the LPTIM_ISR register</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>EXTTRIGCF</name>
              <description>External trigger valid edge clear flag
	Writing 1 to this bit clears the EXTTRIG flag in the LPTIM_ISR register</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ARROKCF</name>
              <description>Autoreload register update OK clear flag
	Writing 1 to this bit clears the ARROK flag in the LPTIM_ISR register</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>UPCF</name>
              <description>Direction change to UP clear flag
	Writing 1 to this bit clear the UP flag in the LPTIM_ISR register.
	Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section69.3.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DOWNCF</name>
              <description>Direction change to down clear flag
	Writing 1 to this bit clear the DOWN flag in the LPTIM_ISR register.
	Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section69.3.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>UECF</name>
              <description>Update event clear flag
	Writing 1 to this bit clear the UE flag in the LPTIM_ISR register.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>REPOKCF</name>
              <description>Repetition register update OK clear flag
	Writing 1 to this bit clears the REPOK flag in the LPTIM_ISR register.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CC2CF</name>
              <description>Capture/compare 2 clear flag
	Writing 1 to this bit clears the CC2IF flag in the LPTIM_ISR register.
	Note: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section69.3.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CC1OCF</name>
              <description>Capture/compare 1 over-capture clear flag
	Writing 1 to this bit clears the CC1OF flag in the LPTIM_ISR register.
	Note: If LPTIM does not implement at least 1 channel this bit is reserved. Refer to Section69.3.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CC2OCF</name>
              <description>Capture/compare 2 over-capture clear flag
	Writing 1 to this bit clears the CC2OF flag in the LPTIM_ISR register.
	Note: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section69.3.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DIEROKCF</name>
              <description>Interrupt enable register update OK clear flag
	Writing 1 to this bit clears the DIEROK flag in the LPTIM_ISR register.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LPTIM1_DIER_output</name>
          <displayName>LPTIM1_DIER_output</displayName>
          <description>LPTIM1 interrupt enable register [alternate]</description>
          <addressOffset>0x008</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CC1IE</name>
              <description>Capture/compare 1 interrupt enable</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Capture/compare 1 interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Capture/compare 1 interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ARRMIE</name>
              <description>Autoreload match Interrupt Enable</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>ARRM interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>ARRM interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EXTTRIGIE</name>
              <description>External trigger valid edge Interrupt Enable</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>EXTTRIG interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>EXTTRIG interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMP1OKIE</name>
              <description>Compare register 1 update OK interrupt enable</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>CMPOK register 1 interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>CMPOK register 1 interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ARROKIE</name>
              <description>Autoreload register update OK Interrupt Enable</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>ARROK interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>ARROK interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UPIE</name>
              <description>Direction change to UP Interrupt Enable
Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section69.3.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>UP interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>UP interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DOWNIE</name>
              <description>Direction change to down Interrupt Enable
Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section69.3.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>DOWN interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>DOWN interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UEIE</name>
              <description>Update event interrupt enable</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Update event interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Update event interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>REPOKIE</name>
              <description>Repetition register update OK interrupt Enable</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Repetition register update OK interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Repetition register update OK interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CC2IE</name>
              <description>Capture/compare 2 interrupt enable
Note: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section69.3.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Capture/compare 2 interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Capture/compare 2 interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMP2OKIE</name>
              <description>Compare register 2 update OK interrupt enable
Note: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section69.3.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>CMPOK register 2 interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>CMPOK register 2 interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UEDE</name>
              <description>Update event DMA request enable
Note: If LPTIM does not implement at least 1 channel this bit is reserved. Refer to Section69.3.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>UE DMA request disabled. Writing '0' to the UEDE bit resets the associated ue_dma_req signal.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>UE DMA request enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>LPTIM1_DIER_intput</name>
          <displayName>LPTIM1_DIER_intput</displayName>
          <description>LPTIM interrupt Enable Register (intput mode)</description>
          <alternateRegister>LPTIM1_DIER_output</alternateRegister>
          <addressOffset>0x8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>CC1IE</name>
              <description>Capture/compare 1 interrupt enable</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Capture/compare 1 interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Capture/compare 1 interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ARRMIE</name>
              <description>Autoreload match Interrupt Enable</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>ARRM interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>ARRM interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EXTTRIGIE</name>
              <description>External trigger valid edge Interrupt Enable</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>EXTTRIG interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>EXTTRIG interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ARROKIE</name>
              <description>Autoreload register update OK Interrupt Enable</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>ARROK interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>ARROK interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UPIE</name>
              <description>Direction change to UP Interrupt Enable
	Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section69.3.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>UP interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>UP interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DOWNIE</name>
              <description>Direction change to down Interrupt Enable
	Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section69.3.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>DOWN interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>DOWN interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UEIE</name>
              <description>Update event interrupt enable</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Update event interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Update event interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>REPOKIE</name>
              <description>Repetition register update OK interrupt Enable</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Repetition register update OK interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Repetition register update OK interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CC2IE</name>
              <description>Capture/compare 2 interrupt enable
	Note: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section69.3.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Capture/compare 2 interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Capture/compare 2 interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CC1OIE</name>
              <description>Capture/compare 1 over-capture interrupt enable
	Note: If LPTIM does not implement at least 1 channel this bit is reserved. Refer to Section69.3.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>CC1 over-capture interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>CC1 over-capture interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CC2OIE</name>
              <description>Capture/compare 2 over-capture interrupt enable
	Note: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section69.3.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>CC2 over-capture interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>CC2 over-capture interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CC1DE</name>
              <description>Capture/compare 1 DMA request enable
	Note: If LPTIM does not implement at least 1 channel this bit is reserved. Refer to Section69.3.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>CC1 DMA request disabled. Writing '0' to the CC1DE bit resets the associated ic1_dma_req signal.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>CC1 DMA request enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UEDE</name>
              <description>Update event DMA request enable 
	Note: If LPTIM does not implement at least 1 channel this bit is reserved. Refer to Section69.3.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>UE DMA request disabled. Writing '0' to the UEDE bit resets the associated ue_dma_req signal.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>UE DMA request enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CC2DE</name>
              <description>Capture/compare 2 DMA request enable
Note: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section69.3.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>CC2 DMA request disabled. Writing '0' to the CC2DE bit resets the associated ic2_dma_req signal.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>CC2 DMA request enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>LPUART1</name>
      <description>LPUART address block description</description>
      <groupName>LPUART</groupName>
      <baseAddress>0x46002400</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x34</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>LPUART1</name>
        <description>LPUART1 global interrupt</description>
        <value>48</value>
      </interrupt>
      <registers>
        <register>
          <name>LPUART_CR1</name>
          <displayName>LPUART_CR1</displayName>
          <description>LPUART control register 1</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>UE</name>
              <description>LPUART enable

When this bit is cleared, the LPUART prescalers and outputs are stopped immediately, and current operations are discarded. The configuration of the LPUART is kept, but all the status flags, in the LPUART_ISR are reset. This bit is set and cleared by software.

Note: To enter low-power mode without generating errors on the line, the TE bit must be reset before and the software must wait for the TC bit in the LPUART_ISR to be set before resetting the UE bit. 

Note: The DMA requests are also reset when UE = 0 so the DMA channel must be disabled before resetting the UE bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>LPUART prescaler and outputs disabled, low-power mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>LPUART enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UESM</name>
              <description>LPUART enable in low-power mode 

When this bit is cleared, the LPUART cannot request its kernel clock and is not functional in low-power mode.

When this bit is set, the LPUART can wake up the MCU from low-power mode.

This bit is set and cleared by software.

Note: The UESM bit must be set at the initialization phase. 

Note: If the LPUART does not support the Wakeup from low-power mode, this bit is reserved and must be kept at reset value. Refer to Section 79.3: LPUART implementation on page 4652.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>LPUART not functional in low-power mode.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>LPUART functional in low-power mode.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RE</name>
              <description>Receiver enable

This bit enables the receiver. It is set and cleared by software.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Receiver is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Receiver is enabled and begins searching for a start bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TE</name>
              <description>Transmitter enable

This bit enables the transmitter. When the Autonomous mode is not used, TE bit is set and cleared by software. When the Autonomous mode is used, TE bit becomes a status bit, which is set and cleared by hardware. 

Note: During transmission, a low pulse on the TE bit (0 followed by 1) sends a preamble (idle line) after the current word, except in Smartcard mode. In order to generate an idle character, the TE must not be immediately written to 1. To ensure the required duration, the software can poll the TEACK bit in the USART_ISR register.

Note: In Smartcard mode, when TE is set, there is a 1 bit-time delay before the transmission starts.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Transmitter is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Transmitter is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IDLEIE</name>
              <description>IDLE interrupt enable

This bit is set and cleared by software.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Interrupt is inhibited</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>An LPUART interrupt is generated whenever IDLE=1 in the LPUART_ISR register</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXFNEIE</name>
              <description>RXFIFO not empty interrupt enable

This bit is set and cleared by software.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Interrupt is inhibited</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>A LPUART interrupt is generated whenever ORE=1 or RXFNE=1 in the LPUART_ISR register</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TCIE</name>
              <description>Transmission complete interrupt enable

This bit is set and cleared by software.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Interrupt is inhibited</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>An LPUART interrupt is generated whenever TC=1 in the LPUART_ISR register</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXFNFIE</name>
              <description>TXFIFO not full interrupt enable

This bit is set and cleared by software.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Interrupt is inhibited</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>A LPUART interrupt is generated whenever TXFNF =1 in the LPUART_ISR register</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PEIE</name>
              <description>PE interrupt enable

This bit is set and cleared by software.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Interrupt is inhibited</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>An LPUART interrupt is generated whenever PE=1 in the LPUART_ISR register</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PS</name>
              <description>Parity selection

This bit selects the odd or even parity when the parity generation/detection is enabled (PCE bit set). It is set and cleared by software. The parity is selected after the current byte.

This bitfield can only be written when the LPUART is disabled (UE=0).</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Even parity</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Odd parity</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PCE</name>
              <description>Parity control enable

This bit selects the hardware parity control (generation and detection). When the parity control is enabled, the computed parity is inserted at the MSB position (9th bit if M=1; 8th bit if M=0) and parity is checked on the received data. This bit is set and cleared by software. Once it is set, PCE is active after the current byte (in reception and in transmission).

This bitfield can only be written when the LPUART is disabled (UE=0).</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Parity control disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Parity control enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAKE</name>
              <description>Receiver wakeup method

This bit determines the LPUART wakeup method from Mute mode. It is set or cleared by software.	

This bitfield can only be written when the LPUART is disabled (UE=0).</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Idle line</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Address mark</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>M0</name>
              <description>Word length

This bit is used in conjunction with bit 28 (M1) to determine the word length. It is set or cleared by software (refer to bit 28 (M1) description).

This bit can only be written when the LPUART is disabled (UE=0).</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MME</name>
              <description>Mute mode enable

This bit activates the Mute mode function of the LPUART. When set, the LPUART can switch between the active and Mute modes, as defined by the WAKE bit. It is set and cleared by software.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Receiver in Active mode permanently</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Receiver can switch between Mute mode and Active mode.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMIE</name>
              <description>Character match interrupt enable

This bit is set and cleared by software.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Interrupt is inhibited</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>A LPUART interrupt is generated when the CMF bit is set in the LPUART_ISR register.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DEDT</name>
              <description>Driver Enable deassertion time

This 5-bit value defines the time between the end of the last stop bit, in a transmitted message, and the de-activation of the DE (Driver Enable) signal.It is expressed in lpuart_ker_ck clock cycles. For more details, refer Section 79.4.14: RS232 Hardware flow control and RS485 Driver Enable.

If the LPUART_TDR register is written during the DEDT time, the new data is transmitted only when the DEDT and DEAT times have both elapsed.

This bitfield can only be written when the LPUART is disabled (UE=0).</description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DEAT</name>
              <description>Driver Enable assertion time

This 5-bit value defines the time between the activation of the DE (Driver Enable) signal and the beginning of the start bit. It is expressed in lpuart_ker_ck clock cycles. For more details, refer Section 78.5.21: RS232 Hardware flow control and RS485 Driver Enable.

This bitfield can only be written when the LPUART is disabled (UE=0).</description>
              <bitOffset>21</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>M1</name>
              <description>Word length

This bit must be used in conjunction with bit 12 (M0) to determine the word length. It is set or cleared by software.

M[1:0] = 00: 1 Start bit, 8 Data bits, n Stop bit

M[1:0] = 01: 1 Start bit, 9 Data bits, n Stop bit

M[1:0] = '10: 1 Start bit, 7 Data bits, n Stop bit

This bit can only be written when the LPUART is disabled (UE=0).

Note: In 7-bit data length mode, the Smartcard mode, LIN master mode and auto baud rate (0x7F and 0x55 frames detection) are not supported.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FIFOEN</name>
              <description>FIFO mode enable

This bit is set and cleared by software.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>FIFO mode is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>FIFO mode is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXFEIE</name>
              <description>TXFIFO empty interrupt enable

This bit is set and cleared by software.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Interrupt is inhibited</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>An LPUART interrupt is generated when TXFE=1 in the LPUART_ISR register</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXFFIE</name>
              <description>RXFIFO Full interrupt enable

This bit is set and cleared by software.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Interrupt is inhibited</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>An LPUART interrupt is generated when RXFF=1 in the LPUART_ISR register</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>LPUART_CR1_ALTERNATE1</name>
          <displayName>LPUART_CR1_ALTERNATE1</displayName>
          <description>LPUART control register 1 [alternate]</description>
          <alternateRegister>LPUART_CR1</alternateRegister>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>UE</name>
              <description>LPUART enable

When this bit is cleared, the LPUART prescalers and outputs are stopped immediately, and current operations are discarded. The configuration of the LPUART is kept, but all the status flags, in the LPUART_ISR are reset. This bit is set and cleared by software.

Note: To enter low-power mode without generating errors on the line, the TE bit must be reset before and the software must wait for the TC bit in the LPUART_ISR to be set before resetting the UE bit. 

Note: The DMA requests are also reset when UE = 0 so the DMA channel must be disabled before resetting the UE bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>LPUART prescaler and outputs disabled, low-power mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>LPUART enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UESM</name>
              <description>LPUART enable in low-power mode 

When this bit is cleared, the LPUART cannot request its kernel clock and is not functional in low-power mode.

When this bit is set, the LPUART can wake up the MCU from low-power mode.

This bit is set and cleared by software.

Note: The UESM bit must be set at the initialization phase. 

Note: If the LPUART does not support the Wakeup from low-power mode, this bit is reserved and must be kept at reset value. Refer to Section 79.3: LPUART implementation on page 4652.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>LPUART not functional in low-power mode.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>LPUART functional in low-power mode.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RE</name>
              <description>Receiver enable

This bit enables the receiver. It is set and cleared by software.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Receiver is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Receiver is enabled and begins searching for a start bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TE</name>
              <description>Transmitter enable

This bit enables the transmitter. When the Autonomous mode is disabled, TE bit is set and cleared by software. When the Autonomous mode is enabled, TE bit becomes a status bit, which is set and cleared by hardware. 

Note: During transmission, a low pulse on the TE bit (0 followed by 1) sends a preamble (idle line) after the current word, except in Smartcard mode. In order to generate an idle character, the TE must not be immediately written to 1. To ensure the required duration, the software can poll the TEACK bit in the LPUART_ISR register.

Note: In Smartcard mode, when TE is set, there is a 1 bit-time delay before the transmission starts.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Transmitter is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Transmitter is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IDLEIE</name>
              <description>IDLE interrupt enable

This bit is set and cleared by software.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Interrupt is inhibited</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>An LPUART interrupt is generated whenever IDLE=1 in the LPUART_ISR register</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXNEIE</name>
              <description>Receive data register not empty

This bit is set and cleared by software.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Interrupt is inhibited</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>A LPUART interrupt is generated whenever ORE=1 or RXNE=1 in the LPUART_ISR register</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TCIE</name>
              <description>Transmission complete interrupt enable

This bit is set and cleared by software.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Interrupt is inhibited</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>An LPUART interrupt is generated whenever TC=1 in the LPUART_ISR register</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXEIE</name>
              <description>Transmit data register empty

This bit is set and cleared by software.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Interrupt is inhibited</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>A LPUART interrupt is generated whenever TXE =1 in the LPUART_ISR register</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PEIE</name>
              <description>PE interrupt enable

This bit is set and cleared by software.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Interrupt is inhibited</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>An LPUART interrupt is generated whenever PE=1 in the LPUART_ISR register</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PS</name>
              <description>Parity selection

This bit selects the odd or even parity when the parity generation/detection is enabled (PCE bit set). It is set and cleared by software. The parity is selected after the current byte.

This bitfield can only be written when the LPUART is disabled (UE=0).</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Even parity</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Odd parity</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PCE</name>
              <description>Parity control enable

This bit selects the hardware parity control (generation and detection). When the parity control is enabled, the computed parity is inserted at the MSB position (9th bit if M=1; 8th bit if M=0) and parity is checked on the received data. This bit is set and cleared by software. Once it is set, PCE is active after the current byte (in reception and in transmission).

This bitfield can only be written when the LPUART is disabled (UE=0).</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Parity control disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Parity control enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAKE</name>
              <description>Receiver wakeup method

This bit determines the LPUART wakeup method from Mute mode. It is set or cleared by software.	

This bitfield can only be written when the LPUART is disabled (UE=0).</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Idle line</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Address mark</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>M0</name>
              <description>Word length

This bit is used in conjunction with bit 28 (M1) to determine the word length. It is set or cleared by software (refer to bit 28 (M1) description).

This bit can only be written when the LPUART is disabled (UE=0).</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MME</name>
              <description>Mute mode enable

This bit activates the Mute mode function of the LPUART. When set, the LPUART can switch between the active and Mute modes, as defined by the WAKE bit. It is set and cleared by software.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Receiver in Active mode permanently</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Receiver can switch between Mute mode and Active mode.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMIE</name>
              <description>Character match interrupt enable

This bit is set and cleared by software.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Interrupt is inhibited</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>A LPUART interrupt is generated when the CMF bit is set in the LPUART_ISR register.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DEDT</name>
              <description>Driver Enable deassertion time

This 5-bit value defines the time between the end of the last stop bit, in a transmitted message, and the de-activation of the DE (Driver Enable) signal.It is expressed in lpuart_ker_ck clock cycles. For more details, refer Section 79.4.14: RS232 Hardware flow control and RS485 Driver Enable.

If the LPUART_TDR register is written during the DEDT time, the new data is transmitted only when the DEDT and DEAT times have both elapsed.

This bitfield can only be written when the LPUART is disabled (UE=0).</description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DEAT</name>
              <description>Driver Enable assertion time

This 5-bit value defines the time between the activation of the DE (Driver Enable) signal and the beginning of the start bit. It is expressed in lpuart_ker_ck clock cycles. For more details, refer Section 78.5.21: RS232 Hardware flow control and RS485 Driver Enable.

This bitfield can only be written when the LPUART is disabled (UE=0).</description>
              <bitOffset>21</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>M1</name>
              <description>Word length

This bit must be used in conjunction with bit 12 (M0) to determine the word length. It is set or cleared by software.

M[1:0] = 00: 1 Start bit, 8 Data bits, n Stop bit

M[1:0] = 01: 1 Start bit, 9 Data bits, n Stop bit

M[1:0] = '10: 1 Start bit, 7 Data bits, n Stop bit

This bit can only be written when the LPUART is disabled (UE=0).

Note: In 7-bit data length mode, the Smartcard mode, LIN master mode and auto baud rate (0x7F and 0x55 frames detection) are not supported.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FIFOEN</name>
              <description>FIFO mode enable

This bit is set and cleared by software.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>FIFO mode is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>FIFO mode is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>LPUART_CR2</name>
          <displayName>LPUART_CR2</displayName>
          <description>LPUART control register 2</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDM7</name>
              <description>7-bit Address Detection/4-bit Address Detection

This bit is for selection between 4-bit address detection or 7-bit address detection. 

This bit can only be written when the LPUART is disabled (UE=0)

Note: In 7-bit and 9-bit data modes, the address detection is done on 6-bit and 8-bit address (ADD[5:0] and ADD[7:0]) respectively.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>4-bit address detection</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>7-bit address detection (in 8-bit data mode)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>STOP</name>
              <description>STOP bits

These bits are used for programming the stop bits.

This bitfield can only be written when the LPUART is disabled (UE=0).</description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>1 stop bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reserved.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>2 stop bits</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SWAP</name>
              <description>Swap TX/RX pins

This bit is set and cleared by software.

This bitfield can only be written when the LPUART is disabled (UE=0).</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>TX/RX pins are used as defined in standard pinout</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The TX and RX pins functions are swapped. This enables to work in the case of a cross-wired connection to another UART.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXINV</name>
              <description>RX pin active level inversion

This bit is set and cleared by software.

This enables the use of an external inverter on the RX line. 

This bitfield can only be written when the LPUART is disabled (UE=0).</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>RX pin signal works using the standard logic levels (VsubDD/sub =1/idle, Gnd=0/mark)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>RX pin signal values are inverted. ((VsubDD/sub =0/mark, Gnd=1/idle).</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXINV</name>
              <description>TX pin active level inversion

This bit is set and cleared by software.

This enables the use of an external inverter on the TX line. 

This bitfield can only be written when the LPUART is disabled (UE=0).</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>TX pin signal works using the standard logic levels (VsubDD/sub =1/idle, Gnd=0/mark)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>TX pin signal values are inverted. ((VsubDD/sub =0/mark, Gnd=1/idle).</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DATAINV</name>
              <description>Binary data inversion

This bit is set and cleared by software.

This bitfield can only be written when the LPUART is disabled (UE=0).</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Logical data from the data register are send/received in positive/direct logic. (1=H, 0=L)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Logical data from the data register are send/received in negative/inverse logic. (1=L, 0=H). The parity bit is also inverted.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MSBFIRST</name>
              <description>Most significant bit first

This bit is set and cleared by software.

This bitfield can only be written when the LPUART is disabled (UE=0).</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>data is transmitted/received with data bit 0 first, following the start bit.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>data is transmitted/received with the MSB (bit 7/8) first, following the start bit.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADD</name>
              <description>Address of the LPUART node 

These bits give the address of the LPUART node in Mute mode or a character code to be recognized in low-power or Run mode:

In Mute mode: they are used in multiprocessor communication to wakeup from Mute mode with 4-bit/7-bit address mark detection. The MSB of the character sent by the transmitter should be equal to 1. In 4-bit address mark detection, only ADD[3:0] bits are used.

In low-power mode: they are used for wake up from low-power mode on character match.

When a character, received during low-power mode, corresponds to the character programmed through ADD[7:0] bitfield, the CMF flag is set and wakes up the device from low-power mode if the corresponding interrupt is enabled by setting CMIE bit. 

In Run mode with Mute mode inactive (for example, end-of-block detection in ModBus protocol): the whole received character (8 bits) is compared to ADD[7:0] value and CMF flag is set on match. An interrupt is generated if the CMIE bit is set.

These bits can only be written when the reception is disabled (RE = 0) or when the USART is disabled (UE = 0).</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LPUART_CR3</name>
          <displayName>LPUART_CR3</displayName>
          <description>LPUART control register 3</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EIE</name>
              <description>Error interrupt enable

Error Interrupt Enable Bit is required to enable interrupt generation in case of a framing error, overrun error or noise flag (FE=1 or ORE=1 or NE=1 in the LPUART_ISR register).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Interrupt is inhibited</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>An interrupt is generated when FE=1 or ORE=1 or NE=1 in the LPUART_ISR register.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HDSEL</name>
              <description>Half-duplex selection

Selection of Single-wire Half-duplex mode 

This bit can only be written when the LPUART is disabled (UE=0).</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Half-duplex mode is not selected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Half-duplex mode is selected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DMAR</name>
              <description>DMA enable receiver

This bit is set/reset by software</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>DMA mode is enabled for reception</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>DMA mode is disabled for reception</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DMAT</name>
              <description>DMA enable transmitter

This bit is set/reset by software</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>DMA mode is enabled for transmission</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>DMA mode is disabled for transmission</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RTSE</name>
              <description>RTS enable

This bit can only be written when the LPUART is disabled (UE=0).</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>RTS hardware flow control disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>RTS output enabled, data is only requested when there is space in the receive buffer. The transmission of data is expected to cease after the current character has been transmitted. The RTS output is deasserted (pulled to 0) when data can be received.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CTSE</name>
              <description>CTS enable

This bit can only be written when the LPUART is disabled (UE=0)</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>CTS hardware flow control disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>CTS mode enabled, data is only transmitted when the CTS input is deasserted (tied to 0). If the CTS input is asserted while data is being transmitted, then the transmission is completed before stopping. If data is written into the data register while CTS is asserted, the transmission is postponed until CTS is deasserted.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CTSIE</name>
              <description>CTS interrupt enable</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Interrupt is inhibited</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>An interrupt is generated whenever CTSIF=1 in the LPUART_ISR register</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OVRDIS</name>
              <description>Overrun Disable

This bit is used to disable the receive overrun detection. 

the ORE flag is not set and the new received data overwrites the previous content of the LPUART_RDR register.

This bit can only be written when the LPUART is disabled (UE=0).

Note: This control bit enables checking the communication flow w/o reading the data.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Overrun Error Flag, ORE is set when received data is not read before receiving new data.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Overrun functionality is disabled. If new data is received while the RXNE flag is still set</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DDRE</name>
              <description>DMA Disable on Reception Error

This bit can only be written when the LPUART is disabled (UE=0).

Note: The reception errors are: parity error, framing error or noise error.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>DMA is not disabled in case of reception error. The corresponding error flag is set but RXNE is kept 0 preventing from overrun. As a consequence, the DMA request is not asserted, so the erroneous data is not transferred (no DMA request), but next correct received data is transferred.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>DMA is disabled following a reception error. The corresponding error flag is set, as well as RXNE. The DMA request is masked until the error flag is cleared. This means that the software must first disable the DMA request (DMAR = 0) or clear RXNE before clearing the error flag.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DEM</name>
              <description>Driver enable mode 

This bit enables the user to activate the external transceiver control, through the DE signal. 

This bit can only be written when the LPUART is disabled (UE=0).</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>DE function is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>DE function is enabled. The DE signal is output on the RTS pin.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DEP</name>
              <description>Driver enable polarity selection

This bit can only be written when the LPUART is disabled (UE=0).</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>DE signal is active high.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>DE signal is active low.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXFTIE</name>
              <description>TXFIFO threshold interrupt enable

This bit is set and cleared by software.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Interrupt is inhibited</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>A LPUART interrupt is generated when TXFIFO reaches the threshold programmed in TXFTCFG.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXFTCFG</name>
              <description>Receive FIFO threshold configuration

Remaining combinations: Reserved.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Receive FIFO reaches 1/8 of its depth.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Receive FIFO reaches 1/4 of its depth.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x6</name>
                  <description>Receive FIFO reaches 1/2 of its depth.</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>Receive FIFO reaches 3/4 of its depth.</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>Receive FIFO reaches 7/8 of its depth.</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>Receive FIFO becomes full.</description>
                  <value>0x5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXFTIE</name>
              <description>RXFIFO threshold interrupt enable

This bit is set and cleared by software.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Interrupt is inhibited</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>An LPUART interrupt is generated when Receive FIFO reaches the threshold programmed in RXFTCFG.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXFTCFG</name>
              <description>TXFIFO threshold configuration

Remaining combinations: Reserved.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>TXFIFO reaches 1/8 of its depth.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>TXFIFO reaches 1/4 of its depth.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x6</name>
                  <description>TXFIFO reaches 1/2 of its depth.</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>TXFIFO reaches 3/4 of its depth.</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>TXFIFO reaches 7/8 of its depth.</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>TXFIFO becomes empty.</description>
                  <value>0x5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>LPUART_BRR</name>
          <displayName>LPUART_BRR</displayName>
          <description>LPUART baud rate register</description>
          <addressOffset>0x0C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BRR</name>
              <description>LPUART baud rate division (LPUARTDIV)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>20</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LPUART_RQR</name>
          <displayName>LPUART_RQR</displayName>
          <description>LPUART request register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SBKRQ</name>
              <description>Send break request

Writing 1 to this bit sets the SBKF flag and request to send a BREAK on the line, as soon as the transmit machine is available.

Note: If the application needs to send the break character following all previously inserted data, including the ones not yet transmitted, the software should wait for the TXE flag assertion before setting the SBKRQ bit.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>MMRQ</name>
              <description>Mute mode request

Writing 1 to this bit puts the LPUART in Mute mode and resets the RWU flag.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>RXFRQ</name>
              <description>Receive data flush request

Writing 1 to this bit clears the RXNE flag. 

This enables discarding the received data without reading it, and avoid an overrun condition.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>TXFRQ</name>
              <description>Transmit data flush request

This bit is used when FIFO mode is enabled. TXFRQ bit is set to flush the whole FIFO. This sets the flag TXFE (TXFIFO empty, bit 23 in the LPUART_ISR register). 

Note: In FIFO mode, the TXFNF flag is reset during the flush request until TxFIFO is empty in order to ensure that no data are written in the data register.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LPUART_ISR</name>
          <displayName>LPUART_ISR</displayName>
          <description>LPUART interrupt and status register</description>
          <addressOffset>0x1C</addressOffset>
          <size>0x20</size>
          <access>read-only</access>
          <resetValue>0x008000C0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PE</name>
              <description>Parity error

This bit is set by hardware when a parity error occurs in Reception mode. It is cleared by software, writing 1 to the PECF in the LPUART_ICR register. 

An interrupt is generated if PEIE = 1 in the LPUART_CR1 register.

Note: This error is associated with the character in the LPUART_RDR.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No parity error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Parity error</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FE</name>
              <description>Framing error

This bit is set by hardware when a de-synchronization, excessive noise or a break character is detected. It is cleared by software, writing 1 to the FECF bit in the LPUART_ICR register.

When transmitting data in Smartcard mode, this bit is set when the maximum number of transmit attempts is reached without success (the card NACKs the data frame).

An interrupt is generated if EIE = 1 in the LPUART_CR1 register.

Note: This error is associated with the character in the LPUART_RDR.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No Framing error is detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Framing error or break character is detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NE</name>
              <description>Start bit noise detection flag

This bit is set by hardware when noise is detected on the start bit of a received frame. It is cleared by software, writing 1 to the NFCF bit in the LPUART_ICR register.

Note: This bit does not generate an interrupt as it appears at the same time as the RXFNE bit which itself generates an interrupt. An interrupt is generated when the NE flag is set during multi buffer communication if the EIE bit is set.

Note: This error is associated with the character in the LPUART_RDR.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No noise is detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Noise is detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ORE</name>
              <description>Overrun error

This bit is set by hardware when the data currently being received in the shift register is

ready to be transferred into the LPUART_RDR register while RXFF = 1. It is cleared by a software, writing 1 to the ORECF, in the LPUART_ICR register.

An interrupt is generated if RXFNEIE=1 or EIE = 1 in the LPUART_CR1 register.

Note: When this bit is set, the LPUART_RDR register content is not lost but the shift register is overwritten. An interrupt is generated if the ORE flag is set during multi buffer communication if the EIE bit is set.

Note: This bit is permanently forced to 0 (no overrun detection) when the bit OVRDIS is set in the LPUART_CR3 register.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No overrun error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Overrun error is detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IDLE</name>
              <description>Idle line detected

This bit is set by hardware when an Idle line is detected. An interrupt is generated if IDLEIE=1 in the LPUART_CR1 register. It is cleared by software, writing 1 to the IDLECF in the LPUART_ICR register. 

Note: The IDLE bit is not set again until the RXFNE bit has been set (i.e. a new idle line occurs).

Note: If Mute mode is enabled (MME=1), IDLE is set if the LPUART is not mute (RWU=0), whatever the Mute mode selected by the WAKE bit. If RWU=1, IDLE is not set.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No Idle line is detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Idle line is detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXFNE</name>
              <description>RXFIFO not empty

RXFNE bit is set by hardware when the RXFIFO is not empty, and so data can be read from the LPUART_RDR register. Every read of the LPUART_RDR frees a location in the RXFIFO. It is cleared when the RXFIFO is empty. 

The RXFNE flag can also be cleared by writing 1 to the RXFRQ in the LPUART_RQR register. 

An interrupt is generated if RXFNEIE=1 in the LPUART_CR1 register.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Data is not received</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Received data is ready to be read.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TC</name>
              <description>Transmission complete

This bit indicates that the last data written in the LPUART_TDR has been transmitted out of the shift register. The TC flag behaves as follows:

When TDN = 0, the TC flag is set when the transmission of a frame containing data is complete and when TXFE is set.

When TDN is equal to the number of data in the TXFIFO, the TC flag is set when TXFIFO is empty and TDN is reached.

When TDN is greater than the number of data in the TXFIFO, TC remains cleared until the TXFIFO is filled again to reach the programmed number of data to be transferred. 

When TDN is less than the number of data in the TXFIFO, TC is set when TDN is reached even if the TXFIFO is not empty.

An interrupt is generated if TCIE=1 in the LPUART_CR1 register.

TC bit is cleared by software by writing 1 to the TCCF in the LPUART_ICR register or by writing to the LPUART_TDR register.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TXFNF</name>
              <description>TXFIFO not full

TXFNF is set by hardware when TXFIFO is not full, and so data can be written in the LPUART_TDR. Every write in the LPUART_TDR places the data in the TXFIFO. This flag remains set until the TXFIFO is full. When the TXFIFO is full, this flag is cleared indicating that data can not be written into the LPUART_TDR. 

The TXFNF is kept reset during the flush request until TXFIFO is empty. After sending the flush request (by setting TXFRQ bit), the flag TXFNF should be checked prior to writing in TXFIFO (TXFNF and TXFE are set at the same time).

An interrupt is generated if the TXFNFIE bit =1 in the LPUART_CR1 register. 

Note: This bit is used during single buffer transmission.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Data register is full/Transmit FIFO is full.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Data register/Transmit FIFO is not full.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CTSIF</name>
              <description>CTS interrupt flag

This bit is set by hardware when the CTS input toggles, if the CTSE bit is set. It is cleared by software, by writing 1 to the CTSCF bit in the LPUART_ICR register. 

An interrupt is generated if CTSIE=1 in the LPUART_CR3 register.

Note: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No change occurred on the CTS status line</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>A change occurred on the CTS status line</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CTS</name>
              <description>CTS flag

This bit is set/reset by hardware. It is an inverted copy of the status of the CTS input pin. 

Note: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>CTS line set</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>CTS line reset</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BUSY</name>
              <description>Busy flag

This bit is set and reset by hardware. It is active when a communication is ongoing on the RX line (successful start bit detected). It is reset at the end of the reception (successful or not).</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>LPUART is idle (no reception)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reception on going</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMF</name>
              <description>Character match flag

This bit is set by hardware, when a the character defined by ADD[7:0] is received. It is cleared by software, writing 1 to the CMCF in the LPUART_ICR register. 

An interrupt is generated if CMIE=1in the LPUART_CR1 register.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No Character match detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Character match detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SBKF</name>
              <description>Send break flag

This bit indicates that a send break character was requested. It is set by software, by writing 1 to the SBKRQ bit in the LPUART_CR3 register. It is automatically reset by hardware during the stop bit of break transmission.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No break character transmitted</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Break character transmitted</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RWU</name>
              <description>Receiver wakeup from Mute mode

This bit indicates if the LPUART is in Mute mode. It is cleared/set by hardware when a wakeup/mute sequence is recognized. The Mute mode control sequence (address or IDLE) is selected by the WAKE bit in the LPUART_CR1 register.

When wakeup on IDLE mode is selected, this bit can only be set by software, writing 1 to the MMRQ bit in the LPUART_RQR register. 

Note: If the LPUART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Receiver in Active mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Receiver in Mute mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TEACK</name>
              <description>Transmit enable acknowledge flag 

This bit is set/reset by hardware, when the Transmit Enable value is taken into account by the LPUART. 

It can be used when an idle frame request is generated by writing TE=0, followed by TE=1 in the LPUART_CR1 register, in order to respect the TE=0 minimum period.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>REACK</name>
              <description>Receive enable acknowledge flag 

This bit is set/reset by hardware, when the Receive Enable value is taken into account by the LPUART. 

It can be used to verify that the LPUART is ready for reception before entering low-power mode.

Note: If the LPUART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TXFE</name>
              <description>TXFIFO Empty

This bit is set by hardware when TXFIFO is Empty. When the TXFIFO contains at least one data, this flag is cleared. The TXFE flag can also be set by writing 1 to the bit TXFRQ (bit 4) in the LPUART_RQR register.

An interrupt is generated if the TXFEIE bit =1 (bit 30) in the LPUART_CR1 register.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>TXFIFO is not empty.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>TXFIFO is empty.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXFF</name>
              <description>RXFIFO Full

This bit is set by hardware when the number of received data corresponds to RXFIFO size + 1 (RXFIFO full + 1 data in the LPUART_RDR register. 

An interrupt is generated if the RXFFIE bit =1 in the LPUART_CR1 register.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>RXFIFO is not Full.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>RXFIFO is Full.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXFT</name>
              <description>RXFIFO threshold flag

This bit is set by hardware when the RXFIFO reaches the threshold programmed in RXFTCFG in LPUART_CR3 register i.e. the Receive FIFO contains RXFTCFG data. An interrupt is generated if the RXFTIE bit =1 (bit 27) in the LPUART_CR3 register.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Receive FIFO does not reach the programmed threshold.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Receive FIFO reached the programmed threshold.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXFT</name>
              <description>TXFIFO threshold flag

This bit is set by hardware when the TXFIFO reaches the threshold programmed in TXFTCFG in LPUART_CR3 register i.e. the TXFIFO contains TXFTCFG empty locations. An interrupt is generated if the TXFTIE bit =1 (bit 31) in the LPUART_CR3 register.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>TXFIFO does not reach the programmed threshold.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>TXFIFO reached the programmed threshold.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>LPUART_ISR_ALTERNATE1</name>
          <displayName>LPUART_ISR_ALTERNATE1</displayName>
          <description>LPUART interrupt and status register [alternate]</description>
          <alternateRegister>LPUART_ISR</alternateRegister>
          <addressOffset>0x1C</addressOffset>
          <size>0x20</size>
          <access>read-only</access>
          <resetValue>0x000000C0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PE</name>
              <description>Parity error

This bit is set by hardware when a parity error occurs in Reception mode. It is cleared by software, writing 1 to the PECF in the LPUART_ICR register. 

An interrupt is generated if PEIE = 1 in the LPUART_CR1 register.

Note: In FIFO mode, this error is associated with the character in the LPUART_RDR.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No parity error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Parity error</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FE</name>
              <description>Framing error

This bit is set by hardware when a de-synchronization, excessive noise or a break character is detected. It is cleared by software, writing 1 to the FECF bit in the LPUART_ICR register.

When transmitting data in Smartcard mode, this bit is set when the maximum number of transmit attempts is reached without success (the card NACKs the data frame).

An interrupt is generated if EIE = 1 in the LPUART_CR1 register.

Note: In FIFO mode, this error is associated with the character in the LPUART_RDR.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No Framing error is detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Framing error or break character is detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NE</name>
              <description>Start bit noise detection flag

This bit is set by hardware when noise is detected on the start bit of a received frame. It is cleared by software, writing 1 to the NFCF bit in the LPUART_ICR register.

Note: This bit does not generate an interrupt as it appears at the same time as the RXNE/RXFNE bit which itself generates an interrupt. An interrupt is generated when the NE flag is set during multi buffer communication if the EIE bit is set.

Note: In FIFO mode, this error is associated with the character in the LPUART_RDR.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No noise is detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Noise is detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ORE</name>
              <description>Overrun error

This bit is set by hardware when the data currently being received in the shift register is

ready to be transferred into the LPUART_RDR register while RXNE=1 (RXFF = 1 in case FIFO mode is enabled). It is cleared by a software, writing 1 to the ORECF, in the LPUART_ICR register.

An interrupt is generated if RXNEIE=1 or EIE = 1 in the LPUART_CR1 register.

Note: When this bit is set, the LPUART_RDR register content is not lost but the shift register is overwritten. An interrupt is generated if the ORE flag is set during multi buffer communication if the EIE bit is set.

Note: This bit is permanently forced to 0 (no overrun detection) when the bit OVRDIS is set in the LPUART_CR3 register.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No overrun error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Overrun error is detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IDLE</name>
              <description>Idle line detected

This bit is set by hardware when an Idle Line is detected. An interrupt is generated if IDLEIE=1 in the LPUART_CR1 register. It is cleared by software, writing 1 to the IDLECF in the LPUART_ICR register. 

Note: The IDLE bit is not set again until the RXNE bit has been set (i.e. a new idle line occurs).

Note: If Mute mode is enabled (MME=1), IDLE is set if the LPUART is not mute (RWU=0), whatever the Mute mode selected by the WAKE bit. If RWU=1, IDLE is not set.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No Idle line is detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Idle line is detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXNE</name>
              <description>Read data register not empty

RXNE bit is set by hardware when the content of the LPUART_RDR shift register has been transferred to the LPUART_RDR register. It is cleared by a read to the LPUART_RDR register. The

RXNE flag can also be cleared by writing 1 to the RXFRQ in the LPUART_RQR register.

The RXFNE flag can also be cleared by writing 1 to the RXFRQ in the LPUART_RQR register. 

An interrupt is generated if RXNEIE=1 in the LPUART_CR1 register.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Data is not received</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Received data is ready to be read.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TC</name>
              <description>Transmission complete

This bit indicates that the last data written in the USART_TDR has been transmitted out of the shift register. The TC flag is set when the transmission of a frame containing data is complete and when TXE is set.

An interrupt is generated if TCIE=1 in the USART_CR1 register.

TC bit is cleared by software by writing 1 to the TCCF in the USART_ICR register or by writing to the USART_TDR register.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TXE</name>
              <description>Transmit data register empty

TXE is set by hardware when the content of the LPUART_TDR register has been transferred into the shift register. It is cleared by a write to the LPUART_TDR register. 

An interrupt is generated if the TXEIE bit =1 in the LPUART_CR1 register. 

Note: This bit is used during single buffer transmission.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Data register is full/Transmit FIFO is full.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Data register/Transmit FIFO is not full.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CTSIF</name>
              <description>CTS interrupt flag

This bit is set by hardware when the CTS input toggles, if the CTSE bit is set. It is cleared by software, by writing 1 to the CTSCF bit in the LPUART_ICR register. 

An interrupt is generated if CTSIE=1 in the LPUART_CR3 register.

Note: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No change occurred on the CTS status line</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>A change occurred on the CTS status line</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CTS</name>
              <description>CTS flag

This bit is set/reset by hardware. It is an inverted copy of the status of the CTS input pin. 

Note: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>CTS line set</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>CTS line reset</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BUSY</name>
              <description>Busy flag

This bit is set and reset by hardware. It is active when a communication is ongoing on the RX line (successful start bit detected). It is reset at the end of the reception (successful or not).</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>LPUART is idle (no reception)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reception on going</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMF</name>
              <description>Character match flag

This bit is set by hardware, when a the character defined by ADD[7:0] is received. It is cleared by software, writing 1 to the CMCF in the LPUART_ICR register. 

An interrupt is generated if CMIE=1in the LPUART_CR1 register.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No Character match detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Character match detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SBKF</name>
              <description>Send break flag

This bit indicates that a send break character was requested. It is set by software, by writing 1 to the SBKRQ bit in the LPUART_CR3 register. It is automatically reset by hardware during the stop bit of break transmission.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No break character transmitted</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Break character transmitted</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RWU</name>
              <description>Receiver wakeup from Mute mode

This bit indicates if the LPUART is in Mute mode. It is cleared/set by hardware when a wakeup/mute sequence is recognized. The Mute mode control sequence (address or IDLE) is selected by the WAKE bit in the LPUART_CR1 register.

When wakeup on IDLE mode is selected, this bit can only be set by software, writing 1 to the MMRQ bit in the LPUART_RQR register. 

Note: If the LPUART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Receiver in Active mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Receiver in Mute mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TEACK</name>
              <description>Transmit enable acknowledge flag 

This bit is set/reset by hardware, when the Transmit Enable value is taken into account by the LPUART. 

It can be used when an idle frame request is generated by writing TE=0, followed by TE=1 in the LPUART_CR1 register, in order to respect the TE=0 minimum period.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>REACK</name>
              <description>Receive enable acknowledge flag 

This bit is set/reset by hardware, when the Receive Enable value is taken into account by the LPUART. 

It can be used to verify that the LPUART is ready for reception before entering low-power mode.

Note: If the LPUART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LPUART_ICR</name>
          <displayName>LPUART_ICR</displayName>
          <description>LPUART interrupt flag clear register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PECF</name>
              <description>Parity error clear flag

Writing 1 to this bit clears the PE flag in the LPUART_ISR register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>FECF</name>
              <description>Framing error clear flag

Writing 1 to this bit clears the FE flag in the LPUART_ISR register.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>NECF</name>
              <description>Noise detected clear flag

Writing 1 to this bit clears the NE flag in the LPUART_ISR register.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ORECF</name>
              <description>Overrun error clear flag

Writing 1 to this bit clears the ORE flag in the LPUART_ISR register.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>IDLECF</name>
              <description>Idle line detected clear flag

Writing 1 to this bit clears the IDLE flag in the LPUART_ISR register.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>TCCF</name>
              <description>Transmission complete clear flag

Writing 1 to this bit clears the TC flag in the LPUART_ISR register.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CTSCF</name>
              <description>CTS clear flag

Writing 1 to this bit clears the CTSIF flag in the LPUART_ISR register.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CMCF</name>
              <description>Character match clear flag

Writing 1 to this bit clears the CMF flag in the LPUART_ISR register.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LPUART_RDR</name>
          <displayName>LPUART_RDR</displayName>
          <description>LPUART receive data register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDR</name>
              <description>Receive data value

Contains the received data character.

The RDR register provides the parallel interface between the input shift register and the internal bus (see Figure 952).

When receiving with the parity enabled, the value read in the MSB bit is the received parity bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LPUART_TDR</name>
          <displayName>LPUART_TDR</displayName>
          <description>LPUART transmit data register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TDR</name>
              <description>Transmit data value

Contains the data character to be transmitted.

The TDR register provides the parallel interface between the internal bus and the output shift register (see Figure 952).

When transmitting with the parity enabled (PCE bit set to 1 in the LPUART_CR1 register), the value written in the MSB (bit 7 or bit 8 depending on the data length) has no effect because it is replaced by the parity.

Note: This register must be written only when TXE/TXFNF=1.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LPUART_PRESC</name>
          <displayName>LPUART_PRESC</displayName>
          <description>LPUART prescaler register</description>
          <addressOffset>0x2C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRESCALER</name>
              <description>Clock prescaler

The LPUART input clock can be divided by a prescaler:

Remaining combinations: Reserved.

Note: When PRESCALER is programmed with a value different of the allowed ones, programmed prescaler value is equal to 1011 i.e. input clock divided by 256.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>input clock not divided</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>input clock divided by 2</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>input clock divided by 4</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>input clock divided by 6</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>input clock divided by 8</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>input clock divided by 10</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x6</name>
                  <description>input clock divided by 12</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7</name>
                  <description>input clock divided by 16</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x8</name>
                  <description>input clock divided by 32</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x9</name>
                  <description>input clock divided by 64</description>
                  <value>0x9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xA</name>
                  <description>input clock divided by 128</description>
                  <value>0xA</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xB</name>
                  <description>input clock divided by 256</description>
                  <value>0xB</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>LPUART_AUTOCR</name>
          <displayName>LPUART_AUTOCR</displayName>
          <description>LPUART Autonomous mode control register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x80000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TDN</name>
              <description>TDC transmission data number

This bitfield enables the programming of the number of data to be transmitted. It can be written only when UE is cleared in LPUART_CR1.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIGPOL</name>
              <description>Trigger polarity bit

This bitfield can be written only when the UE bit is cleared in LPUART_CR1 register.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Trigger active on rising edge</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Trigger active on falling edge</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TRIGEN</name>
              <description>Trigger enable bit 

Note: This bitfield can be written only when the UE bit of USART_CR1 register is cleared. 

Note: When a trigger is detected, TE is set to 1 in LPUART_CR1 and the data transfer is launched.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Trigger disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Trigger enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IDLEDIS</name>
              <description>Idle frame transmission disable bit after enabling the transmitter

Note: This bitfield can be written only when the UE bit of USART_CR1 register is cleared.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Idle frame sent after enabling the transmitter (TE = 1 in LPUART_CR1)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Idle frame not sent after enabling the transmitter</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TRIGSEL</name>
              <description>Trigger selection bits 

Refer to Section : Description LPUART interconnections.

This bitfield can be written only when the UE bit is cleared in LPUART_CR1 register.

...

Note: This bitfield can be written only when the UE bit of USART_CR1 register is cleared.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>lpuart_trg0 selected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>lpuart_trg1 selected</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xF</name>
                  <description>lpuart_trg15 selected</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PKA</name>
      <description>Private key accelerator</description>
      <groupName>PKA</groupName>
      <baseAddress>0x420C2000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x2000</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>PKA</name>
        <description>PKA global interrupt</description>
        <value>62</value>
      </interrupt>
      <registers>
        <register>
          <name>PKA_CR</name>
          <displayName>PKA_CR</displayName>
          <description>PKA control register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>PKA enable.
When an illegal operation is selected while EN=1 OPERRF bit is set in PKA_SR. See PKA_CR.MODE bitfield for details.
Note: When EN=0 PKA RAM can still be accessed by the application.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Disable PKA</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Enable PKA.PKA becomes functional when INITOK is set by hardware in PKA_SR.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>START</name>
              <description>start the operation
Writing 1 to this bit starts the operation which is selected by MODE[5:0], using the operands and data already written to the PKA RAM. This bit is always read as 0.
When an illegal operation is selected while START bit is set no operation is started, and OPERRF bit is set in PKA_SR.
Note: START is ignored if PKA is busy.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>PKA operation code
When an operation not listed here is written by the application with EN bit set, OPERRF bit is set in PKA_SR register, and the write to MODE bitfield is ignored. When PKA is configured in limited mode (LMF = 1 in PKA_SR), writing a MODE different from 0x26 with EN bit to 1 triggers OPERRF bit to be set and write to MODE bit is ignored.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Montgomery parameter computation then modular exponentiation</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Montgomery parameter computation only</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>Modular exponentiation only (Montgomery parameter must be loaded first)</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>Modular exponentiation (protected, used when manipulating secrets)</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x20</name>
                  <description>Montgomery parameter computation then ECC scalar multiplication</description>
                  <value>0x20</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x24</name>
                  <description>ECDSA sign</description>
                  <value>0x24</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x26</name>
                  <description>ECDSA verification</description>
                  <value>0x26</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x28</name>
                  <description>Point on elliptic curve Fp check</description>
                  <value>0x28</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7</name>
                  <description>RSA CRT exponentiation</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x8</name>
                  <description>Modular inversion</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x9</name>
                  <description>Arithmetic addition</description>
                  <value>0x9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xA</name>
                  <description>Arithmetic subtraction</description>
                  <value>0xA</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xB</name>
                  <description>Arithmetic multiplication</description>
                  <value>0xB</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xC</name>
                  <description>Arithmetic comparison</description>
                  <value>0xC</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xD</name>
                  <description>Modular reduction</description>
                  <value>0xD</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xE</name>
                  <description>Modular addition</description>
                  <value>0xE</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xF</name>
                  <description>Modular subtraction</description>
                  <value>0xF</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x10</name>
                  <description>Montgomery multiplication</description>
                  <value>0x10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x23</name>
                  <description>ECC complete addition</description>
                  <value>0x23</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x27</name>
                  <description>ECC double base ladder</description>
                  <value>0x27</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2F</name>
                  <description>ECC projective to affine</description>
                  <value>0x2F</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PROCENDIE</name>
              <description>End of operation interrupt enable</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No interrupt is generated when PROCENDF flag is set in PKA_SR.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>An interrupt is generated when PROCENDF flag is set in PKA_SR.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RAMERRIE</name>
              <description>RAM error interrupt enable</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No interrupt is generated when RAMERRF flag is set in PKA_SR.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>An interrupt is generated when RAMERRF flag is set in PKA_SR.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADDRERRIE</name>
              <description>Address error interrupt enable</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No interrupt is generated when ADDRERRF flag is set in PKA_SR.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>An interrupt is generated when ADDRERRF flag is set in PKA_SR.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OPERRIE</name>
              <description>Operation error interrupt enable</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No interrupt is generated when OPERRF flag is set in PKA_SR.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>An interrupt is generated when OPERRF flag is set in PKA_SR.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PKA_SR</name>
          <displayName>PKA_SR</displayName>
          <description>PKA status register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INITOK</name>
              <description>PKA initialization OK
This bit is asserted when PKA initialization is complete. When RNG is not able to output proper random numbers INITOK stays at 0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>PKA is not initialized correctly. START bit cannot be set.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>PKA is initialized correctly and can be used normally.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LMF</name>
              <description>Limited mode flag
This bit is updated when EN bit in PKA_CR is set</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>All values documented in MODE bitfield can be used.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Only ECDSA verification (MODE = 0x26) is supported by the PKA.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BUSY</name>
              <description>PKA operation is in progress
This bit is set to 1 whenever START bit in the PKA_CR is set. It is automatically cleared when the computation is complete, meaning that PKA RAM can be safely accessed and a new operation can be started.
If PKA is started with a wrong opcode, it is busy for a couple of cycles, then it aborts automatically the operation and go back to ready (BUSY bit is set to 0).</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No operation is in progress (default)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>An operation is in progress</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PROCENDF</name>
              <description>PKA End of Operation flag</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Operation in progress</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>PKA operation is completed. This flag is set when the BUSY bit is deasserted.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RAMERRF</name>
              <description>PKA RAM error flag
This bit is cleared using RAMERRFC bit in PKA_CLRFR.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No PKA RAM access error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>An AHB access to the PKA RAM occurred while the PKA core was computing and using its internal RAM (AHB PKA_RAM access are not allowed while PKA operation is in progress).</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADDRERRF</name>
              <description>Address error flag
This bit is cleared using ADDRERRFC bit in PKA_CLRFR.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No address error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Address access is out of range (unmapped address)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OPERRF</name>
              <description>Operation error flag
This bit is cleared using OPERRFC bit in PKA_CLRFR.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No event error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>An illegal or unknown operation has been selected in PKA_CR register</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PKA_CLRFR</name>
          <displayName>PKA_CLRFR</displayName>
          <description>PKA clear flag register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PROCENDFC</name>
              <description>Clear PKA End of Operation flag</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Clear the PROCENDF flag in PKA_SR</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RAMERRFC</name>
              <description>Clear PKA RAM error flag</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Clear the RAMERRF flag in PKA_SR</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADDRERRFC</name>
              <description>Clear address error flag</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Clear the ADDRERRF flag in PKA_SR</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OPERRFC</name>
              <description>Clear operation error flag</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Clear the OPERRF flag in PKA_SR</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PWR</name>
      <description>Power control</description>
      <groupName>PWR</groupName>
      <baseAddress>0x46020800</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x400</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>WKUP</name>
        <description>PWR global WKUP pin interrupt</description>
        <value>67</value>
      </interrupt>
      <registers>
        <register>
          <name>PWR_CR1</name>
          <displayName>PWR_CR1</displayName>
          <description>PWR control register 1</description>
          <addressOffset>0x000</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LPMS</name>
              <description>Low-power mode selection
These bits select the low-power mode entered when the CPU enters the SleepDeep mode.
10x: Standby mode
others reserved</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Stop 0 mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Stop 1 mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>R2RSB1</name>
              <description>SRAM2 retention in Standby mode
This bit is used to keep the SRAM2 content in Standby retention mode.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>SRAM2 content not retained in Standby mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>SRAM2 content retained in Standby mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ULPMEN</name>
              <description>BOR0 ultra-low-power mode. 
This bit is used to reduce the consumption by configuring the BOR0 in discontinuous mode for Stop 1 and Standby modes. Discontinuous mode is only available when BOR levels 1 to 4 and PVD are disabled.
Note: This bit must be set to reach the lowest power consumption in the low-power modes.
Note: This bit must not be set together with autonomous peripherals using HSI16 as kernel clock.
Note: When BOR level 1 to 4 or PVD is enabled continuous mode applies independent from ULPMEN.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>BOR0 operating in continuous (normal) mode in all operating modes</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>BOR0 operating in discontinuous (ultra-low-power) mode in Stop 1 and Standby modes.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RADIORSB</name>
              <description>2.4 GHz RADIO SRAMs (RXTXRAM and Sequence RAM) and Sleep clock retention in Standby mode.
This bit is used to keep the 2.4 GHz RADIO SRAMs content in Standby retention mode and the 2.4 GHz RADIO sleep timer counter operational.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>2.4 GHz RADIO SRAMs and sleep timer content not retained in Standby mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>2.4 GHz RADIO SRAMs and sleep timer content retained in Standby mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>R1RSB1</name>
              <description>SRAM1 retention in Standby mode
This bit is used to keep the SRAM1 content in Standby retention mode.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>SRAM1 content not retained in Standby mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>SRAM1 content retained in Standby mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_CR2</name>
          <displayName>PWR_CR2</displayName>
          <description>PWR control register 2</description>
          <addressOffset>0x004</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SRAM1PDS1</name>
              <description>SRAM1 power-down in Stop modes (Stop 0, 1)
Note: The SRAM1 retention in Standby mode is controlled by R1RSB1 bit in PWR_CR1.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>SRAM1 content retained in Stop modes</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>SRAM1 content lost in Stop modes</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRAM2PDS1</name>
              <description>SRAM2 power-down in Stop modes (Stop 0, 1)
Note: The SRAM2 retention in Standby mode is controlled by R2RSB1 bit in PWR_CR1.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>SRAM2 content retained in Stop modes</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>SRAM2 content lost in Stop modes</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ICRAMPDS</name>
              <description>ICACHE SRAM power-down in Stop modes (Stop 0, 1)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>ICACHE SRAM content retained in Stop modes</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>ICACHE SRAM content lost in Stop modes</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FLASHFWU</name>
              <description>Flash memory fast wakeup from Stop modes (Stop 0, 1)
This bit is used to obtain the best trade-off between low-power consumption and wakeup time when exiting the Stop 0 or Stop 1 modes.
When this bit is set, the Flash memory remains in normal mode in Stop 0 and Stop 1 modes, which offers a faster startup time with higher consumption.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Flash memory enters low-power mode in Stop 0 and Stop 1 modes (lower-power consumption).</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Flash memory remains in normal mode in Stop 0 and Stop 1 modes (faster wakeup time).</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_CR3</name>
          <displayName>PWR_CR3</displayName>
          <description>PWR control register 3</description>
          <addressOffset>0x008</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REGSEL</name>
              <description>Regulator selection</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FSTEN</name>
              <description>Fast soft start</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>LDO fast startup disabled (limited inrush current)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>LDO fast startup enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_VOSR</name>
          <displayName>PWR_VOSR</displayName>
          <description>PWR voltage scaling register</description>
          <addressOffset>0x00C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00008000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VOSRDY</name>
              <description>Ready bit for VsubCORE/sub voltage scaling output selection
Set and cleared by hardware. When decreasing the voltage scaling range, VOSRDY must be one before increasing the SYSCLK frequency.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Not ready, voltage level  VOS selected level</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Ready, voltage level greater than or equal VOS selected level</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VOS</name>
              <description>Voltage scaling range selection
Set a and cleared by software.
Cleared by hardware when entering Stop 1 mode.
Access can be secured by RCC SYSCLKSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Range 2 (lowest power)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Range 1 (highest frequency).</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_SVMCR</name>
          <displayName>PWR_SVMCR</displayName>
          <description>PWR supply voltage monitoring control register</description>
          <addressOffset>0x010</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PVDE</name>
              <description>Programmable voltage detector enable</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Programmable voltage detector disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Programmable voltage detector enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PVDLS</name>
              <description>Programmable voltage detector level selection
These bits select the voltage threshold detected by the programmable voltage detector:</description>
              <bitOffset>5</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>VsubPVD0/sub ~ 2.0 V</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>VsubPVD1/sub ~ 2.2 V</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>VsubPVD2/sub ~ 2.4 V</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>VsubPVD3/sub ~ 2.5 V</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>VsubPVD4/sub ~ 2.6 V</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>VsubPVD5/sub ~ 2.8 V</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x6</name>
                  <description>VsubPVD6/sub ~ 2.9 V</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7</name>
                  <description>External input analog voltage PVD_IN (compared internally to VREFINT), The I/O used as PVD_IN input, must be configured in analog mode in the GPIO register.</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_WUCR1</name>
          <displayName>PWR_WUCR1</displayName>
          <description>PWR wakeup control register 1</description>
          <addressOffset>0x014</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WUPEN1</name>
              <description>Wakeup and interrupt pin WKUP1 enable
Access can be secured by PWR WUP1SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Wakeup and interrupt pin WKUP1 disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Wakeup and interrupt pin WKUP1 enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WUPEN2</name>
              <description>Wakeup and interrupt pin WKUP2 enable
Access can be secured by PWR WUP2SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Wakeup and interrupt pin WKUP2 disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Wakeup and interrupt pin WKUP2 enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WUPEN3</name>
              <description>Wakeup and interrupt pin WKUP3 enable
Access can be secured by PWR WUP3SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Wakeup and interrupt pin WKUP3 disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Wakeup and interrupt pin WKUP3 enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WUPEN4</name>
              <description>Wakeup and interrupt pin WKUP4 enable
Access can be secured by PWR WUP4SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Wakeup and interrupt pin WKUP4 disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Wakeup and interrupt pin WKUP4 enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WUPEN5</name>
              <description>Wakeup and interrupt pin WKUP5 enable
Access can be secured by PWR WUP5SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Wakeup and interrupt pin WKUP5 disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Wakeup and interrupt pin WKUP5 enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WUPEN6</name>
              <description>Wakeup and interrupt pin WKUP6 enable
Access can be secured by PWR WUP6SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Wakeup and interrupt pin WKUP6 disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Wakeup and interrupt pin WKUP6 enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WUPEN7</name>
              <description>Wakeup and interrupt pin WKUP7 enable
Access can be secured by PWR WUP7SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Wakeup and interrupt pin WKUP7 disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Wakeup and interrupt pin WKUP7 enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WUPEN8</name>
              <description>Wakeup and interrupt pin WKUP8 enable
Access can be secured by PWR WUP8SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Wakeup and interrupt pin WKUP8 disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Wakeup and interrupt pin WKUP8 enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_WUCR2</name>
          <displayName>PWR_WUCR2</displayName>
          <description>PWR wakeup control register 2</description>
          <addressOffset>0x018</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WUPP1</name>
              <description>Wakeup pin WKUP1 polarity.
This bit must be configured when WUPEN1 = 0.
Access can be secured by PWR WUP1SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Detection on high level (rising edge)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Detection on low level (falling edge)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WUPP2</name>
              <description>Wakeup pin WKUP2 polarity
This bit must be configured when WUPEN2 = 0.
Access can be secured by PWR WUP2SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Detection on high level (rising edge)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Detection on low level (falling edge)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WUPP3</name>
              <description>Wakeup pin WKUP3 polarity
This bit must be configured when WUPEN3 = 0.
Access can be secured by PWR WUP3SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Detection on high level (rising edge)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Detection on low level (falling edge)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WUPP4</name>
              <description>Wakeup pin WKUP4 polarity
This bit must be configured when WUPEN4 = 0.
Access can be secured by PWR WUP4SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Detection on high level (rising edge)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Detection on low level (falling edge)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WUPP5</name>
              <description>Wakeup pin WKUP5 polarity
This bit must be configured when WUPEN5 = 0.
Access can be secured by PWR WUP5SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Detection on high level (rising edge)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Detection on low level (falling edge)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WUPP6</name>
              <description>Wakeup pin WKUP6 polarity
This bit must be configured when WUPEN6 = 0.
Access can be secured by PWR WUP6SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Detection on high level (rising edge)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Detection on low level (falling edge)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WUPP7</name>
              <description>Wakeup pin WKUP7 polarity
This bit must be configured when WUPEN7 = 0.
Access can be secured by PWR WUP7SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Detection on high level (rising edge)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Detection on low level (falling edge)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WUPP8</name>
              <description>Wakeup pin WKUP8 polarity
This bit must be configured when WUPEN8 = 0.
Access can be secured by PWR WUP8SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Detection on high level (rising edge)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Detection on low level (falling edge)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_WUCR3</name>
          <displayName>PWR_WUCR3</displayName>
          <description>PWR wakeup control register 3</description>
          <addressOffset>0x01C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WUSEL1</name>
              <description>Wakeup and interrupt pin WKUP1 selection
This field must be configured when WUPEN1 = 0.
Access can be secured by PWR WUP1SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>WKUP1_0</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>WKUP1_1</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WUSEL2</name>
              <description>Wakeup and interrupt pin WKUP2 selection
This field must be configured when WUPEN2 = 0.
Access can be secured by PWR WUP2SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>WKUP2_1</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WUSEL3</name>
              <description>Wakeup and interrupt pin WKUP3 selection
This field must be configured when WUPEN3 = 0.
Access can be secured by PWR WUP3SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>WKUP3_1</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>WKUP3_2</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WUSEL4</name>
              <description>Wakeup and interrupt pin WKUP4 selection
This field must be configured when WUPEN4 = 0.
Access can be secured by PWR WUP4SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>WKUP4_0</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>WKUP4_1</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WUSEL5</name>
              <description>Wakeup and interrupt pin WKUP5 selection
This field must be configured when WUPEN5 = 0.
Access can be secured by PWR WUP5SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>WKUP5_1</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>WKUP5_2</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WUSEL6</name>
              <description>Wakeup and interrupt pin WKUP6 selection
This field must be configured when WUPEN6 = 0.
Access can be secured by PWR WUP6SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>WKUP6_0</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>WKUP6_1</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>WKUP6_3 (internal source, does not generate a WKUP interrupt)</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WUSEL7</name>
              <description>Wakeup and interrupt pin WKUP7 selection
This field must be configured when WUPEN7 = 0.
Access can be secured by PWR WUP7SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>WKUP7_0</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>WKUP7_1</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>WKUP7_3 (internal source, does not generate a WKUP interrupt)</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WUSEL8</name>
              <description>Wakeup and interrupt pin WKUP8 selection
This field must be configured when WUPEN8 = 0.
Access can be secured by PWR WUP8SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>WKUP8_1</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>WKUP8_2</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>WKUP8_3 (internal source, does not generate a WKUP interrupt)</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_DBPR</name>
          <displayName>PWR_DBPR</displayName>
          <description>PWR disable Backup domain register</description>
          <addressOffset>0x028</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DBP</name>
              <description>Disable Backup domain write protection
In reset state, all registers and SRAM in Backup domain are protected against parasitic write access. This bit must be set to enable the write access to these registers.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Write access to Backup domain disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write access to Backup domain enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_SECCFGR</name>
          <displayName>PWR_SECCFGR</displayName>
          <description>PWR security configuration register</description>
          <addressOffset>0x030</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WUP1SEC</name>
              <description>WUP1 secure protection</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Bits related to the WKUP1 pin in PWR_WUCR1, PWR_WUCR2, PWR_WUCR3 and PWR_WUSCR can be read and written with secure or non-secure access.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Bits related to the WKUP1 pin in PWR_WUCR1, PWR_WUCR2, PWR_WUCR3 and PWR_WUSCR can be read and written only with secure access.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WUP2SEC</name>
              <description>WUP2 secure protection</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Bits related to the WKUP2 pin in PWR_WUCR1, PWR_WUCR2, PWR_WUCR3 and PWR_WUSCR can be read and written with secure or non-secure access.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Bits related to the WKUP2 pin in PWR_WUCR1, PWR_WUCR2, PWR_WUCR3 and PWR_WUSCR can be read and written only with secure access.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WUP3SEC</name>
              <description>WUP3 secure protection</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Bits related to the WKUP3 pin in PWR_WUCR1, PWR_WUCR2, PWR_WUCR3 and PWR_WUSCR can be read and written with secure or non-secure access.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Bits related to the WKUP3 pin in PWR_WUCR1, PWR_WUCR2, PWR_WUCR3 and PWR_WUSCR can be read and written only with secure access.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WUP4SEC</name>
              <description>WUP4 secure protection</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Bits related to the WKUP4 pin in PWR_WUCR1, PWR_WUCR2, PWR_WUCR3 and PWR_WUSCR can be read and written with secure or non-secure access.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Bits related to the WKUP4 pin in PWR_WUCR1, PWR_WUCR2, PWR_WUCR3 and PWR_WUSCR can be read and written only with secure access.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WUP5SEC</name>
              <description>WUP5 secure protection</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Bits related to the WKUP5 pin in PWR_WUCR1, PWR_WUCR2, PWR_WUCR3 and PWR_WUSCR can be read and written with secure or non-secure access.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Bits related to the WKUP5 pin in PWR_WUCR1, PWR_WUCR2, PWR_WUCR3 and PWR_WUSCR can be read and written only with secure access.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WUP6SEC</name>
              <description>WUP6 secure protection</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Bits related to the WKUP6 pin in PWR_WUCR1, PWR_WUCR2, PWR_WUCR3 and PWR_WUSCR can be read and written with secure or non-secure access.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Bits related to the WKUP6 pin in PWR_WUCR1, PWR_WUCR2, PWR_WUCR3 and PWR_WUSCR can be read and written only with secure access.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WUP7SEC</name>
              <description>WUP7 secure protection</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Bits related to the WKUP7 pin in PWR_WUCR1, PWR_WUCR2, PWR_WUCR3 and PWR_WUSCR can be read and written with secure or non-secure access.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Bits related to the WKUP7 pin in PWR_WUCR1, PWR_WUCR2, PWR_WUCR3 and PWR_WUSCR can be read and written only with secure access.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WUP8SEC</name>
              <description>WUP8 secure protection</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Bits related to the WKUP8 pin in PWR_WUCR1, PWR_WUCR2, PWR_WUCR3 and PWR_WUSCR can be read and written with secure or non-secure access.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Bits related to the WKUP8 pin in PWR_WUCR1, PWR_WUCR2, PWR_WUCR3 and PWR_WUSCR can be read and written only with secure access.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LPMSEC</name>
              <description>Low-power modes secure protection</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>PWR_CR1, PWR_CR2 and CSSF in the PWR_SR can be read and written with secure or non-secure access.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>PWR_CR1, PWR_CR2, and CSSF in the PWR_SR can be read and written only with secure access.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VDMSEC</name>
              <description>Voltage detection secure protection</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>PWR_SVMCR and PWR_CR3 can be read and written with secure or non-secure access.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>PWR_SVMCR and PWR_CR3 can be read and written only with secure access.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VBSEC</name>
              <description>Backup domain secure protection</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>PWR_DBPR can be read and written with secure or non-secure access.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>PWR_DBPR can be read and written only with secure access.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_PRIVCFGR</name>
          <displayName>PWR_PRIVCFGR</displayName>
          <description>PWR privilege control register</description>
          <addressOffset>0x034</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SPRIV</name>
              <description>PWR secure functions privilege configuration
This bit is set and reset by software.
It can be written only by a secure privileged access.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Read and write to PWR secure functions can be done by privileged or unprivileged access.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Read and write to PWR secure functions can be done by privileged access only.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NSPRIV</name>
              <description>PWR non-secure functions privilege configuration
This bit is set and reset by software.
It can be written only by privileged access, secure or non-secure.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Read and write to PWR non-secure functions can be done by privileged or unprivileged access.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Read and write to PWR non-secure functions can be done by privileged access only.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_SR</name>
          <displayName>PWR_SR</displayName>
          <description>PWR status register</description>
          <addressOffset>0x038</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CSSF</name>
              <description>Clear Stop and Standby flags
Access can be secured by PWR LPMSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.
Writing 1 to this bit clears the STOPF and SBF flags.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>STOPF</name>
              <description>Stop flag
This bit is set by hardware when the device enters a Stop or Standby mode at the same time as the sysclk has been set by hardware to select HSI16. It's cleared by software by writing 1 to the CSSF bit and by hardware when SBF is set.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>The device did not enter any Stop mode.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The device entered a Stop mode.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SBF</name>
              <description>Standby flag
This bit is set by hardware when the device enters the Standby mode and the CPU restart from its reset vector. It's cleared by writing 1 to the CSSF bit, or by a power-on reset. It is not cleared by the system reset.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>The device did not enter Standby mode.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The device entered Standby mode.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_SVMSR</name>
          <displayName>PWR_SVMSR</displayName>
          <description>PWR supply voltage monitoring status register</description>
          <addressOffset>0x03C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00008000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REGS</name>
              <description>Regulator selection</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PVDO</name>
              <description>Programmable voltage detector output</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>VsubDD/sub is equal or above the PVD threshold selected by PVDLS[2:0].</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>VsubDD /subis below the PVD threshold selected by PVDLS[2:0].</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ACTVOSRDY</name>
              <description>Voltage level ready for currently used VOS</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>VsubCORE/sub is above or below the current voltage scaling provided by ACTVOS.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>VsubCORE /subis equal to the current voltage scaling provided by ACTVOS</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ACTVOS</name>
              <description>VOS currently applied to VsubCORE/sub
This field provides the last VOS value.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Range 2 (lowest power)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Range 1 (highest frequency)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_WUSR</name>
          <displayName>PWR_WUSR</displayName>
          <description>PWR wakeup status register</description>
          <addressOffset>0x044</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WUF1</name>
              <description>Wakeup and interrupt pending flag 1
This bit is set when a wakeup event is detected on WKUP1 pin. This bit is cleared by writing 1 in the CWUF1 bit of PWR_WUSCR or by hardware when WUPEN1 = 0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WUF2</name>
              <description>Wakeup and interrupt pending flag 2
This bit is set when a wakeup event is detected on WKUP2 pin. This bit is cleared by writing 1 in the CWUF2 bit of PWR_WUSCR or by hardware when WUPEN2 = 0.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WUF3</name>
              <description>Wakeup and interrupt pending flag 3
This bit is set when a wakeup event is detected on WKUP3 pin. This bit is cleared by writing 1 in the CWUF3 bit of PWR_WUSCR or by hardware when WUPEN3 = 0.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WUF4</name>
              <description>Wakeup and interrupt pending flag 4
This bit is set when a wakeup event is detected on WKUP4 pin. This bit is cleared by writing 1 in the CWUF4 bit of PWR_WUSCR or by hardware when WUPEN4 = 0.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WUF5</name>
              <description>Wakeup and interrupt pending flag 5
This bit is set when a wakeup event is detected on WKUP5 pin. This bit is cleared by writing 1 in the CWUF5 bit of PWR_WUSCR or by hardware when WUPEN5 = 0.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WUF6</name>
              <description>Wakeup and interrupt pending flag 6
This bit is set when a wakeup event is detected on WKUP6 pin. This bit is cleared by writing 1 in the CWUF6 bit of PWR_WUSCR when WUSEL6 different 11, or by hardware when WUPEN6 = 0.
When WUSEL6 = 11, this bit is cleared by hardware when all associated internal wakeup source are cleared.
When WUSEL6 = 11, no WKUP interrupt is generated</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WUF7</name>
              <description>Wakeup and interrupt pending flag 7
This bit is set when a wakeup event is detected on WKUP7 pin. This bit is cleared by writing 1 in the CWUF7 bit of PWR_WUSCR when WUSEL7 different 11, or by hardware when WUPEN7 = 0.
When WUSEL7 = 11, this bit is cleared by hardware when all associated internal wakeup source are cleared.
When WUSEL7 = 11, no WKUP interrupt is generated.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WUF8</name>
              <description>Wakeup and interrupt pending flag 8
This bit is set when a wakeup event is detected on WKUP8 pin. This bit is cleared by writing 1 in the CWUF8 bit of PWR_WUSCR when WUSEL8 different 11, or by hardware when WUPEN8 = 0.
When WUSEL8 = 11, this bit is cleared by hardware when all associated internal wakeup source are cleared.
When WUSEL8 = 11, no WKUP interrupt is generated</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_WUSCR</name>
          <displayName>PWR_WUSCR</displayName>
          <description>PWR wakeup status clear register</description>
          <addressOffset>0x048</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CWUF1</name>
              <description>Clear wakeup flag 1
Access can be secured by PWR WUP1SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.
Writing 1 to this bit clears the WUF1 flag in PWR_WUSR.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CWUF2</name>
              <description>Clear wakeup flag 2
Access can be secured by PWR WUP2SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.
Writing 1 to this bit clears the WUF2 flag in PWR_WUSR.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CWUF3</name>
              <description>Clear wakeup flag 3
Access can be secured by PWR WUP3SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.
Writing 1 to this bit clears the WUF3 flag in PWR_WUSR.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CWUF4</name>
              <description>Clear wakeup flag 4
Access can be secured by PWR WUP4SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.
Writing 1 to this bit clears the WUF4 flag in PWR_WUSR.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CWUF5</name>
              <description>Clear wakeup flag 5
Access can be secured by PWR WUP5SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.
Writing 1 to this bit clears the WUF5 flag in PWR_WUSR.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CWUF6</name>
              <description>Clear wakeup flag 6
Access can be secured by PWR WUP6SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.
Writing 1 to this bit clears the WUF6 flag in PWR_WUSR.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CWUF7</name>
              <description>Clear wakeup flag 7
Access can be secured by PWR WUP7SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.
Writing 1 to this bit clears the WUF7 flag in PWR_WUSR.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CWUF8</name>
              <description>Clear wakeup flag 8
Access can be secured by PWR WUP8SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.
Writing 1 to this bit clears the WUF8 flag in PWR_WUSR.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_IORETENRA</name>
          <displayName>PWR_IORETENRA</displayName>
          <description>PWR port A Standby IO retention enable register</description>
          <addressOffset>0x050</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EN0</name>
              <description>Port A Standby GPIO retention enable
Access can be protected by GPIOA SECy, privilege protection is controlled by PWR SPRIV or PWR NSPRIV.
When set, each bit enables the Standby GPIO retention feature for PAy</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN1</name>
              <description>Port A Standby GPIO retention enable
Access can be protected by GPIOA SECy, privilege protection is controlled by PWR SPRIV or PWR NSPRIV.
When set, each bit enables the Standby GPIO retention feature for PAy</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN2</name>
              <description>Port A Standby GPIO retention enable
Access can be protected by GPIOA SECy, privilege protection is controlled by PWR SPRIV or PWR NSPRIV.
When set, each bit enables the Standby GPIO retention feature for PAy</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN3</name>
              <description>Port A Standby GPIO retention enable
Access can be protected by GPIOA SECy, privilege protection is controlled by PWR SPRIV or PWR NSPRIV.
When set, each bit enables the Standby GPIO retention feature for PAy</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN5</name>
              <description>Port A Standby GPIO retention enable
Access can be secured by GPIOA SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>PAy Standby GPIO retention feature disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>PAy Standby GPIO retention feature enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EN6</name>
              <description>Port A Standby GPIO retention enable
Access can be secured by GPIOA SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>PAy Standby GPIO retention feature disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>PAy Standby GPIO retention feature enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EN7</name>
              <description>Port A Standby GPIO retention enable
Access can be secured by GPIOA SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>PAy Standby GPIO retention feature disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>PAy Standby GPIO retention feature enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EN8</name>
              <description>Port A Standby GPIO retention enable
Access can be secured by GPIOA SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>PAy Standby GPIO retention feature disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>PAy Standby GPIO retention feature enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EN9</name>
              <description>Port A Standby GPIO retention enable
Access can be secured by GPIOA SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>PAy Standby GPIO retention feature disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>PAy Standby GPIO retention feature enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EN10</name>
              <description>Port A Standby GPIO retention enable
Access can be secured by GPIOA SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>PAy Standby GPIO retention feature disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>PAy Standby GPIO retention feature enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EN11</name>
              <description>Port A Standby GPIO retention enable
Access can be secured by GPIOA SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>PAy Standby GPIO retention feature disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>PAy Standby GPIO retention feature enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EN12</name>
              <description>Port A Standby GPIO retention enable
Access can be secured by GPIOA SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>PAy Standby GPIO retention feature disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>PAy Standby GPIO retention feature enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EN13</name>
              <description>Port A Standby GPIO retention enable
Access can be secured by GPIOA SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>PAy Standby GPIO retention feature disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>PAy Standby GPIO retention feature enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EN14</name>
              <description>Port A Standby GPIO retention enable
Access can be secured by GPIOA SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>PAy Standby GPIO retention feature disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>PAy Standby GPIO retention feature enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EN15</name>
              <description>Port A Standby GPIO retention enable
Access can be secured by GPIOA SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>PAy Standby GPIO retention feature disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>PAy Standby GPIO retention feature enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_IORETRA</name>
          <displayName>PWR_IORETRA</displayName>
          <description>PWR port A Standby IO retention status register</description>
          <addressOffset>0x054</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RET0</name>
              <description>Port A Standby GPIO retention active
Access can be protected by GPIOA SECy, privilege protection is controlled by PWR SPRIV or PWR NSPRIV.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Set by hardware when Standby GPIO PAy is enabled in PWR_IORETENRA and Standby mode is entered. Standby GPIO retention PAy active.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Cleared by software, writing 0. Standby GPIO retention PAy disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RET1</name>
              <description>Port A Standby GPIO retention active
Access can be protected by GPIOA SECy, privilege protection is controlled by PWR SPRIV or PWR NSPRIV.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Set by hardware when Standby GPIO PAy is enabled in PWR_IORETENRA and Standby mode is entered. Standby GPIO retention PAy active.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Cleared by software, writing 0. Standby GPIO retention PAy disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RET2</name>
              <description>Port A Standby GPIO retention active
Access can be protected by GPIOA SECy, privilege protection is controlled by PWR SPRIV or PWR NSPRIV.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Set by hardware when Standby GPIO PAy is enabled in PWR_IORETENRA and Standby mode is entered. Standby GPIO retention PAy active.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Cleared by software, writing 0. Standby GPIO retention PAy disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RET3</name>
              <description>Port A Standby GPIO retention active
Access can be protected by GPIOA SECy, privilege protection is controlled by PWR SPRIV or PWR NSPRIV.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Set by hardware when Standby GPIO PAy is enabled in PWR_IORETENRA and Standby mode is entered. Standby GPIO retention PAy active.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Cleared by software, writing 0. Standby GPIO retention PAy disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RET5</name>
              <description>Port A Standby GPIO retention active
Access can be secured by GPIOA SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Set by hardware when Standby GPIO PAy is enabled in PWR_IORETENRA and Standby mode is entered. Standby GPIO retention PAy active.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Cleared by software, writing 0. Standby GPIO retention PAy disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RET6</name>
              <description>Port A Standby GPIO retention active
Access can be secured by GPIOA SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Set by hardware when Standby GPIO PAy is enabled in PWR_IORETENRA and Standby mode is entered. Standby GPIO retention PAy active.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Cleared by software, writing 0. Standby GPIO retention PAy disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RET7</name>
              <description>Port A Standby GPIO retention active
Access can be secured by GPIOA SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Set by hardware when Standby GPIO PAy is enabled in PWR_IORETENRA and Standby mode is entered. Standby GPIO retention PAy active.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Cleared by software, writing 0. Standby GPIO retention PAy disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RET8</name>
              <description>Port A Standby GPIO retention active
Access can be secured by GPIOA SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Set by hardware when Standby GPIO PAy is enabled in PWR_IORETENRA and Standby mode is entered. Standby GPIO retention PAy active.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Cleared by software, writing 0. Standby GPIO retention PAy disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RET9</name>
              <description>Port A Standby GPIO retention active
Access can be secured by GPIOA SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Set by hardware when Standby GPIO PAy is enabled in PWR_IORETENRA and Standby mode is entered. Standby GPIO retention PAy active.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Cleared by software, writing 0. Standby GPIO retention PAy disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RET10</name>
              <description>Port A Standby GPIO retention active
Access can be secured by GPIOA SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Set by hardware when Standby GPIO PAy is enabled in PWR_IORETENRA and Standby mode is entered. Standby GPIO retention PAy active.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Cleared by software, writing 0. Standby GPIO retention PAy disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RET11</name>
              <description>Port A Standby GPIO retention active
Access can be secured by GPIOA SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Set by hardware when Standby GPIO PAy is enabled in PWR_IORETENRA and Standby mode is entered. Standby GPIO retention PAy active.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Cleared by software, writing 0. Standby GPIO retention PAy disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RET12</name>
              <description>Port A Standby GPIO retention active
Access can be secured by GPIOA SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Set by hardware when Standby GPIO PAy is enabled in PWR_IORETENRA and Standby mode is entered. Standby GPIO retention PAy active.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Cleared by software, writing 0. Standby GPIO retention PAy disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RET13</name>
              <description>Port A Standby GPIO retention active
Access can be secured by GPIOA SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Set by hardware when Standby GPIO PAy is enabled in PWR_IORETENRA and Standby mode is entered. Standby GPIO retention PAy active.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Cleared by software, writing 0. Standby GPIO retention PAy disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RET14</name>
              <description>Port A Standby GPIO retention active
Access can be secured by GPIOA SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Set by hardware when Standby GPIO PAy is enabled in PWR_IORETENRA and Standby mode is entered. Standby GPIO retention PAy active.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Cleared by software, writing 0. Standby GPIO retention PAy disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RET15</name>
              <description>Port A Standby GPIO retention active
Access can be secured by GPIOA SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Set by hardware when Standby GPIO PAy is enabled in PWR_IORETENRA and Standby mode is entered. Standby GPIO retention PAy active.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Cleared by software, writing 0. Standby GPIO retention PAy disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_IORETENRB</name>
          <displayName>PWR_IORETENRB</displayName>
          <description>PWR port B Standby IO retention enable register</description>
          <addressOffset>0x058</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EN0</name>
              <description>Port B Standby GPIO retention enable
Access can be secured by GPIOB SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>PBy Standby GPIO retention feature disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>PBy Standby GPIO retention feature enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EN1</name>
              <description>Port B Standby GPIO retention enable
Access can be secured by GPIOB SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>PBy Standby GPIO retention feature disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>PBy Standby GPIO retention feature enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EN2</name>
              <description>Port B Standby GPIO retention enable
Access can be secured by GPIOB SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>PBy Standby GPIO retention feature disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>PBy Standby GPIO retention feature enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EN3</name>
              <description>Port B Standby GPIO retention enable
Access can be secured by GPIOB SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>PBy Standby GPIO retention feature disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>PBy Standby GPIO retention feature enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EN4</name>
              <description>Port B Standby GPIO retention enable
Access can be secured by GPIOB SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>PBy Standby GPIO retention feature disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>PBy Standby GPIO retention feature enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EN5</name>
              <description>Port B Standby GPIO retention enable
Access can be secured by GPIOB SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>PBy Standby GPIO retention feature disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>PBy Standby GPIO retention feature enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EN6</name>
              <description>Port B Standby GPIO retention enable
Access can be secured by GPIOB SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>PBy Standby GPIO retention feature disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>PBy Standby GPIO retention feature enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EN7</name>
              <description>Port B Standby GPIO retention enable
Access can be secured by GPIOB SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>PBy Standby GPIO retention feature disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>PBy Standby GPIO retention feature enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EN8</name>
              <description>Port B Standby GPIO retention enable
Access can be secured by GPIOB SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>PBy Standby GPIO retention feature disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>PBy Standby GPIO retention feature enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EN9</name>
              <description>Port B Standby GPIO retention enable
Access can be secured by GPIOB SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>PBy Standby GPIO retention feature disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>PBy Standby GPIO retention feature enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EN10</name>
              <description>Port B Standby GPIO retention enable
Access can be secured by GPIOB SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>PBy Standby GPIO retention feature disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>PBy Standby GPIO retention feature enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EN11</name>
              <description>Port B Standby GPIO retention enable
Access can be secured by GPIOB SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>PBy Standby GPIO retention feature disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>PBy Standby GPIO retention feature enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EN12</name>
              <description>Port B Standby GPIO retention enable
Access can be secured by GPIOB SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>PBy Standby GPIO retention feature disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>PBy Standby GPIO retention feature enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EN13</name>
              <description>Port B Standby GPIO retention enable
Access can be secured by GPIOB SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>PBy Standby GPIO retention feature disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>PBy Standby GPIO retention feature enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EN14</name>
              <description>Port B Standby GPIO retention enable
Access can be secured by GPIOB SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>PBy Standby GPIO retention feature disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>PBy Standby GPIO retention feature enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EN15</name>
              <description>Port B Standby GPIO retention enable
Access can be secured by GPIOB SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>PBy Standby GPIO retention feature disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>PBy Standby GPIO retention feature enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_IORETRB</name>
          <displayName>PWR_IORETRB</displayName>
          <description>PWR port B Standby IO retention status register</description>
          <addressOffset>0x05C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RET0</name>
              <description>Port B Standby GPIO retention active
Access can be secured by GPIOB SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Set by hardware when Standby GPIO PBy is enabled in PWR_IORETENRB and Standby mode is entered. Standby GPIO retention PBy active.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Cleared by software, writing 0. Standby GPIO retention PBy disabled..</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RET1</name>
              <description>Port B Standby GPIO retention active
Access can be secured by GPIOB SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Set by hardware when Standby GPIO PBy is enabled in PWR_IORETENRB and Standby mode is entered. Standby GPIO retention PBy active.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Cleared by software, writing 0. Standby GPIO retention PBy disabled..</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RET2</name>
              <description>Port B Standby GPIO retention active
Access can be secured by GPIOB SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Set by hardware when Standby GPIO PBy is enabled in PWR_IORETENRB and Standby mode is entered. Standby GPIO retention PBy active.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Cleared by software, writing 0. Standby GPIO retention PBy disabled..</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RET3</name>
              <description>Port B Standby GPIO retention active
Access can be secured by GPIOB SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Set by hardware when Standby GPIO PBy is enabled in PWR_IORETENRB and Standby mode is entered. Standby GPIO retention PBy active.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Cleared by software, writing 0. Standby GPIO retention PBy disabled..</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RET4</name>
              <description>Port B Standby GPIO retention active
Access can be secured by GPIOB SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Set by hardware when Standby GPIO PBy is enabled in PWR_IORETENRB and Standby mode is entered. Standby GPIO retention PBy active.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Cleared by software, writing 0. Standby GPIO retention PBy disabled..</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RET5</name>
              <description>Port B Standby GPIO retention active
Access can be secured by GPIOB SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Set by hardware when Standby GPIO PBy is enabled in PWR_IORETENRB and Standby mode is entered. Standby GPIO retention PBy active.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Cleared by software, writing 0. Standby GPIO retention PBy disabled..</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RET6</name>
              <description>Port B Standby GPIO retention active
Access can be secured by GPIOB SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Set by hardware when Standby GPIO PBy is enabled in PWR_IORETENRB and Standby mode is entered. Standby GPIO retention PBy active.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Cleared by software, writing 0. Standby GPIO retention PBy disabled..</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RET7</name>
              <description>Port B Standby GPIO retention active
Access can be secured by GPIOB SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Set by hardware when Standby GPIO PBy is enabled in PWR_IORETENRB and Standby mode is entered. Standby GPIO retention PBy active.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Cleared by software, writing 0. Standby GPIO retention PBy disabled..</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RET8</name>
              <description>Port B Standby GPIO retention active
Access can be secured by GPIOB SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Set by hardware when Standby GPIO PBy is enabled in PWR_IORETENRB and Standby mode is entered. Standby GPIO retention PBy active.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Cleared by software, writing 0. Standby GPIO retention PBy disabled..</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RET9</name>
              <description>Port B Standby GPIO retention active
Access can be secured by GPIOB SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Set by hardware when Standby GPIO PBy is enabled in PWR_IORETENRB and Standby mode is entered. Standby GPIO retention PBy active.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Cleared by software, writing 0. Standby GPIO retention PBy disabled..</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RET10</name>
              <description>Port B Standby GPIO retention active
Access can be secured by GPIOB SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Set by hardware when Standby GPIO PBy is enabled in PWR_IORETENRB and Standby mode is entered. Standby GPIO retention PBy active.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Cleared by software, writing 0. Standby GPIO retention PBy disabled..</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RET11</name>
              <description>Port B Standby GPIO retention active
Access can be secured by GPIOB SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Set by hardware when Standby GPIO PBy is enabled in PWR_IORETENRB and Standby mode is entered. Standby GPIO retention PBy active.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Cleared by software, writing 0. Standby GPIO retention PBy disabled..</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RET12</name>
              <description>Port B Standby GPIO retention active
Access can be secured by GPIOB SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Set by hardware when Standby GPIO PBy is enabled in PWR_IORETENRB and Standby mode is entered. Standby GPIO retention PBy active.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Cleared by software, writing 0. Standby GPIO retention PBy disabled..</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RET13</name>
              <description>Port B Standby GPIO retention active
Access can be secured by GPIOB SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Set by hardware when Standby GPIO PBy is enabled in PWR_IORETENRB and Standby mode is entered. Standby GPIO retention PBy active.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Cleared by software, writing 0. Standby GPIO retention PBy disabled..</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RET14</name>
              <description>Port B Standby GPIO retention active
Access can be secured by GPIOB SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Set by hardware when Standby GPIO PBy is enabled in PWR_IORETENRB and Standby mode is entered. Standby GPIO retention PBy active.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Cleared by software, writing 0. Standby GPIO retention PBy disabled..</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RET15</name>
              <description>Port B Standby GPIO retention active
Access can be secured by GPIOB SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Set by hardware when Standby GPIO PBy is enabled in PWR_IORETENRB and Standby mode is entered. Standby GPIO retention PBy active.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Cleared by software, writing 0. Standby GPIO retention PBy disabled..</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_IORETENRC</name>
          <displayName>PWR_IORETENRC</displayName>
          <description>PWR port C Standby IO retention enable register</description>
          <addressOffset>0x060</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EN13</name>
              <description>Port C Standby GPIO retention enable
Access can be secured by GPIOC SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>PCy Standby GPIO retention feature disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>PCy Standby GPIO retention feature enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EN14</name>
              <description>Port C Standby GPIO retention enable
Access can be secured by GPIOC SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>PCy Standby GPIO retention feature disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>PCy Standby GPIO retention feature enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EN15</name>
              <description>Port C Standby GPIO retention enable
Access can be secured by GPIOC SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>PCy Standby GPIO retention feature disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>PCy Standby GPIO retention feature enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_IORETRC</name>
          <displayName>PWR_IORETRC</displayName>
          <description>PWR port C Standby IO retention status register</description>
          <addressOffset>0x064</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RET13</name>
              <description>Port C Standby GPIO retention active
Access can be secured by GPIOC SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Set by hardware when Standby GPIO PCy is enabled in PWR_IORETENRC and Standby mode is entered. Standby GPIO retention PCy active.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Cleared by software, writing 0. Standby GPIO retention PCy disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RET14</name>
              <description>Port C Standby GPIO retention active
Access can be secured by GPIOC SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Set by hardware when Standby GPIO PCy is enabled in PWR_IORETENRC and Standby mode is entered. Standby GPIO retention PCy active.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Cleared by software, writing 0. Standby GPIO retention PCy disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RET15</name>
              <description>Port C Standby GPIO retention active
Access can be secured by GPIOC SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Set by hardware when Standby GPIO PCy is enabled in PWR_IORETENRC and Standby mode is entered. Standby GPIO retention PCy active.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Cleared by software, writing 0. Standby GPIO retention PCy disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_IORETENRH</name>
          <displayName>PWR_IORETENRH</displayName>
          <description>PWR port H Standby IO retention enable register</description>
          <addressOffset>0x088</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EN3</name>
              <description>Port H Standby GPIO retention enable
Access can be secured by GPIOH SEC3. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>PHy Standby GPIO retention feature disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>PHy Standby GPIO retention feature enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_IORETRH</name>
          <displayName>PWR_IORETRH</displayName>
          <description>PWR port H Standby IO retention status register</description>
          <addressOffset>0x08C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RET3</name>
              <description>Port H Standby GPIO retention active
Access can be secured by GPIOH SEC3. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Set by hardware when Standby GPIO PHy is enabled in PWR_IORETENRH and Standby mode is entered. Standby GPIO retention PHy active.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Cleared by software, writing 0. Standby GPIO retention PHy disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_RADIOSCR</name>
          <displayName>PWR_RADIOSCR</displayName>
          <description>PWR 2.4 GHz RADIO status and control register</description>
          <addressOffset>0x100</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MODE</name>
              <description>2.4 GHz RADIO operating mode.
1x: 2.4 GHz RADIO active mode</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>2.4 GHz RADIO deep sleep mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>2.4 GHz RADIO sleep mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PHYMODE</name>
              <description>2.4 GHz RADIO PHY operating mode</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>2.4 GHz RADIO Sleep mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>2.4 GHz RADIO Standby mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ENCMODE</name>
              <description>2.4 GHz RADIO encryption function operating mode</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>2.4 GHz RADIO encryption function disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>2.4 GHz RADIO encryption function enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RFVDDHPA</name>
              <description>2.4 GHz RADIO VDDHPA control word.
Bits [3:0] see Table 81: PA output power table format for definition.
Bit [4] rf_event.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>REGPARDYVDDRFPA</name>
              <description>Ready bit for VsubDDHPA/sub voltage level when selecting VDDRFPA input.
Note: REGPARDYVDDRFPA does not allow to detect correct VsubDDHPA/sub voltage level when request to lower the level.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Not ready, VsubDDHPA/sub voltage level  REGPAVOS selected supply level</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Ready, VsubDDHPA/sub voltage level greater than or equal REGPAVOS selected supply level</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>RAMCFG</name>
      <description>RAMs configuration controller</description>
      <groupName>RAMCFG</groupName>
      <baseAddress>0x40026000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>RAMCFG</name>
        <description>RAM configuration global interrupt</description>
        <value>5</value>
      </interrupt>
      <registers>
        <register>
          <name>RAMCFG_M1CR</name>
          <displayName>RAMCFG_M1CR</displayName>
          <description>RAMCFG SRAM1 control register</description>
          <addressOffset>0x000</addressOffset>
          <size>0x20</size>
          <resetValue>0x00010000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SRAMER</name>
              <description>SRAM1 erase
This bit can be set by software only after writing the unlock sequence in the ERASEKEY field of the RAMCFG_M1ERKEYR register. Setting this bit starts the SRAM1 erase. This bit is automatically cleared by hardware at the end of the erase operation.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No erase operation ongoing</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Erase operation ongoing</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WSC</name>
              <description>SRAM1 wait state configuration
This field is used to program the number of wait states inserted on the AHB when reading the SRAM1, depending on its access time.
...
Note: Before entering Stop 1 mode software must set SRAM1 wait states to at least 1.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Zero wait states</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>One wait state</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7</name>
                  <description>Seven wait states</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RAMCFG_M1ISR</name>
          <displayName>RAMCFG_M1ISR</displayName>
          <description>RAMCFG SRAM1 interrupt status register</description>
          <addressOffset>0x008</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SRAMBUSY</name>
              <description>SRAM busy with erase operation.
Note: Depending on the SRAM, the erase operation can be performed due to software request, system reset if the enabled by user option, tamper detection or RDP regression. Refer to Table38.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No memory erase operation ongoing</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Memory erase operation ongoing</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RAMCFG_M1ERKEYR</name>
          <displayName>RAMCFG_M1ERKEYR</displayName>
          <description>RAMCFG SRAM1 erase key register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ERASEKEY</name>
              <description>Erase write protection key
The following steps are required to unlock the write protection of the SRAMER bit in the RAMCFG_MxCR register.
Write 0xCA into ERASEKEY[7:0]
Write 0x53 into ERASEKEY[7:0]
Note: Writing a wrong key reactivates the write protection.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAMCFG_M2CR</name>
          <displayName>RAMCFG_M2CR</displayName>
          <description>RAMCFG SRAM2 control register</description>
          <addressOffset>0x040</addressOffset>
          <size>0x20</size>
          <resetValue>0x00010000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ALE</name>
              <description>SRAM2 parity fail address latch enable</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Failing address not stored in the SRAM2 parity error address register RAMCFG_M2PEAR</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Failing address stored in the SRAM2 parity error address register RAMCFG_M2PEAR</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRAMER</name>
              <description>SRAM2 erase
This bit can be set by software only after writing the unlock sequence in the ERASEKEY field of the RAMCFG_M2ERKEYR register. Setting this bit starts the SRAM2 erase. This bit is automatically cleared by hardware at the end of the erase operation.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No erase operation ongoing</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Erase operation ongoing</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WSC</name>
              <description>SRAM2 wait state configuration
This field is used to program the number of wait states inserted on the AHB when reading the SRAM2, depending on its access time.
...
Note: Before entering Stop 1 mode software must set SRAM2 wait states to at least 1.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>0 wait state</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>1 wait state</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7</name>
                  <description>7 wait states</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RAMCFG_M2IER</name>
          <displayName>RAMCFG_M2IER</displayName>
          <description>RAMCFG SRAM2 interrupt enable register</description>
          <addressOffset>0x044</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PEIE</name>
              <description>Parity error interrupt enable</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Parity error interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Parity error interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PENMI</name>
              <description>Parity error NMI.
This bit is set by software and cleared only by a global RAMCFG reset
Note: When PENMI bit is set, the RAMCFG maskable interrupt is not generated for a parity error whatever PEIE bit value.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>NMI not generated in case of parity error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>NMI generated in case of parity error</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RAMCFG_M2ISR</name>
          <displayName>RAMCFG_M2ISR</displayName>
          <description>RAMCFG SRAM2 interrupt status register</description>
          <addressOffset>0x048</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PED</name>
              <description>Parity error detected</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No parity error detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Parity error detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRAMBUSY</name>
              <description>SRAM2 busy with erase operation.
Note: Depending on the SRAM2, the erase operation can be performed due to software request, system reset if the enabled by user option, tamper detection or RDP regression. Refer to Table38.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No memory erase operation ongoing</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Memory erase operation ongoing</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RAMCFG_M2PEAR</name>
          <displayName>RAMCFG_M2PEAR</displayName>
          <description>RAMCFG SRAM2 parity error address register</description>
          <addressOffset>0x050</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PEA</name>
              <description>Parity error SRAM word aligned address offset.PEA[1:0] read 0b00.
When ALE bit is set in RAMCFG_M2CR register, this field is updated when PED and CPED are zero and a new parity error is detected, with the SRAM word aligned address offset corresponding to the parity error.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ID</name>
              <description>Parity error AHB bus master ID.
When ALE bit is set in RAMCFG_M2CR register, this field is updated when PED and CPED are zero and a new parity error is detected, with:
Others: reserved</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>parity error detected on CPU access</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>parity error detected on Debugger access</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x6</name>
                  <description>parity error detected on DMA master port o access</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7</name>
                  <description>parity error detected on DMA master port 1 access</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BYTE</name>
              <description>Byte parity error flag.
When ALE bit is set in RAMCFG_M2CR register, this field is updated when PED and CPED are zero and a new parity error is detected, with:
1xxx: parity error detected on fourth byte in word aligned address
x1xx: parity error detected on third byte in word aligned address
xx1x: parity error detected on second byte in word aligned address
xxx1: parity error detected on first byte in word aligned address</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAMCFG_M2ICR</name>
          <displayName>RAMCFG_M2ICR</displayName>
          <description>RAMCFG SRAM2 interrupt clear register</description>
          <addressOffset>0x054</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CPED</name>
              <description>Clear parity error detect bit
Writing 1 to this bit clears the PED bit in RAMCFG_M2ISR.
Reading this bit returns the value of the RAMCFG_M2ISR PED bit.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAMCFG_M2WPR1</name>
          <displayName>RAMCFG_M2WPR1</displayName>
          <description>RAMCFG SRAM2 write protection register 1</description>
          <addressOffset>0x058</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>P0WP</name>
              <description>SRAM2 1-Kbyte write protect page y write protection
These bits are set by software and cleared only by a system reset.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>P1WP</name>
              <description>SRAM2 1-Kbyte write protect page y write protection
These bits are set by software and cleared only by a system reset.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>P2WP</name>
              <description>SRAM2 1-Kbyte write protect page y write protection
These bits are set by software and cleared only by a system reset.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>P3WP</name>
              <description>SRAM2 1-Kbyte write protect page y write protection
These bits are set by software and cleared only by a system reset.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>P4WP</name>
              <description>SRAM2 1-Kbyte write protect page y write protection
These bits are set by software and cleared only by a system reset.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>P5WP</name>
              <description>SRAM2 1-Kbyte write protect page y write protection
These bits are set by software and cleared only by a system reset.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>P6WP</name>
              <description>SRAM2 1-Kbyte write protect page y write protection
These bits are set by software and cleared only by a system reset.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>P7WP</name>
              <description>SRAM2 1-Kbyte write protect page y write protection
These bits are set by software and cleared only by a system reset.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>P8WP</name>
              <description>SRAM2 1-Kbyte write protect page y write protection
These bits are set by software and cleared only by a system reset.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>P9WP</name>
              <description>SRAM2 1-Kbyte write protect page y write protection
These bits are set by software and cleared only by a system reset.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>P10WP</name>
              <description>SRAM2 1-Kbyte write protect page y write protection
These bits are set by software and cleared only by a system reset.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>P11WP</name>
              <description>SRAM2 1-Kbyte write protect page y write protection
These bits are set by software and cleared only by a system reset.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>P12WP</name>
              <description>SRAM2 1-Kbyte write protect page y write protection
These bits are set by software and cleared only by a system reset.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>P13WP</name>
              <description>SRAM2 1-Kbyte write protect page y write protection
These bits are set by software and cleared only by a system reset.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>P14WP</name>
              <description>SRAM2 1-Kbyte write protect page y write protection
These bits are set by software and cleared only by a system reset.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>P15WP</name>
              <description>SRAM2 1-Kbyte write protect page y write protection
These bits are set by software and cleared only by a system reset.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>P16WP</name>
              <description>SRAM2 1-Kbyte write protect page y write protection
These bits are set by software and cleared only by a system reset.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>P17WP</name>
              <description>SRAM2 1-Kbyte write protect page y write protection
These bits are set by software and cleared only by a system reset.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>P18WP</name>
              <description>SRAM2 1-Kbyte write protect page y write protection
These bits are set by software and cleared only by a system reset.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>P19WP</name>
              <description>SRAM2 1-Kbyte write protect page y write protection
These bits are set by software and cleared only by a system reset.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>P20WP</name>
              <description>SRAM2 1-Kbyte write protect page y write protection
These bits are set by software and cleared only by a system reset.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>P21WP</name>
              <description>SRAM2 1-Kbyte write protect page y write protection
These bits are set by software and cleared only by a system reset.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>P22WP</name>
              <description>SRAM2 1-Kbyte write protect page y write protection
These bits are set by software and cleared only by a system reset.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>P23WP</name>
              <description>SRAM2 1-Kbyte write protect page y write protection
These bits are set by software and cleared only by a system reset.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>P24WP</name>
              <description>SRAM2 1-Kbyte write protect page y write protection
These bits are set by software and cleared only by a system reset.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>P25WP</name>
              <description>SRAM2 1-Kbyte write protect page y write protection
These bits are set by software and cleared only by a system reset.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>P26WP</name>
              <description>SRAM2 1-Kbyte write protect page y write protection
These bits are set by software and cleared only by a system reset.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>P27WP</name>
              <description>SRAM2 1-Kbyte write protect page y write protection
These bits are set by software and cleared only by a system reset.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>P28WP</name>
              <description>SRAM2 1-Kbyte write protect page y write protection
These bits are set by software and cleared only by a system reset.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>P29WP</name>
              <description>SRAM2 1-Kbyte write protect page y write protection
These bits are set by software and cleared only by a system reset.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>P30WP</name>
              <description>SRAM2 1-Kbyte write protect page y write protection
These bits are set by software and cleared only by a system reset.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>P31WP</name>
              <description>SRAM2 1-Kbyte write protect page y write protection
These bits are set by software and cleared only by a system reset.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RAMCFG_M2WPR2</name>
          <displayName>RAMCFG_M2WPR2</displayName>
          <description>RAMCFG SRAM2 write protection register 2</description>
          <addressOffset>0x05C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>P32WP</name>
              <description>SRAM2 1-Kbyte write protect page y write protection
These bits are set by software and cleared only by a system reset.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>P33WP</name>
              <description>SRAM2 1-Kbyte write protect page y write protection
These bits are set by software and cleared only by a system reset.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>P34WP</name>
              <description>SRAM2 1-Kbyte write protect page y write protection
These bits are set by software and cleared only by a system reset.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>P35WP</name>
              <description>SRAM2 1-Kbyte write protect page y write protection
These bits are set by software and cleared only by a system reset.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>P36WP</name>
              <description>SRAM2 1-Kbyte write protect page y write protection
These bits are set by software and cleared only by a system reset.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>P37WP</name>
              <description>SRAM2 1-Kbyte write protect page y write protection
These bits are set by software and cleared only by a system reset.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>P38WP</name>
              <description>SRAM2 1-Kbyte write protect page y write protection
These bits are set by software and cleared only by a system reset.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>P39WP</name>
              <description>SRAM2 1-Kbyte write protect page y write protection
These bits are set by software and cleared only by a system reset.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>P40WP</name>
              <description>SRAM2 1-Kbyte write protect page y write protection
These bits are set by software and cleared only by a system reset.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>P41WP</name>
              <description>SRAM2 1-Kbyte write protect page y write protection
These bits are set by software and cleared only by a system reset.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>P42WP</name>
              <description>SRAM2 1-Kbyte write protect page y write protection
These bits are set by software and cleared only by a system reset.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>P43WP</name>
              <description>SRAM2 1-Kbyte write protect page y write protection
These bits are set by software and cleared only by a system reset.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>P44WP</name>
              <description>SRAM2 1-Kbyte write protect page y write protection
These bits are set by software and cleared only by a system reset.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>P45WP</name>
              <description>SRAM2 1-Kbyte write protect page y write protection
These bits are set by software and cleared only by a system reset.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>P46WP</name>
              <description>SRAM2 1-Kbyte write protect page y write protection
These bits are set by software and cleared only by a system reset.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>P47WP</name>
              <description>SRAM2 1-Kbyte write protect page y write protection
These bits are set by software and cleared only by a system reset.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>P48WP</name>
              <description>SRAM2 1-Kbyte write protect page y write protection
These bits are set by software and cleared only by a system reset.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>P49WP</name>
              <description>SRAM2 1-Kbyte write protect page y write protection
These bits are set by software and cleared only by a system reset.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>P50WP</name>
              <description>SRAM2 1-Kbyte write protect page y write protection
These bits are set by software and cleared only by a system reset.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>P51WP</name>
              <description>SRAM2 1-Kbyte write protect page y write protection
These bits are set by software and cleared only by a system reset.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>P52WP</name>
              <description>SRAM2 1-Kbyte write protect page y write protection
These bits are set by software and cleared only by a system reset.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>P53WP</name>
              <description>SRAM2 1-Kbyte write protect page y write protection
These bits are set by software and cleared only by a system reset.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>P54WP</name>
              <description>SRAM2 1-Kbyte write protect page y write protection
These bits are set by software and cleared only by a system reset.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>P55WP</name>
              <description>SRAM2 1-Kbyte write protect page y write protection
These bits are set by software and cleared only by a system reset.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>P56WP</name>
              <description>SRAM2 1-Kbyte write protect page y write protection
These bits are set by software and cleared only by a system reset.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>P57WP</name>
              <description>SRAM2 1-Kbyte write protect page y write protection
These bits are set by software and cleared only by a system reset.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>P58WP</name>
              <description>SRAM2 1-Kbyte write protect page y write protection
These bits are set by software and cleared only by a system reset.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>P59WP</name>
              <description>SRAM2 1-Kbyte write protect page y write protection
These bits are set by software and cleared only by a system reset.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>P60WP</name>
              <description>SRAM2 1-Kbyte write protect page y write protection
These bits are set by software and cleared only by a system reset.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>P61WP</name>
              <description>SRAM2 1-Kbyte write protect page y write protection
These bits are set by software and cleared only by a system reset.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>P62WP</name>
              <description>SRAM2 1-Kbyte write protect page y write protection
These bits are set by software and cleared only by a system reset.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>P63WP</name>
              <description>SRAM2 1-Kbyte write protect page y write protection
These bits are set by software and cleared only by a system reset.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Write protection of SRAM2 1-Kbyte write protect page y is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RAMCFG_M2ERKEYR</name>
          <displayName>RAMCFG_M2ERKEYR</displayName>
          <description>RAMCFG SRAM2 erase key register</description>
          <addressOffset>0x68</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ERASEKEY</name>
              <description>Erase write protection key
The following steps are required to unlock the write protection of the SRAMER bit in the RAMCFG_MxCR register.
Write 0xCA into ERASEKEY[7:0]
Write 0x53 into ERASEKEY[7:0]
Note: Writing a wrong key reactivates the write protection.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>RCC</name>
      <description>Reset and clock control</description>
      <groupName>RCC</groupName>
      <baseAddress>0x46020C00</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x400</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>RCC</name>
        <description>RCC non-secure global interrupt</description>
        <value>9</value>
      </interrupt>
      <interrupt>
        <name>RCC_S</name>
        <description>RCC Ssecure global interrupt</description>
        <value>10</value>
      </interrupt>
      <registers>
        <register>
          <name>RCC_CR</name>
          <displayName>RCC_CR</displayName>
          <description>RCC clock control register</description>
          <addressOffset>0x000</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000500</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HSION</name>
              <description>HSI16 clock enable
Set and cleared by software.
Cleared by hardware when entering Stop and Standby modes. 
Set by hardware to force the HSI16 oscillator on when exiting Stop and Standby modes.
Set by hardware to force the HSI16 oscillator on in case of clock security failure of the HSE32 crystal oscillator.
This bit is set by hardware if the HSI16 is used directly or indirectly as system clock.
Access to the bit can be secured by RCC HSISEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>HSI16 oscillator off</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>HSI16 oscillator on</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HSIKERON</name>
              <description>HSI16 enable for some peripheral kernels
Set and cleared by software to force HSI16 oscillator on even in Stop modes. 
Keeping the HSI16 oscillator on in Stop modes allows the communication speed not to be reduced by the HSI16 oscillator startup time. This bit has no effect on register bit HSION value.
Cleared by hardware when entering Standby modes. 
Refer to Peripherals clock gating and autonomous mode for more details.
Access to the bit can be secured by RCC HSISEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No effect on HSI16 oscillator</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>HSI16 oscillator forced on even in Stop mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HSIRDY</name>
              <description>HSI16 clock ready flag
Set by hardware to indicate that HSI16 oscillator is stable. This bit is set only when HSI16 is enabled by software by setting HSION.
Access to the bit can be secured by RCC HSISEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.
Note: Once the HSION bit is cleared, HSIRDY goes low after six HSI16 clock cycles.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>HSI16 oscillator not ready</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>HSI16 oscillator ready</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HSEON</name>
              <description>HSE32 clock enable
Set and cleared by software.
Cleared by hardware to stop the HSE32 clock for the CPU when entering Stop and Standby modes and on a HSECSS failure.
When the HSE32 is used as 2.4 GHz RADIO kernel clock, enabled by RADIOEN and RADIOSMEN and the 2.4 GHz RADIO is active, HSEON is not be cleared when entering low power mode. In this case only Stop 0 mode is entered as low power mode.
This bit cannot be reset if the HSE32 oscillator is used directly or indirectly as the system clock.
Access to the bit can be secured by RCC HSESEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>HSE32 oscillator not requested by the CPU.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>HSE32 oscillator ON</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HSERDY</name>
              <description>HSE32 clock ready flag
Set by hardware to indicate that the HSE32 oscillator is stable. This bit is set both when HSE32 is enabled by software by setting HSEON and when requested as kernel clock by the 2.4 GHz RADIO.
Access to the bit can be secured by RCC HSESEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>HSE32 oscillator not ready</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>HSE32 oscillator ready to be used by the CPU (HSERDY remains set when HSE32 is disabled by HSECSS failure).</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HSECSSON</name>
              <description>HSE32 clock security system enable
Set by software to enable the HSE32 clock security system. When HSECSSON is set, the clock detector is enabled by hardware when the HSE32 oscillator is ready and disabled by hardware if a HSE32 clock failure is detected. This bit is set only and is cleared by reset.
Access to the bit can be secured by RCC HSESEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>HSE32 clock security system off (clock detector off)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>HSE32 clock security system on (clock detector on if the HSE32 oscillator is stable, off if not).</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HSEPRE</name>
              <description>HSE32 clock for SYSCLK prescaler
Set and cleared by software to control the division factor of the HSE32 clock for SYSCLK.
Access to the bit can be secured by RCC HSESEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>HSE32 not divided, SYSCLK = HSE32</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>HSE32 divided, SYSCLK = HSE32/2</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PLL1ON</name>
              <description>PLL1 enable
Set and cleared by software to enable the main PLL.
Cleared by hardware when entering Stop or Standby modes and when PLL1 on HSE32 is selected as sysclk, on a HSECSS failure.
This bit cannot be reset if the PLL1 clock is used as the system clock.
Access to the bit can be secured by RCC PLL1SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>PLL1 off</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>PLL1 on</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PLL1RDY</name>
              <description>PLL1 clock ready flag
Set by hardware to indicate that the PLL1 is locked.
Access to the bit can be secured by RCC PLL1SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>PLL1 unlocked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>PLL1 locked (PLL1RDY remains set when PLL1 is selected as sysclk and PLL1 is disabled by HSECSS failure).</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RCC_ICSCR3</name>
          <displayName>RCC_ICSCR3</displayName>
          <description>RCC internal clock sources calibration register 3</description>
          <addressOffset>0x010</addressOffset>
          <size>0x20</size>
          <resetValue>0x00100000</resetValue>
          <resetMask>0xFFFFF000</resetMask>
          <fields>
            <field>
              <name>HSICAL</name>
              <description>HSI16 clock calibration
These bits are initialized at startup with the factory-programmed HSI16 calibration value. When HSITRIM[4:0] is written, HSICAL[11:0] is updated with the sum of HSITRIM[4:0] and the initial factory trim value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>HSITRIM</name>
              <description>HSI16 clock trimming 
These bits provide an additional user-programmable trimming value that is added to the HSICAL[11:0] bits. It can be programmed to adjust to voltage and temperature variations that influence the frequency of the HSI16.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RCC_CFGR1</name>
          <displayName>RCC_CFGR1</displayName>
          <description>RCC clock configuration register 1</description>
          <addressOffset>0x01C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SW</name>
              <description>system clock switch
Set and cleared by software to select system clock source (SYSCLK).
Cleared by hardware when entering Stop and Standby modes
When selecting HSE32 directly or indirectly as system clock and HSE32 oscillator clock security fails, cleared by hardware.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>HSI16 selected as system clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>HSE32 or HSE32/2, as defined by HSEPRE, selected as system clock</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>pll1rclk selected as system clock</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SWS</name>
              <description>system clock switch status
Set and cleared by hardware to indicate which clock source is used as system clock.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>HSI16 oscillator used as system clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>HSE32 or HSE32/2, as defined by HSEPRE, used as system clock</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>pll1rclk used as system clock</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MCOSEL</name>
              <description>microcontroller clock output
Set and cleared by software.
others: reserved
Note: This clock output may have some truncated cycles at startup or during MCO clock source switching.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>MCO output disabled, no clock on MCO</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>sysclkpre system clock after PLL1RCLKPRE division selected</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>HSI16 clock selected</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>HSE32 clock selected</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>pll1rclk clock selected</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x6</name>
                  <description>LSI clock selected</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7</name>
                  <description>LSE clock selected</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x8</name>
                  <description>pll1pclk clock selected</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x9</name>
                  <description>pll1qclk clock selected</description>
                  <value>0x9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xA</name>
                  <description>hclk5 clock selected</description>
                  <value>0xA</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MCOPRE</name>
              <description>microcontroller clock output prescaler
Set and cleared by software.
It is highly recommended to change this prescaler before MCO output is enabled.
others: not allowed</description>
              <bitOffset>28</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>MCO divided by 1</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>MCO divided by 2</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>MCO divided by 4</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>MCO divided by 8</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>MCO divided by 16</description>
                  <value>0x4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RCC_CFGR2</name>
          <displayName>RCC_CFGR2</displayName>
          <description>RCC clock configuration register 2</description>
          <addressOffset>0x020</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HPRE</name>
              <description>AHB1, AHB2 and AHB4 prescaler
Set and cleared by software to control the division factor of the AHB1, AHB2 and AHB4 clock (hclk1).
The software must limit the incremental frequency step by setting these bits correctly to ensure that the hclk1 maximum incremental frequency step does not exceed the maximum allowed incremental frequency step (for more details, refer to Table99: SYSCLK and bus maximum frequency). After a write operation to these bits and before decreasing the voltage range, this register must be read to be sure that the new value is taken into account.
0xx: hclk1 = SYSCLK not divided</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>hclk1 = SYSCLK divided by 2</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>hclk1 = SYSCLK divided by 4</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x6</name>
                  <description>hclk1 = SYSCLK divided by 8</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7</name>
                  <description>hclk1 = SYSCLK divided by 16</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PPRE1</name>
              <description>APB1 prescaler
Set and cleared by software to control the division factor of the APB1 clock (pclk1).
0xx: pclk1 = hclk1 not divided</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>pclk1 = hclk1 divided by 2</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>pclk1 = hclk1 divided by 4</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x6</name>
                  <description>pclk1 = hclk1 divided by 8</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7</name>
                  <description>pclk1 = hclk1 divided by 16</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PPRE2</name>
              <description>APB2 prescaler
Set and cleared by software to control the division factor of the APB2 clock (pclk2).
0xx: pclk2 = hclk1 not divided</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>pclk2 = hclk1 divided by 2</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>pclk2 = hclk1 divided by 4</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x6</name>
                  <description>pclk2 = hclk1 divided by 8</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7</name>
                  <description>pclk2 = hclk1 divided by 16</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RCC_CFGR3</name>
          <displayName>RCC_CFGR3</displayName>
          <description>RCC clock configuration register 3</description>
          <addressOffset>0x024</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PPRE7</name>
              <description>APB7 prescaler
Set and cleared by software to control the division factor of the APB7 clock (pclk7).
0xx: hclk1 not divided</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>hclk1 divided by 2</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>hclk1 divided by 4</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x6</name>
                  <description>hclk1 divided by 8</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7</name>
                  <description>hclk1 divided by 16</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RCC_PLL1CFGR</name>
          <displayName>RCC_PLL1CFGR</displayName>
          <description>RCC PLL1 configuration register</description>
          <addressOffset>0x028</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PLL1SRC</name>
              <description>PLL1 entry clock source
Set and cleared by software to select PLL1 clock source. These bits can be written only when the PLL1 is disabled.
Cleared by hardware when entering Stop or Standby modes. 
Note: In order to save power, when no PLL1 clock is used, the value of PLL1SRC must be 0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no clock sent to PLL1</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>HSI16 clock selected as PLL1 clock entry</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>HSE32 clock after HSEPRE divider selected as PLL1 clock entry</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PLL1RGE</name>
              <description>PLL1 input frequency range
Set and reset by software to select the proper reference frequency range used for PLL1.
This bit must be written before enabling the PLL1.
00-01-10: PLL1 input (ref1_ck) clock range frequency between 4 and 8 MHz</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>PLL1 input (ref1_ck) clock range frequency between 8 and 16 MHz</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PLL1FRACEN</name>
              <description>PLL1 fractional latch enable
Set and reset by software to latch the content of PLL1FRACN into the  modulator.
In order to latch the PLL1FRACN value into the  modulator, PLL1FRACEN must be set to 0, then set to 1: the transition 0 to 1 transfers the content of PLL1FRACN into the modulator (see PLL1 initialization phase for details).</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PLL1M</name>
              <description>Prescaler for PLL1
Set and cleared by software to configure the prescaler of the PLL1. The VCO1 input frequency is PLL1 input clock frequency/PLL1M.
This bit can be written only when the PLL1 is disabled (PLL1ON = 0 and PLL1RDY = 0). 
...</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>division by 1 (bypass)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>division by 2</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>division by 3</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7</name>
                  <description>division by 8</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PLL1PEN</name>
              <description>PLL1 DIVP divider output enable
Set and reset by software to enable the pll1pclk output of the PLL1.
To save power, PLL1PEN and PLL1P bits must be set to 0 when the pll1pclk is not used. 
This bit can be written only when the PLL1 is disabled (PLL1ON = 0 and PLL1RDY = 0).</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>pll1pclk output disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>pll1pclk output enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PLL1QEN</name>
              <description>PLL1 DIVQ divider output enable
Set and reset by software to enable the pll1qclk output of the PLL1.
To save power, PLL1QEN and PLL1Q bits must be set to 0 when the pll1qclk is not used. 
This bit can be written only when the PLL1 is disabled (PLL1ON = 0 and PLL1RDY = 0).</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>pll1qclk output disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>pll1qclk output enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PLL1REN</name>
              <description>PLL1 DIVR divider output enable
Set and cleared by software to enable the pll1rclk output of the PLL1.
To save power, PLL1REN and PLL1R bits must be set to 0 when the pll1rclk is not used.
This bit can be written only when the PLL1 is disabled (PLL1ON = 0 and PLL1RDY = 0).</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>pll1rclk output disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>pll1rclk output enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PLL1RCLKPRE</name>
              <description>pll1rclk clock for SYSCLK prescaler division enable
Set and cleared by software to control the division of the pll1rclk clock for SYSCLK.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>pll1rclk not divided, sysclkpre = pll1rclk</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>pll1rclk divided, sysclkpre = pll1rclk divided</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PLL1RCLKPRESTEP</name>
              <description>pll1rclk clock for SYSCLK prescaler division step selection
Set and cleared by software to control the division step of the pll1rclk clock for SYSCLK.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>pll1rclk 2-step division</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>pll1rclk 3-step division</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PLL1RCLKPRERDY</name>
              <description>pll1rclkpre not divided ready.
Set by hardware after PLL1RCLKPRE has been set from divided to not divide, to indicate that the pll1rclk not divided is available on sysclkpre.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>pll1rclk divided</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>pll1rclk not divided ready</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RCC_PLL1DIVR</name>
          <displayName>RCC_PLL1DIVR</displayName>
          <description>RCC PLL1 dividers register</description>
          <addressOffset>0x034</addressOffset>
          <size>0x20</size>
          <resetValue>0x01010280</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PLL1N</name>
              <description>Multiplication factor for PLL1 VCO
Set and reset by software to control the multiplication factor of the VCO.
These bits can be written only when the PLL1 is disabled (PLL1ON = 0 and PLL1RDY = 0).
...
...
others: reserved
VCO output frequency = Fsubref1_ck/sub x multiplication factor for PLL1 VCO, when fractional value 0 has been loaded into PLL1FRACN, with: 
Multiplication factor for PLL1 VCO between 4 and 512
input frequency Fsubref1_ck/sub between 4 and 16MHz</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x003</name>
                  <description>multiplication factor for PLL1 VCO= 4</description>
                  <value>0x003</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x004</name>
                  <description>multiplication factor for PLL1 VCO = 5</description>
                  <value>0x004</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x005</name>
                  <description>multiplication factor for PLL1 VCO = 6</description>
                  <value>0x005</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x080</name>
                  <description>multiplication factor for PLL1 VCO = 129 (default after reset)</description>
                  <value>0x080</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1FF</name>
                  <description>multiplication factor for PLL1 VCO = 512</description>
                  <value>0x1FF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PLL1P</name>
              <description>PLL1 DIVP division factor
Set and reset by software to control the frequency of the pll1pclk clock.
These bits can be written only when the PLL1 is disabled (PLL1ON = 0 and PLL1RDY = 0).
Note that odd division factors are not allowed.
...</description>
              <bitOffset>9</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Not allowed</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>pll1pclk = VCO output frequency / 2 (default after reset)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>not allowed</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>pll1pclk = VCO output frequency / 4</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7F</name>
                  <description>pll1pclk = VCO output frequency / 128</description>
                  <value>0x7F</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PLL1Q</name>
              <description>PLL1 DIVQ division factor
Set and reset by software to control the frequency of the PLl1QCLK clock.
These bits can be written only when the PLL1 is disabled (PLL1ON = 0 and PLL1RDY = 0).
...</description>
              <bitOffset>16</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>PLl1QCLK = VCO output frequency</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>PLl1QCLK = VCO output frequency / 2 (default after reset)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>PLl1QCLK = VCO output frequency / 3</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>PLl1QCLK = VCO output frequency / 4</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7F</name>
                  <description>PLl1QCLK = VCO output frequency / 128</description>
                  <value>0x7F</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PLL1R</name>
              <description>PLL1 DIVR division factor
Set and reset by software to control the frequency of the pll1rclk clock.
These bits can be written only when the PLL1 is disabled (PLL1ON = 0 and PLL1RDY = 0).
...</description>
              <bitOffset>24</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>pll1rclk = VCO output frequency</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>pll1rclk = VCO output frequency / 2 (default after reset)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>pll1rclk = VCO output frequency / 3</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>pll1rclk = VCO output frequency / 4</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7F</name>
                  <description>pll1rclk = VCO output frequency / 128</description>
                  <value>0x7F</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RCC_PLL1FRACR</name>
          <displayName>RCC_PLL1FRACR</displayName>
          <description>RCC PLL1 fractional divider register</description>
          <addressOffset>0x038</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PLL1FRACN</name>
              <description>Fractional part of the multiplication factor for PLL1 VCO
Set and reset by software to control the fractional part of the multiplication factor of the VCO.
These bits can be written at any time, allowing dynamic fine-tuning of the PLL1 VCO.
VCO output frequency = Fsubref1_ck/sub x [multiplication factor for PLL1 VCO + (PLL1FRACN / 2sup13/sup)], with: 
Multiplication factor for PLL1 VCO must be between 4 and 512.
PLL1FRACN can be between 0 and 2sup13/sup- 1.
The input frequency Fsubref1_ck/sub must be between 4 and 16 MHz. 
To change the used fractional value on-the-fly even if the PLL1 is enabled, the application must proceed as follows:
Set the bit PLL1FRACEN to 0. 
Write the new fractional value into PLL1FRACN. 
Set the bit PLL1FRACEN to 1.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>13</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RCC_CIER</name>
          <displayName>RCC_CIER</displayName>
          <description>RCC clock interrupt enable register</description>
          <addressOffset>0x050</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LSI1RDYIE</name>
              <description>LSI1 ready interrupt enable
Set and cleared by software to enable/disable interrupt caused by the LSI1 oscillator stabilization.
Access to the bit can be secured by RCC LSISEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>LSI1 ready interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>LSI1 ready interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LSERDYIE</name>
              <description>LSE ready interrupt enable
Set and cleared by software to enable/disable interrupt caused by the LSE oscillator stabilization.
Access to the bit can be secured by RCC LSESEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>LSE ready interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>LSE ready interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HSIRDYIE</name>
              <description>HSI16 ready interrupt enable
Set and cleared by software to enable/disable interrupt caused by the HSI16 oscillator stabilization.
Access to the bit can be secured by RCC HSISEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>HSI16 ready interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>HSI16 ready interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HSERDYIE</name>
              <description>HSE32 ready interrupt enable
Set and cleared by software to enable/disable interrupt caused by the HSE32 oscillator stabilization.
Access to the bit can be secured by RCC HSESEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>HSE32 ready interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>HSE32 ready interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PLL1RDYIE</name>
              <description>PLL1 ready interrupt enable
Set and cleared by software to enable/disable interrupt caused by PLL1 lock.
Access to the bit can be secured by RCC PLL1SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>PLL1 lock interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>PLL1 lock interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RCC_CIFR</name>
          <displayName>RCC_CIFR</displayName>
          <description>RCC clock interrupt flag register</description>
          <addressOffset>0x054</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LSI1RDYF</name>
              <description>LSI1 ready interrupt flag
Set by hardware when the LSI1 clock becomes stable and LSI1RDYIE is set.
Cleared by software setting the LSI1RDYC bit.
Access to the bit can be secured by RCC LSISEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no clock ready interrupt caused by the LSI1 oscillator</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>clock ready interrupt caused by the LSI1 oscillator</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LSERDYF</name>
              <description>LSE ready interrupt flag
Set by hardware when the LSE clock becomes stable and LSERDYIE is set.
Cleared by software setting the LSERDYC bit.
Access to the bit can be secured by RCC LSESEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no clock ready interrupt caused by the LSE oscillator</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>clock ready interrupt caused by the LSE oscillator</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HSIRDYF</name>
              <description>HSI16 ready interrupt flag
Set by hardware when the HSI16 clock becomes stable and HSIRDYIE is set in a response to setting the HSION (see RCC_CR). When HSION is not set but the HSI16 oscillator is enabled by the peripheral through a clock request, this bit is not set and no interrupt is generated.
Access to the bit can be secured by RCC HSISEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.
Cleared by software setting the HSIRDYC bit.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no clock ready interrupt caused by the HSI16 oscillator</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>clock ready interrupt caused by the HSI16 oscillator</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HSERDYF</name>
              <description>HSE32 ready interrupt flag
Set by hardware when the HSE32 clock becomes stable and HSERDYIE is set.
Cleared by software setting the HSERDYC bit.
Access to the bit can be secured by RCC HSESEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no clock ready interrupt caused by the HSE32 oscillator</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>clock ready interrupt caused by the HSE32 oscillator</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PLL1RDYF</name>
              <description>PLL1 ready interrupt flag
Set by hardware when the PLL1 locks and PLL1RDYIE is set.
Cleared by software setting the PLL1RDYC bit.
Access to the bit can be secured by RCC PLL1SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no clock ready interrupt caused by PLL1 lock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>clock ready interrupt caused by PLL1 lock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HSECSSF</name>
              <description>HSE32 clock security system interrupt flag
Set by hardware when a clock security failure is detected in the HSE32 oscillator.
Cleared by software setting the HSECSSC bit.
Access to the bit can be secured by RCC HSESEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no clock security interrupt caused by HSE32 clock failure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>clock security interrupt caused by HSE32 clock failure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RCC_CICR</name>
          <displayName>RCC_CICR</displayName>
          <description>RCC clock interrupt clear register</description>
          <addressOffset>0x058</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LSI1RDYC</name>
              <description>LSI1 ready interrupt clear
Writing this bit to 1 clears the LSI1RDYF flag. Writing 0 has no effect.
Access to the bit can be secured by RCC LSISEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>LSERDYC</name>
              <description>LSE ready interrupt clear
Writing this bit to 1 clears the LSERDYF flag. Writing 0 has no effect.
Access to the bit can be secured by RCC LSESEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>HSIRDYC</name>
              <description>HSI16 ready interrupt clear
Writing this bit to 1 clears the HSIRDYF flag. Writing 0 has no effect.
Access to the bit can be secured by RCC HSISEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>HSERDYC</name>
              <description>HSE32 ready interrupt clear
Writing this bit to 1 clears the HSERDYF flag. Writing 0 has no effect.
Access to the bit can be secured by RCC HSESEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>PLL1RDYC</name>
              <description>PLL1 ready interrupt clear
Writing this bit to 1 clears the PLL1RDYF flag. Writing 0 has no effect.
Access to the bit can be secured by RCC PLL1SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>HSECSSC</name>
              <description>High speed external clock security system interrupt clear
Writing this bit to 1 clears the HSECSSF flag. Writing 0 has no effect.
Access to the bit can be secured by RCC HSESEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RCC_AHB1RSTR</name>
          <displayName>RCC_AHB1RSTR</displayName>
          <description>RCC AHB1 peripheral reset register</description>
          <addressOffset>0x060</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPDMA1RST</name>
              <description>GPDMA1 reset
Set and cleared by software.
Access can be secured by GPDMA1 SECx. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset GPDMA1</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CRCRST</name>
              <description>CRC reset
Set and cleared by software.
Access can be secured by GTZC_TZSC CRCSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset CRC</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSCRST</name>
              <description>TSC reset
Set and cleared by software.
Access can be secured by GTZC_TZSC TSCSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset TSC</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RCC_AHB2RSTR</name>
          <displayName>RCC_AHB2RSTR</displayName>
          <description>RCC AHB2 peripheral reset register</description>
          <addressOffset>0x064</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPIOARST</name>
              <description>IO port A reset
Set and cleared by software.
Access can be secured by GPIOA SECx. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset IO port A</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>GPIOBRST</name>
              <description>IO port B reset
Set and cleared by software.
Access can be secured by GPIOB SECx. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset IO port B</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>GPIOCRST</name>
              <description>IO port C reset
Set and cleared by software.
Access can be secured by GPIOC SECx. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset IO port C</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>GPIOHRST</name>
              <description>IO port H reset
Set and cleared by software.
Access can be secured by GPIOH SECx. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset IO port H</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AESRST</name>
              <description>AES hardware accelerator reset
Set and cleared by software.
Access can be secured by GTZC_TZSC AESSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset AES</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HASHRST</name>
              <description>Hash reset
Set and cleared by software.
Access can be secured by GTZC_TZSC HASHSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset HASH</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RNGRST</name>
              <description>Random number generator reset
Set and cleared by software.
Access can be secured by GTZC_TZSC RNGSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset RNG</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SAESRST</name>
              <description>SAES hardware accelerator reset
Set and cleared by software.
Access can be secured by GTZC_TZSC SAESSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset SAES</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HSEMRST</name>
              <description>HSEM hardware accelerator reset
Set and cleared by software.
Can only be accessed secure when one or more features in the HSEM is secure. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset HSEM</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PKARST</name>
              <description>PKA reset
Set and cleared by software.
Access can be secured by GTZC_TZSC PKASEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset PKA</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RCC_AHB4RSTR</name>
          <displayName>RCC_AHB4RSTR</displayName>
          <description>RCC AHB4 peripheral reset register</description>
          <addressOffset>0x06C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADC4RST</name>
              <description>ADC4 reset
Set and cleared by software.
Access can be secred by GTZC_TZSC ADC4SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset ADC4 interface</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RCC_AHB5RSTR</name>
          <displayName>RCC_AHB5RSTR</displayName>
          <description>RCC AHB5 peripheral reset register</description>
          <addressOffset>0x070</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RADIORST</name>
              <description>2.4 GHz RADIO reset
Set and cleared by software.
Access can be secured by GTZC_TZSC RADIOSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset 2.4 GHz RADIO</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RCC_APB1RSTR1</name>
          <displayName>RCC_APB1RSTR1</displayName>
          <description>RCC APB1 peripheral reset register 1</description>
          <addressOffset>0x074</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIM2RST</name>
              <description>TIM2 reset
Set and cleared by software.
Access can be secured by GTZC_TZSC TIM2SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset TIM2</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TIM3RST</name>
              <description>TIM3 reset
Set and cleared by software.
Access can be secured by GTZC_TZSC TIM3SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset TIM3</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>USART2RST</name>
              <description>USART2 reset
Set and cleared by software.
Access can be secured by GTZC_TZSC UART2SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset USART2</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>I2C1RST</name>
              <description>I2C1 reset
Set and cleared by software.
Access can be secured by GTZC_TZSC I2C1SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset I2C1</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RCC_APB1RSTR2</name>
          <displayName>RCC_APB1RSTR2</displayName>
          <description>RCC APB1 peripheral reset register 2</description>
          <addressOffset>0x078</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LPTIM2RST</name>
              <description>LPTIM2 reset
Set and cleared by software.
Access can be secured by GTZC_TZSC LPTIM2SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset LPTIM2</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RCC_APB2RSTR</name>
          <displayName>RCC_APB2RSTR</displayName>
          <description>RCC APB2 peripheral reset register</description>
          <addressOffset>0x07C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIM1RST</name>
              <description>TIM1 reset
Set and cleared by software.
Access can be secured by GTZC_TZSC TIM1SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset TIM1</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SPI1RST</name>
              <description>SPI1 reset
Set and cleared by software.
Access can be secured by GTZC_TZSC SPI1SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset SPI1</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>USART1RST</name>
              <description>USART1 reset
Set and cleared by software.
Access can be secured by GTZC_TZSC USART1SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset USART1</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TIM16RST</name>
              <description>TIM16 reset
Set and cleared by software.
Access can be secured by GTZC_TZSC TIM16SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset TIM16</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TIM17RST</name>
              <description>TIM17 reset
Set and cleared by software.
Access can be secured by GTZC_TZSC TIM17SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset TIM17</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RCC_APB7RSTR</name>
          <displayName>RCC_APB7RSTR</displayName>
          <description>RCC APB7 peripheral reset register</description>
          <addressOffset>0x080</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SYSCFGRST</name>
              <description>SYSCFG reset
Set and cleared by software.
Access can be secured by SYSCFG SYSCFGSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset SYSCFG</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SPI3RST</name>
              <description>SPI3 reset
Set and cleared by software.
Access can be secured by GTZC_TZSC SPI3SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset SPI3</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LPUART1RST</name>
              <description>LPUART1 reset
Set and cleared by software.
Access can be secured by GTZC_TZSC LPUART1SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset LPUART1</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>I2C3RST</name>
              <description>I2C3 reset
Set and cleared by software.
Access can be secured by GTZC_TZSC I2C3SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset I2C3</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LPTIM1RST</name>
              <description>LPTIM1 reset
Set and cleared by software.
Access can be secured by GTZC_TZSC LPTIM1SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset LPTIM1</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RCC_AHB1ENR</name>
          <displayName>RCC_AHB1ENR</displayName>
          <description>RCC AHB1 peripheral clock enable register</description>
          <addressOffset>0x088</addressOffset>
          <size>0x20</size>
          <resetValue>0x80000100</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPDMA1EN</name>
              <description>GPDMA1 bus clock enable
Set and cleared by software.
Access can be secured by GPDMA1 SECx. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>GPDMA1 bus clock disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GPDMA1 bus clock enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FLASHEN</name>
              <description>FLASH bus clock enable
Set and cleared by software. This bit can be disabled only when the Flash memory is in power down mode.
Can only be accessed secured when the Flash security state is secure. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>FLASH bus clock disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>FLASH bus clock enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CRCEN</name>
              <description>CRC bus clock enable
Set and cleared by software.
Access can be secured by GTZC_TZSC CRCSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>CRC bus clock disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>CRC bus clock enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSCEN</name>
              <description>Touch sensing controller bus clock enable
Set and cleared by software.
Access can be secured by GTZC_TZSC TSCSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>TSC bus clock disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>TSC bus clock enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RAMCFGEN</name>
              <description>RAMCFG bus clock enable
Set and cleared by software.
Access can be secured by GTZC_TZSC RAMCFGSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>RAMCFG bus clock disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>RAMCFG bus clock enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>GTZC1EN</name>
              <description>GTZC1 bus clock enable 
Set and reset by software.
Can only be accessed secure when device is secure (TZEN = 1). When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>GTZC1 bus clock disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GTZC1 bus clock enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRAM1EN</name>
              <description>SRAM1 bus clock enable 
Set and reset by software.
Access can be secured by GTZC_MPCBB1 SECx, INVSECSTATE. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>SRAM1 bus clock disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>SRAM1 bus clock enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RCC_AHB2ENR</name>
          <displayName>RCC_AHB2ENR</displayName>
          <description>RCC AHB2 peripheral clock enable register</description>
          <addressOffset>0x08C</addressOffset>
          <size>0x20</size>
          <resetValue>0x40000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPIOAEN</name>
              <description>IO port A bus clock enable
Set and cleared by software.
Access can be secured by GPIOA SECx. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>IO port A bus clock disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>IO port A bus clock enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>GPIOBEN</name>
              <description>IO port B bus clock enable
Set and cleared by software.
Access can be secured by GPIOB SECx. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>IO port B bus clock disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>IO port B bus clock enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>GPIOCEN</name>
              <description>IO port C bus clock enable
Set and cleared by software.
Access can be secured by GPIOC SECx. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>IO port C bus clock disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>IO port C bus clock enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>GPIOHEN</name>
              <description>IO port H bus clock enable
Set and cleared by software.
Access can be secured by GPIOH SECx. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>IO port H bus clock disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>IO port H bus clock enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AESEN</name>
              <description>AES bus clock enable
Set and cleared by software.
Access can be secured by GTZC_TZSC AESSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>AES bus clock disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>AES bus clock enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HASHEN</name>
              <description>HASH bus clock enable
Set and cleared by software.
Access can be secured by GTZC_TZSC HASHSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>HASH bus clock disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>HASH bus clock enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RNGEN</name>
              <description>RNG bus and kernel clocks enable
Set and cleared by software.
Access can be secured by GTZC_TZSC RNGSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>RNG bus and kernel clocks disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>RNG bus and kernel clocks enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SAESEN</name>
              <description>SAES bus clock enable
Set and cleared by software.
Access can be secured by GTZC_TZSC SAESSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>SAES bus clock disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>SAES bus clock enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HSEMEN</name>
              <description>HSEM bus clock enable
Set and cleared by software.
Can only be accessed secure when one or more features in the HSEM is secure. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>HSEM bus clock disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>HSEM bus clock enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PKAEN</name>
              <description>PKA bus clock enable
Set and cleared by software.
Access can be secured by GTZC_TZSC PKASEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>PKA bus clock disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>PKA bus clock enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRAM2EN</name>
              <description>SRAM2 bus clock enable
Set and cleared by software.
Access can be secured by GTZC_MPCBB2 SECx, INVSECSTATE. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>SRAM2 bus clock disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>SRAM2 bus clock enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RCC_AHB4ENR</name>
          <displayName>RCC_AHB4ENR</displayName>
          <description>RCC AHB4 peripheral clock enable register</description>
          <addressOffset>0x094</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PWREN</name>
              <description>PWR bus clock enable
Set and cleared by software.
Can only be accessed secure when one or more features in the PWR is/are secure. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>PWR bus clock disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>PWR bus clock enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADC4EN</name>
              <description>ADC4 bus and kernel clocks enable
Set and cleared by software.
Access can be secured by GTZC_TZSC ADC4SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>ADC4 bus and kernel clocks disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>ADC4 bus and kernel clocks enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RCC_AHB5ENR</name>
          <displayName>RCC_AHB5ENR</displayName>
          <description>RCC AHB5 peripheral clock enable register</description>
          <addressOffset>0x098</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RADIOEN</name>
              <description>2.4 GHz RADIO bus clock enable
Set and cleared by software.
Access can be secured by GTZC_TZSC RADIOSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.
Before accessing the 2.4 GHz RADIO sleep timers registers the RADIOCLKRDY bit must be checked.
Note: When RADIOSMEN and STRADIOCLKON are both cleared, RADIOCLKRDY bit must be re-checked when exiting low-power modes (Sleep and Stop).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>2.4 GHz RADIO bus clock disabled (The 2.4 GHz RADIO bus clock may still be enabled by STRADIOCLKON)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>2.4 GHz RADIO bus clock enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RCC_APB1ENR1</name>
          <displayName>RCC_APB1ENR1</displayName>
          <description>RCC APB1 peripheral clock enable register 1</description>
          <addressOffset>0x09C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIM2EN</name>
              <description>TIM2 bus and kernel clocks enable
Set and cleared by software.
Access can be secured by GTZC_TZSC TIM2SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>TIM2 bus and kernel clocks disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>TIM2 bus and kernel clocks enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TIM3EN</name>
              <description>TIM3 bus and kernel clocks enable
Set and cleared by software.
Access can be secured by GTZC_TZSC TIM2SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>TIM3 bus and kernel clocks disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>TIM3 bus and kernel clocks enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WWDGEN</name>
              <description>WWDG bus clock enable
Set by software to enable the window watchdog bus clock. Reset by hardware system reset.
This bit can also be set by hardware if the WWDG_SW option bit is reset.
Access can be secured by GTZC_TZSC WWDGSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>WWDG bus clock disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>WWDG bus clock enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>USART2EN</name>
              <description>USART2 bus and kernel clocks enable
Set and cleared by software.
Access can be secured by GTZC_TZSC USART2SEC When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV..</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>USART2 bus and kernel clocks disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>USART2 bus and kernel clocks enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>I2C1EN</name>
              <description>I2C1 bus and kernel clocks enable
Set and cleared by software.
Access can be secured by GTZC_TZSC I2C1SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>I2C1 bus and kernel clocks disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>I2C1 bus and kernel clocks enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RCC_APB1ENR2</name>
          <displayName>RCC_APB1ENR2</displayName>
          <description>RCC APB1 peripheral clock enable register 2</description>
          <addressOffset>0x0A0</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LPTIM2EN</name>
              <description>LPTIM2 bus and kernel clocks enable
Set and cleared by software.
Access can be secured by GTZC_TZSC LPTIM2SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>LPTIM2 bus and kernel clocks disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>LPTIM2 bus and kernel clocks enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RCC_APB2ENR</name>
          <displayName>RCC_APB2ENR</displayName>
          <description>RCC APB2 peripheral clock enable register</description>
          <addressOffset>0x0A4</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIM1EN</name>
              <description>TIM1 bus and kernel clocks enable
Set and cleared by software.
Access can be secured by GTZC_TZSC TIM1SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>TIM1 bus and kernel clocks disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>TIM1 bus and kernel clocks enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SPI1EN</name>
              <description>SPI1 bus and kernel clocks enable
Set and cleared by software.
Access can be secured by GTZC_TZSC SPI1SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>SPI1 bus and kernel clocks disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>SPI1 bus and kernel clocks enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>USART1EN</name>
              <description>USART1bus and kernel clocks enable
Set and cleared by software.
Access can be secured by GTZC_TZSC USART1SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>USART1 bus and kernel clocks disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>USART1 bus and kernel clocks enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TIM16EN</name>
              <description>TIM16 bus and kernel clocks enable
Set and cleared by software.
Access can be secured by GTZC_TZSC TIM16SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>TIM16 bus and kernel clocks disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>TIM16 bus and kernel clocks enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TIM17EN</name>
              <description>TIM17 bus and kernel clocks enable
Set and cleared by software.
Access can be secured by GTZC_TZSC TIM17SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>TIM17 bus and kernel clocks disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>TIM17 bus and kernel clocks enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RCC_APB7ENR</name>
          <displayName>RCC_APB7ENR</displayName>
          <description>RCC APB7 peripheral clock enable register</description>
          <addressOffset>0x0A8</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SYSCFGEN</name>
              <description>SYSCFG bus clock enable
Set and cleared by software.
Access can be secured by SYSCFG SYSCFGSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>SYSCFG bus clock disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>SYSCFG bus clock enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SPI3EN</name>
              <description>SPI3 bus and kernel clocks enable
Set and cleared by software.
Access can be secured by GTZC_TZSC SPI3SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>SPI3 bus and kernel clocks disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>SPI3 bus and kernel clocks enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LPUART1EN</name>
              <description>LPUART1 bus and kernel clocks enable
Set and cleared by software.
Access can be secured by GTZC_TZSC LPUART1SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>LPUART1 bus and kernel clocks disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>LPUART1 bus and kernel clocks enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>I2C3EN</name>
              <description>I2C3 bus and kernel clocks enable
Set and cleared by software.
Access can be secured by GTZC_TZSC I2C3SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>I2C3 bus and kernel clocks disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>I2C3 bus and kernel clocks enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LPTIM1EN</name>
              <description>LPTIM1 bus and kernel clocks enable
Set and cleared by software.
Access can be secured by GTZC_TZSC LPTIM1SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>LPTIM1 bus and kernel clocks disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>LPTIM1 bus and kernel clocks enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RTCAPBEN</name>
              <description>RTC and TAMP bus clock enable
Set and cleared by software.
Can only be accessed secure when one or more features in the RTC or TAMP is/are secure. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>RTC bus clock disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>RTC bus clock enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RCC_AHB1SMENR</name>
          <displayName>RCC_AHB1SMENR</displayName>
          <description>RCC AHB1 peripheral clocks enable in Sleep and Stop modes register</description>
          <addressOffset>0x0B0</addressOffset>
          <size>0x20</size>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPDMA1SMEN</name>
              <description>GPDMA1 bus clock enable during Sleep and Stop modes
Set and cleared by software.
Access can be secured by GPDMA1 SECx. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.
Note: This bit must be set to allow the peripheral to wake up from Stop modes.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>GPDMA1 bus clock disabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GPDMA1 bus clock enabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FLASHSMEN</name>
              <description>FLASH bus clock enable during Sleep and Stop modes
Set and cleared by software.
Can only be accessed secured when the Flash security state is secure. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>FLASH bus clock disabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>FLASH bus clock enabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CRCSMEN</name>
              <description>CRC bus clock enable during Sleep and Stop modes
Set and cleared by software.
Access can be secured by GTZC_TZSC CRCSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>CRC bus clock disabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>CRC bus clock enabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSCSMEN</name>
              <description>TSC bus clock enable during Sleep and Stop modes
Set and cleared by software.
Access can be secured by GTZC_TZSC TSCSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV..</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>TSC bus clock disabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>TSC bus clock enabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RAMCFGSMEN</name>
              <description>RAMCFG bus clock enable during Sleep and Stop modes
Set and cleared by software.
Access can be secured by GTZC_TZSC RAMCFGSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>RAMCFG bus clock disabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>RAMCFG bus clock enabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>GTZC1SMEN</name>
              <description>GTZC1 bus clock enable during Sleep and Stop modes
Set and cleared by software.
Can only be accessed secure when one device is secure (TZEN = 1). When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>GTZC1 bus clock disabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>GTZC1 bus clock enabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ICACHESMEN</name>
              <description>ICACHE bus clock enable during Sleep and Stop modes
Set and cleared by software.
Access can be secured by GTZC_TZSC ICACHE_REGSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV..</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>ICACHE bus clock disabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>ICACHE bus clock enabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRAM1SMEN</name>
              <description>SRAM1 bus clock enable during Sleep and Stop modes
Set and cleared by software.
Access can be secured by GTZC_MPCBB1 SECx, INVSECSTATE. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>SRAM1 bus clock disabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>SRAM1 bus clock enabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RCC_AHB2SMENR</name>
          <displayName>RCC_AHB2SMENR</displayName>
          <description>RCC AHB2 peripheral clocks enable in Sleep and Stop modes register</description>
          <addressOffset>0x0B4</addressOffset>
          <size>0x20</size>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPIOASMEN</name>
              <description>IO port A bus clock enable during Sleep and Stop modes
Set and cleared by software.
Access can be secured by GPIOA SECx. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>IO port A bus clock disabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>IO port A bus clock enabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>GPIOBSMEN</name>
              <description>IO port B bus clock enable during Sleep and Stop modes
Set and cleared by software.
Access can be secured by GPIOB SECx. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>IO port B bus clock disabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>IO port B bus clock enabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>GPIOCSMEN</name>
              <description>IO port C bus clock enable during Sleep and Stop modes
Set and cleared by software.
Access can be secured by GPIOC SECx. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>IO port C bus clock disabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>IO port C bus clock enabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>GPIOHSMEN</name>
              <description>IO port H bus clock enable during Sleep and Stop modes
Set and cleared by software.
Access can be secured by GPIOH SECx. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>IO port H bus clock disabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>IO port H bus clock enabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AESSMEN</name>
              <description>AES bus clock enable during Sleep and Stop modes
Set and cleared by software.
Access can be secured by GTZC_TZSC AESSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>AES bus clock disabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>AES bus clock enabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HASHSMEN</name>
              <description>HASH bus clock enable during Sleep and Stop modes
Set and cleared by software.
Access can be secured by GTZC_TZSC HASHSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>HASH bus clock disabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>HASH bus clock enabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RNGSMEN</name>
              <description>Random number generator (RNG) bus and kernel clocks enable during Sleep and Stop modes
Set and cleared by software.
Access can be secured by GTZC_TZSC RNGSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>RNG bus and kernel clocks disabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>RNG bus and kernel clocks enabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SAESSMEN</name>
              <description>SAES accelerator bus clock enable during Sleep and Stop modes
Set and cleared by software.
Access can be secured by GTZC_TZSC SAESSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>SAES bus clock disabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>SAES bus clock enabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PKASMEN</name>
              <description>PKA bus clock enable during Sleep and Stop modes
Set and cleared by software.
Access can be secured by GTZC_TZSC PKASEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>PKA bus clock disabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>PKA bus clock enabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRAM2SMEN</name>
              <description>SRAM2 bus clock enable during Sleep and Stop modes
Set and cleared by software.
Access can be secured by GTZC_MPCBB2 SECx, INVSECSTATE. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>SRAM2 bus clock disabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>SRAM2 bus clock enabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RCC_AHB4SMENR</name>
          <displayName>RCC_AHB4SMENR</displayName>
          <description>RCC AHB4 peripheral clocks enable in Sleep and Stop modes register</description>
          <addressOffset>0x0BC</addressOffset>
          <size>0x20</size>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PWRSMEN</name>
              <description>PWR bus clock enable during Sleep and Stop modes
Set and cleared by software.
Can only be accessed secure when one or more features in the PWR is/are secure. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>PWR bus clock disabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>PWR bus clock enabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADC4SMEN</name>
              <description>ADC4 bus and kernel clocks enable during Sleep and Stop modes
Set and cleared by software.
Access can be secured by GTZC_TZSC ADC4SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.
Note: This bit must be set to allow the peripheral to wake up from Stop modes.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>ADC4 bus and kernel clocks disabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>ADC4 bus and kernel clocks enabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RCC_AHB5SMENR</name>
          <displayName>RCC_AHB5SMENR</displayName>
          <description>RCC AHB5 peripheral clocks enable in Sleep and Stop modes register</description>
          <addressOffset>0x0C0</addressOffset>
          <size>0x20</size>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RADIOSMEN</name>
              <description>2.4 GHz RADIO bus clock enable during Sleep and Stop modes when the 2.4 GHz RADIO is active.
Set and cleared by software.
Access can be secured by GTZC_TZSC RADIOSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>2.4 GHz RADIO bus clock disabled by the clock gating during Sleep and Stop modes (The 2.4 GHz RADIO bus clock may still be enabled by STRADIOCLKON)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>2.4 GHz RADIO bus clock enabled by the clock gating during Sleep and Stop modes when the 2.4 GHz RADIO is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RCC_APB1SMENR1</name>
          <displayName>RCC_APB1SMENR1</displayName>
          <description>RCC APB1 peripheral clocks enable in Sleep and Stop modes	register 1</description>
          <addressOffset>0x0C4</addressOffset>
          <size>0x20</size>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIM2SMEN</name>
              <description>TIM2 bus and kernel clocks enable during Sleep and Stop modes
Set and cleared by software.
Access can be secured by GTZC_TZSC TIM2SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>TIM2 bus and kernel clocks disabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>TIM2 bus and kernel clocks enabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TIM3SMEN</name>
              <description>TIM3 bus and kernel clocks enable during Sleep and Stop modes
Set and cleared by software.
Access can be secured by GTZC_TZSC TIM3SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>TIM3 bus and kernel clocks disabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>TIM3 bus and kernel clocks enabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WWDGSMEN</name>
              <description>Window watchdog bus clock enable during Sleep and Stop modes
Set and cleared by software. This bit is forced to 1 by hardware when the hardware WWDG option is activated.
Access can be secured by GTZC_TZSC WWDGSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>WWDG bus clock disabled by the clock gating during Sleep mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>WWDG bus clock enabled by the clock gating during Sleep mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>USART2SMEN</name>
              <description>USART2 bus and kernel clocks enable during Sleep and Stop modes
Set and cleared by software.
Access can be secured by GTZC_TZSC USART2SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.
Note: This bit must be set to allow the peripheral to wake up from Stop modes.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>USART2 bus and kernel clocks disabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>USART2 bus and kernel clocks enabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>I2C1SMEN</name>
              <description>I2C1 bus and kernel clocks enable during Sleep and Stop modes
Set and cleared by software.
Access can be secured by GTZC_TZSC I2C1SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.
Note: This bit must be set to allow the peripheral to wake up from Stop modes.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>I2C1 bus and kernel clocks disabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>I2C1 bus and kernel clocks enabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RCC_APB1SMENR2</name>
          <displayName>RCC_APB1SMENR2</displayName>
          <description>RCC APB1 peripheral clocks enable in Sleep and Stop modes 	register 2</description>
          <addressOffset>0x0C8</addressOffset>
          <size>0x20</size>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LPTIM2SMEN</name>
              <description>LPTIM2 bus and kernel clocks enable during Sleep and Stop modes
Set and cleared by software.
Access can be secured by GTZC_TZSC LPTIM2SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.
Note: This bit must be set to allow the peripheral to wake up from Stop modes.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>LPTIM2 bus and kernel clocks disabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>LPTIM2 bus and kernel clocks enabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RCC_APB2SMENR</name>
          <displayName>RCC_APB2SMENR</displayName>
          <description>RCC APB2 peripheral clocks enable in Sleep and Stop modes register</description>
          <addressOffset>0x0CC</addressOffset>
          <size>0x20</size>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIM1SMEN</name>
              <description>TIM1 bus and kernel clocks enable during Sleep and Stop modes
Set and cleared by software.
Access can be secured by GTZC_TZSC TIM1SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>TIM1 bus and kernel clocks disabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>TIM1 bus and kernel clocks enabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SPI1SMEN</name>
              <description>SPI1 bus and kernel clocks enable during Sleep and Stop modes
Set and cleared by software.
Access can be secured by GTZC_TZSC SPI1SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.
Note: This bit must be set to allow the peripheral to wake up from Stop modes.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>SPI1 bus and kernel clocks disabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>SPI1 bus and kernel clocks enabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>USART1SMEN</name>
              <description>USART1 bus and kernel clocks enable during Sleep and Stop modes
Set and cleared by software.
Access can be secured by GTZC_TZSC USART1SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.
Note: This bit must be set to allow the peripheral to wake up from Stop modes.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>USART1 bus and kernel clocks disabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>USART1 bus and kernel clocks enabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TIM16SMEN</name>
              <description>TIM16 bus and kernel clocks enable during Sleep and Stop modes
Set and cleared by software.
Access can be secured by GTZC_TZSC TIM16SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>TIM16 bus and kernel clocks disabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>TIM16 bus and kernel clocks enabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TIM17SMEN</name>
              <description>TIM17 bus and kernel clocks enable during Sleep and Stop modes
Set and cleared by software.
Access can be secured by GTZC_TZSC TIM17SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>TIM17 bus and kernel clocks disabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>TIM17 bus and kernel clocks enabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RCC_APB7SMENR</name>
          <displayName>RCC_APB7SMENR</displayName>
          <description>RCC APB7 peripheral clock enable in Sleep and Stop modes register</description>
          <addressOffset>0x0D0</addressOffset>
          <size>0x20</size>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SYSCFGSMEN</name>
              <description>SYSCFG bus clock enable during Sleep and Stop modes
Set and cleared by software.
Access can be secured by SYSCFG SYSCFGSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>SYSCFG bus clock disabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>SYSCFG bus clock enabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SPI3SMEN</name>
              <description>SPI3 bus and kernel clocks enable during Sleep and Stop modes
Set and cleared by software.
Access can be secured by GTZC_TZSC SPI3SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.
Note: This bit must be set to allow the peripheral to wake up from Stop modes.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>SPI3 bus and kernel clocks disabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>SPI3 bus and kernel clocks enabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LPUART1SMEN</name>
              <description>LPUART1 bus and kernel clocks enable during Sleep and Stop modes
Set and cleared by software.
Access can be secured by GTZC_TZSC LPUART1SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.
Note: This bit must be set to allow the peripheral to wake up from Stop modes.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>LPUART1 bus and kernel clocks disabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>LPUART1 bus and kernel clocks enabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>I2C3SMEN</name>
              <description>I2C3 bus and kernel clocks enable during Sleep and Stop modes
Set and cleared by software.
Access can be secured by GTZC_TZSC I2C3SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.
Note: This bit must be set to allow the peripheral to wake up from Stop modes.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>I2C3 bus and kernel clocks disabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>I2C3 bus and kernel clocks enabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LPTIM1SMEN</name>
              <description>LPTIM1 bus and kernel clocks enable during Sleep and Stop modes
Set and cleared by software.
Access can be secured by GTZC_TZSC LPTIM1SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.
Note: This bit must be set to allow the peripheral to wake up from Stop modes.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>LPTIM1 bus and kernel clocks disabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>LPTIM1 bus and kernel clocks enabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RTCAPBSMEN</name>
              <description>RTC and TAMP APB clock enable during Sleep and Stop modes
Set and cleared by software.
Can only be accessed secure when one or more features in the RTC or TAMP is/are secure. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.
Note: This bit must be set to allow the peripheral to wake up from Stop modes.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>RTC and TAMP APB clock disabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>RTC and TAMP APB clock enabled by the clock gating during Sleep and Stop modes</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RCC_CCIPR1</name>
          <displayName>RCC_CCIPR1</displayName>
          <description>RCC peripherals independent clock configuration register 1</description>
          <addressOffset>0x0E0</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>USART1SEL</name>
              <description>USART1 kernel clock source selection
This bits are used to select the USART1 kernel clock source.
Access can be secured by GTZC_TZSC USART1SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.
Note: The USART1 is functional in Stop 0 and Stop 1 mode only when the kernel clock is HSI16 or LSE.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>pclk2 selected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>SYSCLK selected</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>HSI16 selected</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>LSE selected</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>USART2SEL</name>
              <description>USART2 kernel clock source selection
This bits are used to select the USART2 kernel clock source.
Access can be secured by GTZC_TZSC USART2SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.
Note: The USART2 is functional in Stop 0 and Stop 1 mode only when the kernel clock is HSI16 or LSE.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>pclk1 selected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>SYSCLK selected</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>HSI16 selected</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>LSE selected</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>I2C1SEL</name>
              <description>I2C1 kernel clock source selection
These bits are used to select the I2C1 kernel clock source.
Access can be secured by GTZC_TZSC I2C1SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.
Note: The I2C1 is functional in Stop 0 and Stop 1 mode only when the kernel clock is HSI16.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>pclk1 selected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>SYSCLK selected</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>HSI16 selected</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LPTIM2SEL</name>
              <description>Low-power timer 2 kernel clock source selection
These bits are used to select the LPTIM2 kernel clock source.
Access can be secured by GTZC_TZSC LPTIM2SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.
Note: The LPTIM2 is functional in Stop 0 and Stop 1 mode only when the kernel clock is LSI, LSE or HSI16 if HSIKERON = 1.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>pclk1 selected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>LSI selected</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>HSI16 selected</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>LSE selected</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SPI1SEL</name>
              <description>SPI1 kernel clock source selection
These bits are used to select the SPI1 kernel clock source.
Access can be secured by GTZC_TZSC SPI1SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.
Note: The SPI1 is functional in Stop 0 and Stop 1 mode only when the kernel clock is HSI16.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>pclk2 selected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>SYSCLK selected</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>HSI16 selected</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SYSTICKSEL</name>
              <description>SysTick clock source selection
These bits are used to select the SysTick clock source.
Access can be secured by RCC SYSCLKSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.
Note: When LSE or LSI is selected, the AHB frequency must be at least four times higher than the LSI or LSE frequency. In addition, a jitter up to one hclk1 cycle is introduced, due to the LSE or LSI sampling with hclk1 in the SysTick circuitry.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>hclk1 divided by 8 selected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>LSI selected</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>LSE selected</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TIMICSEL</name>
              <description>Clocks sources for TIM16,TIM17 and LPTIM2 internal input capture 
When the TIMICSEL bit is set, the TIM16, TIM17 and LPTIM2 internal input capture can be connected to HSI16/256. 
When TIMICSEL is cleared, the HSI16, clock sources cannot be selected as TIM16, TIM17 or LPTIM2 internal input capture.
Access can be secured by GTZC_TZSC TIM16SEC, TIM17SEC, or LPTIM2SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.
Note: The clock division must be disabled (TIMICSEL configured to 0) before selecting or changing a clock sources division.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>HSI16 divider disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>HSI16/256 generated and can be selected by TIM16, TIM17 and LPTIM2 as internal input capture</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RCC_CCIPR2</name>
          <displayName>RCC_CCIPR2</displayName>
          <description>RCC peripherals independent clock configuration register 2</description>
          <addressOffset>0x0E4</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RNGSEL</name>
              <description>RNGSEL kernel clock source selection
These bits allow to select the RNG kernel clock source.
Access can be secured by GTZC_TZSC RNGSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>LSE selected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>LSI selected</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>HSI16 selected</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>pll1qclk divide by 2 selected</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RCC_CCIPR3</name>
          <displayName>RCC_CCIPR3</displayName>
          <description>RCC peripherals independent clock configuration register 3</description>
          <addressOffset>0x0E8</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LPUART1SEL</name>
              <description>LPUART1 kernel clock source selection
These bits are used to select the LPUART1 kernel clock source.
Access can be secured by GTZC_TZSC LPUART1SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.
Note: The LPUART1 is functional in Stop modes only when the kernel clock is HSI16 or LSE.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>pclk7 selected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>SYSCLK selected</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>HSI16 selected</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>LSE selected</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SPI3SEL</name>
              <description>SPI3 kernel clock source selection
These bits are used to select the SPI3 kernel clock source.
Access can be secured by GTZC_TZSC SPI3SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.
Note: The SPI3 is functional in Stop modes only when the kernel clock is HSI16.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>pclk7 selected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>SYSCLK selected</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>HSI16 selected</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>I2C3SEL</name>
              <description>I2C3 kernel clock source selection
These bits are used to select the I2C3 kernel clock source.
Access can be secured by GTZC_TZSC I2C3SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.
Note: The I2C3 is functional in Stop modes only when the kernel clock is HSI16</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>pclk7 selected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>SYSCLK selected</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>HSI16 selected</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LPTIM1SEL</name>
              <description>LPTIM1 kernel clock source selection
These bits are used to select the LPTIM1 kernel clock source.
Access can be secured by GTZC_TZSC LPTIM1SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.
Note: The LPTIM1 is functional in Stop modes only when the kernel clock is LSI, LSE, HSI16 with HSIKERON = 1.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>pclk7 selected.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>LSI selected</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>HSI16 selected</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>LSE selected</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADCSEL</name>
              <description>ADC4 kernel clock source selection
These bits are used to select the ADC4 kernel clock source.
Access can be secured by GTZC_TZSC ADC4SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.
others: reserved
Note: The ADC4 is functional in Stop modes only when the kernel clock is HSI16.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>hclk1 clock selected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>SYSCLK selected</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>pll1pclk selected</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>HSE32 clock selected</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>HSI16 clock selected</description>
                  <value>0x4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RCC_BDCR1</name>
          <displayName>RCC_BDCR1</displayName>
          <description>RCC backup domain control register</description>
          <addressOffset>0x0F0</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>LSEON</name>
              <description>LSE oscillator enable
Set and cleared by software.
Access can be secured by RCC LSESEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>LSE oscillator off</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>LSE oscillator on</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LSERDY</name>
              <description>LSE oscillator ready
Set and cleared by hardware to indicate when the external 32kHz oscillator is stable. After the LSEON bit is cleared, LSERDY goes low after six external low-speed oscillator clock cycles.
Access can be secured by RCC LSESEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>LSE oscillator not ready</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>LSE oscillator ready</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LSEBYP</name>
              <description>LSE oscillator bypass
Set and cleared by software to bypass oscillator in debug mode. This bit can be written only when the external 32kHz oscillator is disabled (LSEON = 0 and LSERDY = 0).
Access can be secured by RCC LSESEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>LSE oscillator 'Xtal' mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>LSE oscillator bypassed</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LSEDRV</name>
              <description>LSE oscillator drive capability
Set by software to modulate the drive capability of the LSE oscillator. LSEDRV must be programmed to a different value than 0 before enabling the LSE oscillator in 'Xtal' mode.
Access can be secured by RCC LSESEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.
Note: The oscillator is in 'Xtal mode' when it is not in bypass mode.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>'Xtal mode' medium-low driving capability</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>'Xtal mode' medium-high driving capability</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>'Xtal mode' higher driving capability</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LSECSSON</name>
              <description>Low speed external clock security enable
Set by software to enable the LSECSS. LSECSSON must be enabled after the LSE oscillator is enabled (LSEON bit enabled) and ready (LSERDY flag set by hardware) and after the RTCSEL bit is selected.
Once enabled, this bit cannot be disabled, except after a LSE failure detection (LSECSSD=1). In that case, the software must disable the LSECSSON bit.
Access can be secured by RCC LSESEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>LSECSS disabled off</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>LSECSS enabled on</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LSECSSD</name>
              <description>Low speed external clock security, LSE failure Detection
Set by hardware to indicate when a failure is detected by the LSECCS on the external 32kHz oscillator.
Reset when LSCSSON bit is cleared.
Access can be secured by RCC LSESEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no failure detected on LSE</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>failure detected on LSE</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LSESYSEN</name>
              <description>LSE system clock (LSESYS) enable
Set by software to enable the LSE system clock generated by RCC. The lsesys clock is used for peripherals (USART, LPUART, LPTIM, RNG, 2.4 GHz RADIO) and functions (LSCO, MCO, TIM triggers, LPTIM trigger) excluding the RTC, TAMP and LSECSS.
Access can be secured by RCC LSESEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>LSESYS clock disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>LSESYS clock enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RTCSEL</name>
              <description>RTC and TAMP kernel clock source enable and selection
Set by software to enable and select the clock source for the RTC.
Can only be accessed secure when one or more features in the RTC or TAMP is/are secure. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no clock selected, RTC and TAMP kernel clock disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>LSE oscillator clock selected, and enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>LSI oscillator clock selected, and enabled</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>HSE32 oscillator clock divided by 32 selected, and enabled</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LSESYSRDY</name>
              <description>LSE system clock (LSESYS) ready
Set and cleared by hardware to indicate when the LSE system clock is stable.When the LSESYSEN bit is set, the LSESYSRDY flag is set after two LSE clock cycles.
The LSE clock must be already enabled and stable (LSEON and LSERDY are set). 
When the LSEON bit is cleared, LSERDY goes low after six external low-speed oscillator clock cycles.
Access can be secured by RCC LSESEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>LSESYS clock not ready</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>LSESYS clock ready</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LSEGFON</name>
              <description>LSE clock glitch filter enable
Set and cleared by hardware to enable the LSE glitch filter. This bit can be written only when the LSE is disabled (LSEON = 0 and LSERDY = 0).
Access can be secured by RCC LSESEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>LSE glitch filter disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>LSE glitch filter enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LSETRIM</name>
              <description>LSE trimming
These bits are initialized at startup and after OBL_LAUNCH with SBF cleared with the factory-programmed LSE calibration value.
Set and cleared by software. These bits must be modified only once after a BOR reset or an OBL_LAUNCH and before enabling LSE with LSEON (when both LSEON = 0 and LSERDY= 0).
Access can be secured by RCC LSESEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.
Note: OBL_LAUNCH of this field occurs only when SBF is cleared and must then only be started by software when LSE oscillator is disabled, LSEON = 0 and LSERDY = 0.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>current source resistance 5/4 x R</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>current source resistance R</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>current source resistance 3/4 x R</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>current source resistance 2/3 x R</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BDRST</name>
              <description>Backup domain software reset
Set and cleared by software.
Can only be accessed secure when one or more features in the RTC or TAMP is secure. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Reset not activated</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset the entire Backup domain</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RADIOSTSEL</name>
              <description>2.4 GHz RADIO sleep timer kernel clock enable and selection
Set and cleared by software.
Access can be secured by GTZC_TZSC RADIOSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no clock selected, 2.4 GHz RADIO sleep timer kernel clock disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>LSE oscillator clock selected</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>HSE32 oscillator clock divided by 1000 selected</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LSCOEN</name>
              <description>Low-speed clock output (LSCO) enable
Set and cleared by software.
Access can be secured by RCC LSISEC and/or RCC LSESEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>LSCO disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>LSCO enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LSCOSEL</name>
              <description>Low-speed clock output selection
Set and cleared by software.
Access can be secured by RCC LSISEC and/or RCC LSESEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>LSI clock selected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>LSE clock selected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LSI1ON</name>
              <description>LSI1 oscillator enable
Set and cleared by software.
Access can be secured by RCC LSISEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>LSI1 oscillator off</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>LSI1 oscillator on</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LSI1RDY</name>
              <description>LSI1 oscillator ready
Set and cleared by hardware to indicate when the LSI1 oscillator is stable. After the LSI1ON bit is cleared, LSI1RDY goes low after three internal low-speed oscillator clock cycles. This bit is set when the LSI1 is used by IWDG or RTC, even if LSI1ON = 0.
Access can be secured by RCC LSISEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>LSI1 oscillator not ready</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>LSI1 oscillator ready</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LSI1PREDIV</name>
              <description>LSI1 Low-speed clock divider configuration
Set and cleared by software to enable the LSI1 division. This bit can be written only when the LSI1 is disabled (LSI1ON = 0 and LSI1RDY = 0). The LSI1PREDIV cannot be changed if the LSI1 is used by the IWDG or by the RTC.
Access can be secured by RCC LSISEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>LSI1 not divided</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>LSI1 divided by 128</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LSI2ON</name>
              <description>LSI2 oscillator enable</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LSI2RDY</name>
              <description>LSI2 oscillator ready</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RCC_CSR</name>
          <displayName>RCC_CSR</displayName>
          <description>RCC control/status register</description>
          <addressOffset>0x0F4</addressOffset>
          <size>0x20</size>
          <resetValue>0x0C000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RMVF</name>
              <description>Remove reset flag
Set by software to clear the reset flags.
Access can be secured by RCC RMVFSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Clear the reset flags (once set by software bit is cleared automatically by hardware)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OBLRSTF</name>
              <description>Option byte loader reset flag
Set by hardware when a reset from the option byte loading occurs.
Cleared by writing to the RMVF bit.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No reset from option byte loading occurred</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset from option byte loading occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PINRSTF</name>
              <description>NRST pin reset flag
Set by hardware when a reset from the NRST pin occurs.
Cleared by writing to the RMVF bit.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No reset from NRST pin occurred</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reset from NRST pin occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BORRSTF</name>
              <description>BOR flag
Set by hardware when a BOR occurs.
Cleared by writing to the RMVF bit.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no BOR occurred</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>BOR occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SFTRSTF</name>
              <description>Software reset flag
Set by hardware when a software reset occurs.
Cleared by writing to the RMVF bit.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no software reset occurred</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>software reset occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IWDGRSTF</name>
              <description>Independent watchdog reset flag
Set by hardware when an independent watchdog reset domain occurs.
Cleared by writing to the RMVF bit.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no independent watchdog reset occurred</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>independent watchdog reset occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WWDGRSTF</name>
              <description>Window watchdog reset flag
Set by hardware when a window watchdog reset occurs.
Cleared by writing to the RMVF bit.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no window watchdog reset occurred</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>window watchdog reset occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LPWRRSTF</name>
              <description>Low-power reset flag
Set by hardware when a reset occurs due to illegal Stop and Standby modes entry.
Cleared by writing to the RMVF bit.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no illegal mode reset occurred</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>illegal mode reset occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RCC_SECCFGR</name>
          <displayName>RCC_SECCFGR</displayName>
          <description>RCC secure configuration register</description>
          <addressOffset>0x110</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HSISEC</name>
              <description>HSI16 clock configuration and status bits security
Set and reset by software.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Non secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HSESEC</name>
              <description>HSE32 clock configuration bits, status bits and HSECSS security
Set and reset by software.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Non secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LSISEC</name>
              <description>LSI clock configuration and status bits security
Set and reset by software.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Non secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LSESEC</name>
              <description>LSE clock configuration and status bits security
Set and reset by software.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Non secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SYSCLKSEC</name>
              <description>SYSCLK selection, clock output on MCO configuration security
Set and reset by software.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Non secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRESCSEC</name>
              <description>AHBx/APBx prescaler configuration bits security
Set and reset by software.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Non secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PLL1SEC</name>
              <description>PLL1 clock configuration and status bits security
Set and reset by software.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Non secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RMVFSEC</name>
              <description>Remove reset flag security
Set and reset by software.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Non secure</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RCC_PRIVCFGR</name>
          <displayName>RCC_PRIVCFGR</displayName>
          <description>RCC privilege configuration register</description>
          <addressOffset>0x114</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SPRIV</name>
              <description>RCC secure functions privilege configuration
Set and reset by software.
This bit can be written only by a secure privileged access.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Read and write to RCC secure functions can be done by privileged or unprivileged access.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Read and write to RCC secure functions can be done by privileged access only.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NSPRIV</name>
              <description>RCC non-secure functions privilege configuration
Set and reset by software.
This bit can be written only by privileged access, secure or non-secure.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Read and write to RCC non-secure functions can be done by privileged or unprivileged access.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Read and write to RCC non-secure functions can be done by privileged access only.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RCC_CFGR4</name>
          <displayName>RCC_CFGR4</displayName>
          <description>RCC clock configuration register 2</description>
          <addressOffset>0x200</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000010</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HPRE5</name>
              <description>AHB5 prescaler when SWS select PLL1
Set and cleared by software to control the division factor of the AHB5 clock (hclk5).
Must not be changed when SYSCLK source indicated by SWS is PLL1.
When SYSCLK source indicated by SWS is not PLL1: HPRE5 is not taken into account.
When SYSCLK source indicated by SWS is PLL1: HPRE5 is taken into account, from the moment the system clock switch occurs
Depending on the device voltage range, the software must set these bits correctly to ensure that the AHB5 frequency does not exceed the maximum allowed frequency (for more details, refer to Table99: SYSCLK and bus maximum frequency). After a write operation to these bits and before decreasing the voltage range, this register must be read to be sure that the new value is taken into account.
0xx: hclk5 = SYSCLK not divided</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>hclk5 = SYSCLK divided by 2</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>hclk5 = SYSCLK divided by 3</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x6</name>
                  <description>hclk5 = SYSCLK divided by 4</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7</name>
                  <description>hclk5 = SYSCLK divided by 6</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HDIV5</name>
              <description>AHB5 divider when SWS select HSI16 or HSE32
Set and reset by software.
Set to 1 by hardware when entering Stop 1 mode.
When SYSCLK source indicated by SWS is HSI16 or HSE32: HDIV5 is taken into account
When SYSCLK source indicated by SWS is PLL1: HDIV5 is taken not taken into account
Depending on the device voltage range, the software must set this bit correctly to ensure that the AHB5 frequency does not exceed the maximum allowed frequency (for more details, refer to Table99). After a write operation to this bit and before decreasing the voltage range, this register must be read to be sure that the new value is taken into account.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>hclk5 = SYSCLK not divided</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>hclk5 = SYSCLK divided by 2</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RCC_RADIOENR</name>
          <displayName>RCC_RADIOENR</displayName>
          <description>RCC RADIO peripheral clock enable register</description>
          <addressOffset>0x208</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BBCLKEN</name>
              <description>2.4 GHz RADIO baseband kernel clock (aclk) enable
Set and cleared by software.
Note: The HSE32 oscillator needs to be enabled by either HSEON or STRADIOCLKON.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>2.4 GHz RADIO baseband kernel clock disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>2.4 GHz RADIO baseband kernel clock enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>STRADIOCLKON</name>
              <description>2.4 GHz RADIO bus clock enable and HSE32 oscillator enable by 2.4 GHz RADIO sleep timer wakeup event
Set by hardware on a 2.4 GHz RADIO sleep timer wakeup event.
Cleared by software writing zero to this bit.
Note: Before accessing the 2.4 GHz RADIO registers the RADIOCLKRDY bit must be checked.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>2.4 GHz RADIO bus clock and HSE32 oscillator not requested by 2.4 GHz RADIO sleep timer wakeup event.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>2.4 GHz RADIO bus clock and HSE32 oscillator enabled by 2.4 GHz RADIO sleep timer wakeup event</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RADIOCLKRDY</name>
              <description>2.4 GHz RADIO bus clock ready.
Set and cleared by hardware to indicate that the 2.4 GHz RADIO bus clock is ready and the 2.4 GHz RADIO registers can be accessed.
Note: Once both RADIOEN and STRADIOCLKON are cleared, RADIOCLKRDY goes low after three hclk5 clock cycles.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>2.4 GHz RADIO bus clock not ready</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>2.4 GHz RADIO bus clock ready</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RCC_ECSCR1</name>
          <displayName>RCC_ECSCR1</displayName>
          <description>RCC external clock sources calibration register 1</description>
          <addressOffset>0x210</addressOffset>
          <size>0x20</size>
          <resetValue>0x00200000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HSETRIM</name>
              <description>HSE32 clock trimming 
These bits provide user-programmable capacitor trimming value. It can be programmed to adjust the HSE32 oscillator frequency.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>RNG</name>
      <description>RNG register block</description>
      <groupName>RNG</groupName>
      <baseAddress>0x420C0800</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x400</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>RNG</name>
        <description>RNG global interrupt</description>
        <value>59</value>
      </interrupt>
      <registers>
        <register>
          <name>RNG_CR</name>
          <displayName>RNG_CR</displayName>
          <description>RNG control register</description>
          <addressOffset>0x000</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00800D00</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RNGEN</name>
              <description>True random number generator enable</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>True random number generator is disabled. Analog noise sources are powered off and logic clocked by the RNG clock is gated.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>True random number generator is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IE</name>
              <description>Interrupt Enable</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>RNG Interrupt is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>RNG Interrupt is enabled. An interrupt is pending as soon as DRDY = 1, SEIS = 1 or CEIS = 1 in the RNG_SR register.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CED</name>
              <description>Clock error detection 

The clock error detection cannot be enabled nor disabled on-the-fly when the RNG is enabled, that is to enable or disable CED the RNG must be disabled.

Writing this bit is taken into account only if CONDRST bit is set to 1 in the same access, while CONFIGLOCK remains at 0. Writing to this bit is ignored if CONFIGLOCK = 1.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Clock error detection is enable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Clock error detection is disable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ARDIS</name>
              <description>Auto reset disable

When auto-reset is enabled application still need to clear SEIS bit after a noise source error.

Writing this bit is taken into account only if CONDRST bit is set to 1 in the same access, while CONFIGLOCK remains at 0. Writing to this bit is ignored if CONFIGLOCK = 1.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>When a noise source error occurs RNG performs an automatic reset to clear SECS bit.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>When a noise source error occurs application must reset RNG by writing CONDRST to 1 then to 0, in order to restart random number generation.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RNG_CONFIG3</name>
              <description>RNG configuration 3

Reserved to the RNG configuration (bitfield 3). Refer to RNG_CONFIG1 bitfield for details.

If NISTC bit is cleared in this register RNG_CONFIG3 bitfield values are ignored by RNG.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NISTC</name>
              <description>Non NIST compliant

two conditioning loops are performed and 256 bits of noise source are used.

Writing this bit is taken into account only if CONDRST bit is set to 1 in the same access, while CONFIGLOCK remains at 0. Writing to this bit is ignored if CONFIGLOCK = 1.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Hardware default values for NIST compliant RNG. In this configuration per 128-bit output</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Custom values for NIST compliant RNG. See Section 26.6: RNG entropy source validation for proposed configuration.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RNG_CONFIG2</name>
              <description>RNG configuration 2

Reserved to the RNG configuration (bitfield 2). Refer to RNG_CONFIG1 bitfield for details.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKDIV</name>
              <description>Clock divider factor

This value used to configure an internal programmable divider (from 1 to 16) acting on the incoming RNG clock. These bits can be written only when the core is disabled (RNGEN = 0). 

...

Writing these bits is taken into account only if CONDRST bit is set to 1 in the same access, while CONFIGLOCK remains at 0. Writing to this bit is ignored if CONFIGLOCK = 1.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>internal RNG clock after divider is similar to incoming RNG clock.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>two RNG clock cycles per internal RNG clock.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>2sup2/sup (= 4) RNG clock cycles per internal RNG clock.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xF</name>
                  <description>2sup15/sup RNG clock cycles per internal clock (for example. an incoming 48 MHz RNG clock becomes a 1.5 kHz internal RNG clock)</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RNG_CONFIG1</name>
              <description>RNG configuration 1

Reserved to the RNG configuration (bitfield 1). Must be initialized using the recommended value documented in Section 26.6: RNG entropy source validation.

Writing any bit of RNG_CONFIG1 is taken into account only if CONDRST bit is set to 1 in the same access, while CONFIGLOCK remains at 0. Writing to this bit is ignored if CONFIGLOCK = 1.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CONDRST</name>
              <description>Conditioning soft reset

	Write 1 and then write 0 to reset the conditioning logic, clear all the FIFOs and start a new RNG initialization process, with RNG_SR cleared. Registers RNG_CR and RNG_NSCR are not changed by CONDRST.

This bit must be set to 1 in the same access that set any configuration bits [29:4]. In other words, when CONDRST bit is set to 1 correct configuration in bits [29:4] must also be written.

When CONDRST is set to 0 by software its value goes to 0 when the reset process is done. It takes about 2 AHB clock cycles + 2 RNG clock cycles.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CONFIGLOCK</name>
              <description>RNG Config lock

This bitfield is set once: if this bit is set it can only be reset to 0 if RNG is reset.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Writes to the RNG_CR configuration bits [29:4] are allowed.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Writes to the RNG_CR configuration bits [29:4] are ignored until the next RNG reset.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RNG_SR</name>
          <displayName>RNG_SR</displayName>
          <description>RNG status register</description>
          <addressOffset>0x004</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DRDY</name>
              <description>Data Ready

Once the output buffer becomes empty (after reading the RNG_DR register), this bit returns to 0 until a new random value is generated.

Note: The DRDY bit can rise when the peripheral is disabled (RNGEN = 0 in the RNG_CR register).

If IE=1 in the RNG_CR register, an interrupt is generated when DRDY = 1.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>The RNG_DR register is not yet valid, no random data is available.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The RNG_DR register contains valid random data.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CECS</name>
              <description>Clock error current status

Note: CECS bit is valid only if the CED bit in the RNG_CR register is set to 0.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>The RNG clock is correct (fRNGCLK fHCLK/32). If the CEIS bit is set, this means that a slow clock was detected and the situation has been recovered.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The RNG clock is too slow (fRNGCLK fHCLK/32).</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECS</name>
              <description>Seed error current status

Run-time repetition count test failed (noise source has provided more than 24 consecutive bits at a constant value 0 or 1, or more than 32 consecutive occurrence of two bits patterns 01 or 10)

Start-up or continuous adaptive proportion test on noise source failed.

Start-up post-processing/conditioning sanity check failed.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No faulty sequence has currently been detected. If the SEIS bit is set, this means that a faulty sequence was detected and the situation has been recovered.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>At least one of the following faulty sequence has been detected:</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CEIS</name>
              <description>Clock error interrupt status

This bit is set at the same time as CECS. It is cleared by writing 0. Writing 1 has no effect.

An interrupt is pending if IE = 1 in the RNG_CR register.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>The RNG clock is correct (fRNGCLK fHCLK/32)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The RNG clock before internal divider is detected too slow (fRNGCLK fHCLK/32)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEIS</name>
              <description>Seed error interrupt status

This bit is set at the same time as SECS. It is cleared by writing 0 (unless CONDRST is used). Writing 1 has no effect.

An interrupt is pending if IE = 1 in the RNG_CR register.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No faulty sequence detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>At least one faulty sequence is detected. See SECS bit description for details.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RNG_DR</name>
          <displayName>RNG_DR</displayName>
          <description>RNG data register</description>
          <addressOffset>0x008</addressOffset>
          <size>0x20</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RNDATA</name>
              <description>Random data

32-bit random data which are valid when DRDY = 1. When DRDY = 0 RNDATA value is zero.

It is recommended to always verify that RNG_DR is different from zero. Because when it is the case a seed error occurred between RNG_SR polling and RND_DR output reading (rare event).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RNG_HTCR</name>
          <displayName>RNG_HTCR</displayName>
          <description>RNG health test control register</description>
          <addressOffset>0x010</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x000072AC</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HTCFG</name>
              <description>health test configuration

This configuration is used by RNG to configure the health tests. See Section 26.6: RNG entropy source validation for the recommended value.

Note: The RNG behavior, including the read to this register, is not guaranteed if a different value from the recommended value is written.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>RTC</name>
      <description>Real-time clock</description>
      <groupName>RTC</groupName>
      <baseAddress>0x46007800</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x400</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>RTC</name>
        <description>RTC non-secure global interrupts</description>
        <value>002</value>
      </interrupt>
      <interrupt>
        <name>RTC_S</name>
        <description>RTC secure global interrupts</description>
        <value>003</value>
      </interrupt>
      <registers>
        <register>
          <name>RTC_TR</name>
          <displayName>RTC_TR</displayName>
          <description>RTC time register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SU</name>
              <description>Second units in BCD format</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ST</name>
              <description>Second tens in BCD format</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MNU</name>
              <description>Minute units in BCD format</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MNT</name>
              <description>Minute tens in BCD format</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HU</name>
              <description>Hour units in BCD format</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HT</name>
              <description>Hour tens in BCD format</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PM</name>
              <description>AM/PM notation</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>AM or 24-hour format</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>PM</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RTC_DR</name>
          <displayName>RTC_DR</displayName>
          <description>RTC date register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <resetValue>0x00002101</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DU</name>
              <description>Date units in BCD format</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DT</name>
              <description>Date tens in BCD format</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MU</name>
              <description>Month units in BCD format</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MT</name>
              <description>Month tens in BCD format</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WDU</name>
              <description>Week day units
...</description>
              <bitOffset>13</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>forbidden</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Monday</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7</name>
                  <description>Sunday</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>YU</name>
              <description>Year units in BCD format</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>YT</name>
              <description>Year tens in BCD format</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RTC_SSR</name>
          <displayName>RTC_SSR</displayName>
          <description>RTC subsecond register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SS</name>
              <description>Synchronous binary counter
SS[31:16]: Synchronous binary counter MSB values
When Binary or Mixed mode is selected (BIN = 01 or 10 or 11):
SS[31:16] are the 16 MSB of the SS[31:0] free-running down-counter.
When BCD mode is selected (BIN=00):
SS[31:16] are forced by hardware to 0x0000.
SS[15:0]: Subsecond value/synchronous binary counter LSB values
When Binary mode is selected (BIN = 01 or 10 or 11):
SS[15:0] are the 16 LSB of the SS[31:0] free-running down-counter.
When BCD mode is selected (BIN=00):
SS[15:0] is the value in the synchronous prescaler counter. The fraction of a second is given by the formula below:
Second fraction = (PREDIV_S - SS) / (PREDIV_S + 1)
SS can be larger than PREDIV_S only after a shift operation. In that case, the correct time/date is one second less than as indicated by RTC_TR/RTC_DR.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RTC_ICSR</name>
          <displayName>RTC_ICSR</displayName>
          <description>RTC initialization control and status register</description>
          <addressOffset>0x0C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000007</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WUTWF</name>
              <description>Wakeup timer write flag
This bit is set by hardware when WUT value can be changed, after the WUTE bit has been set to 0 in RTC_CR.
It is cleared by hardware in initialization mode.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Wakeup timer configuration update not allowed except in initialization mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Wakeup timer configuration update allowed</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SHPF</name>
              <description>Shift operation pending
This flag is set by hardware as soon as a shift operation is initiated by a write to the RTC_SHIFTR register. It is cleared by hardware when the corresponding shift operation has been executed. Writing to the SHPF bit has no effect.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No shift operation is pending</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>A shift operation is pending</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INITS</name>
              <description>Initialization status flag
This bit is set by hardware when the calendar year field is different from 0 (Backup domain reset state).</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Calendar has not been initialized</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Calendar has been initialized</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RSF</name>
              <description>Registers synchronization flag
This bit is set by hardware each time the calendar registers are copied into the shadow registers (RTC_SSR, RTC_TR and RTC_DR). This bit is cleared by hardware in initialization mode, while a shift operation is pending (SHPF = 1), or when in bypass shadow register mode (BYPSHAD = 1). This bit can also be cleared by software.
It is cleared either by software or by hardware in initialization mode.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Calendar shadow registers not yet synchronized</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Calendar shadow registers synchronized</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INITF</name>
              <description>Initialization flag
When this bit is set to 1, the RTC is in initialization state, and the time, date and prescaler registers can be updated.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Calendar registers update is not allowed</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Calendar registers update is allowed</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INIT</name>
              <description>Initialization mode</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Free running mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Initialization mode used to program time and date register (RTC_TR and RTC_DR), and prescaler register (RTC_PRER), plus BIN and BCDU fields. Counters are stopped and start counting from the new value when INIT is reset.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BIN</name>
              <description>Binary mode</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Free running BCD calendar mode (Binary mode disabled).</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Free running Binary mode (BCD mode disabled)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>Free running BCD calendar and Binary modes</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>Free running BCD calendar and Binary modes</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BCDU</name>
              <description>BCD update (BIN = 10 or 11)
In mixed mode when both BCD calendar and binary extended counter are used (BIN = 10 or 11), the calendar second is incremented using the SSR Least Significant Bits.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>1s calendar increment is generated each time SS[7:0] = 0</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>1s calendar increment is generated each time SS[8:0] = 0</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>1s calendar increment is generated each time SS[9:0] = 0</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>1s calendar increment is generated each time SS[10:0] = 0</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>1s calendar increment is generated each time SS[11:0] = 0</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>1s calendar increment is generated each time SS[12:0] = 0</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x6</name>
                  <description>1s calendar increment is generated each time SS[13:0] = 0</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7</name>
                  <description>1s calendar increment is generated each time SS[14:0] = 0</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RECALPF</name>
              <description>Recalibration pending Flag
The RECALPF status flag is automatically set to 1 when software writes to the RTC_CALR register, indicating that the RTC_CALR register is blocked. When the new calibration settings are taken into account, this bit returns to 0. Refer to Re-calibration on-the-fly.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RTC_PRER</name>
          <displayName>RTC_PRER</displayName>
          <description>RTC prescaler register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <resetValue>0x007F00FF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PREDIV_S</name>
              <description>Synchronous prescaler factor
This is the synchronous division factor:
ck_spre frequency = ck_apre frequency/(PREDIV_S+1)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>15</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PREDIV_A</name>
              <description>Asynchronous prescaler factor
This is the asynchronous division factor:
ck_apre frequency = RTCCLK frequency/(PREDIV_A+1)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RTC_WUTR</name>
          <displayName>RTC_WUTR</displayName>
          <description>RTC wakeup timer register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <resetValue>0x0000FFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WUT</name>
              <description>Wakeup auto-reload value bits
When the wakeup timer is enabled (WUTE set to 1), the WUTF flag is set every (WUT[15:0]+1) ck_wut cycles. The ck_wut period is selected through WUCKSEL[2:0] bits of the RTC_CR register.
When WUCKSEL[2] = 1, the wakeup timer becomes 17-bits and WUCKSEL[1] effectively becomes WUT[16] the most-significant bit to be reloaded into the timer.
The first assertion of WUTF occurs between WUT and (WUT + 2) ck_wut cycles after WUTE is set. Setting WUT[15:0] to 0x0000 with WUCKSEL[2:0] = 011 (RTCCLK/2) is forbidden.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WUTOCLR</name>
              <description>Wakeup auto-reload output clear value
When WUTOCLR[15:0] is different from 0x0000, WUTF is set by hardware when the auto-reload down-counter reaches 0 and is cleared by hardware when the auto-reload downcounter reaches WUTOCLR[15:0].
When WUTOCLR[15:0] = 0x0000, WUTF is set by hardware when the WUT down-counter
reaches 0 and is cleared by software.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RTC_CR</name>
          <displayName>RTC_CR</displayName>
          <description>RTC control register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WUCKSEL</name>
              <description>ck_wut wakeup clock selection
10x: ck_spre (usually 1Hz) clock is selected in BCD mode. In binary or mixed mode, this is the clock selected by BCDU.
11x: ck_spre (usually 1 Hz) clock is selected in BCD mode. In binary or mixed mode, this is the clock selected by BCDU. Furthermore, 2sup16/sup is added to the WUT counter value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>RTC/16 clock is selected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>RTC/8 clock is selected</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>RTC/4 clock is selected</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>RTC/2 clock is selected</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSEDGE</name>
              <description>Timestamp event active edge
TSE must be reset when TSEDGE is changed to avoid unwanted TSF setting.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>RTC_TS input rising edge generates a timestamp event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>RTC_TS input falling edge generates a timestamp event</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>REFCKON</name>
              <description>RTC_REFIN reference clock detection enable (50 or 60Hz)
Note: BIN must be 0x00 and PREDIV_S must be 0x00FF.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>RTC_REFIN detection disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>RTC_REFIN detection enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BYPSHAD</name>
              <description>Bypass the shadow registers
Note: If the frequency of the APB clock is less than seven times the frequency of RTCCLK, BYPSHAD must be set to 1.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Calendar values (when reading from RTC_SSR, RTC_TR, and RTC_DR) are taken from the shadow registers, which are updated once every two RTCCLK cycles.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Calendar values (when reading from RTC_SSR, RTC_TR, and RTC_DR) are taken directly from the calendar counters.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FMT</name>
              <description>Hour format</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>24 hour/day format</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>AM/PM hour format</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SSRUIE</name>
              <description>SSR underflow interrupt enable</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>SSR underflow interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>SSR underflow interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ALRAE</name>
              <description>Alarm A enable</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Alarm A disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Alarm A enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ALRBE</name>
              <description>Alarm B enable</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Alarm B disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Alarm B enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WUTE</name>
              <description>Wakeup timer enable
Note: When the wakeup timer is disabled, wait for WUTWF = 1 before enabling it again.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Wakeup timer disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Wakeup timer enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSE</name>
              <description>timestamp enable</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>timestamp disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>timestamp enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ALRAIE</name>
              <description>Alarm A interrupt enable</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Alarm A interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Alarm A interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ALRBIE</name>
              <description>Alarm B interrupt enable</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Alarm B interrupt disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Alarm B interrupt enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WUTIE</name>
              <description>Wakeup timer interrupt enable</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Wakeup timer interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Wakeup timer interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSIE</name>
              <description>Timestamp interrupt enable</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Timestamp interrupt disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Timestamp interrupt enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADD1H</name>
              <description>Add 1 hour (summer time change)
When this bit is set outside initialization mode, 1 hour is added to the calendar time. This bit is always read as 0.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Adds 1 hour to the current time. This can be used for summer time change</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SUB1H</name>
              <description>Subtract 1 hour (winter time change)
When this bit is set outside initialization mode, 1 hour is subtracted to the calendar time if the current hour is not 0. This bit is always read as 0.
Setting this bit has no effect when current hour is 0.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Subtracts 1 hour to the current time. This can be used for winter time change.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BKP</name>
              <description>Backup
This bit can be written by the user to memorize whether the daylight saving time change has been performed or not.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COSEL</name>
              <description>Calibration output selection
When COE = 1, this bit selects which signal is output on CALIB.
These frequencies are valid for RTCCLK at 32.768kHz and prescalers at their default values (PREDIV_A = 127 and PREDIV_S = 255). Refer to Section74.3.18: Calibration clock output.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Calibration output is 512Hz</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Calibration output is 1Hz</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>POL</name>
              <description>Output polarity
This bit is used to configure the polarity of TAMPALRM output.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>The pin is high when ALRAF/ALRBF/WUTF is asserted (depending on OSEL[1:0]), or when a TAMPxF/ITAMPxF is asserted (if TAMPOE = 1).</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The pin is low when ALRAF/ALRBF/WUTF is asserted (depending on OSEL[1:0]), or when a TAMPxF/ITAMPxF is asserted (if TAMPOE = 1).</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OSEL</name>
              <description>Output selection
These bits are used to select the flag to be routed to TAMPALRM output.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Output disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Alarm A output enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>Alarm B output enabled</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>Wakeup output enabled</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>COE</name>
              <description>Calibration output enable
This bit enables the CALIB output</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Calibration output disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Calibration output enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAMPTS</name>
              <description>Activate timestamp on tamper detection event
TAMPTS is valid even if TSE = 0 in the RTC_CR register. Timestamp flag is set up to 3 ck_apre cycles after the tamper flags.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Tamper detection event does not cause a RTC timestamp to be saved</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Save RTC timestamp on tamper detection event</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAMPOE</name>
              <description>Tamper detection output enable on TAMPALRM</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>The tamper flag is not routed on TAMPALRM</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The tamper flag is routed on TAMPALRM, combined with the signal provided by OSEL and with the polarity provided by POL.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ALRAFCLR</name>
              <description>Alarm A flag automatic clear</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Alarm A event generates a trigger event and ALRAF must be cleared by software to allow next alarm event.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Alarm A event generates a trigger event. ALRAF is automatically cleared by hardware after 1 ck_apre cycle.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ALRBFCLR</name>
              <description>Alarm B flag automatic clear</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Alarm B event generates a trigger event and ALRBF must be cleared by software to allow next alarm event.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Alarm B event generates a trigger event. ALRBF is automatically cleared by hardware after 1 ck_apre cycle.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAMPALRM_PU</name>
              <description>TAMPALRM pull-up enable</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No pull-up is applied on TAMPALRM output</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>A pull-up is applied on TAMPALRM output</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAMPALRM_TYPE</name>
              <description>TAMPALRM output type</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>TAMPALRM is push-pull output</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>TAMPALRM is open-drain output</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OUT2EN</name>
              <description>RTC_OUT2 output enable
With this bit set, the RTC outputs can be remapped on RTC_OUT2 as follows:
OUT2EN=0: RTC output 2 disable
If OSEL different 00 or TAMPOE = 1: TAMPALRM is output on RTC_OUT1
If OSEL=00 and TAMPOE=0 and COE=1: CALIB is output on RTC_OUT1
OUT2EN = 1: RTC output 2 enable
If (OSEL different 00 or TAMPOE = 1) and COE = 0: TAMPALRM is output on RTC_OUT2
If OSEL=00 and TAMPOE=0 and COE=1: CALIB is output on RTC_OUT2
If (OSEL different 00 or TAMPOE = 1) and COE = 1: CALIB is output on RTC_OUT2 and TAMPALRM is output on RTC_OUT1.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RTC_PRIVCFGR</name>
          <displayName>RTC_PRIVCFGR</displayName>
          <description>RTC privilege mode control register</description>
          <addressOffset>0x1C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ALRAPRIV</name>
              <description>Alarm A and SSR underflow privilege protection</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>RTC Alarm A and SSR underflow configuration and interrupt clear can be written when the APB access is privileged or non-privileged.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>RTC Alarm A and SSR underflow configuration and interrupt clear can be written only when the APB access is privileged.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ALRBPRIV</name>
              <description>Alarm B privilege protection</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>RTC Alarm B configuration and interrupt clear can be written when the APB access is privileged or non-privileged.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>RTC Alarm B configuration and interrupt clear can be written only when the APB access is privileged.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WUTPRIV</name>
              <description>Wakeup timer privilege protection</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>RTC Wakeup timer configuration and interrupt clear can be written when the APB access is privileged or non-privileged.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>RTC Wakeup timer configuration and interrupt clear can be written only when the APB access is privileged.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSPRIV</name>
              <description>Timestamp privilege protection</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>RTC Timestamp configuration and interrupt clear can be written when the APB access is privileged or non-privileged.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>RTC Timestamp configuration and interrupt clear can be written only when the APB access is privileged.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CALPRIV</name>
              <description>Shift register, Delight saving, calibration and reference clock privilege protection</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Shift register, Delight saving, calibration and reference clock can be written when the APB access is privileged or non-privileged.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Shift register, Delight saving, calibration and reference clock can be written only when the APB access is privileged.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INITPRIV</name>
              <description>Initialization privilege protection</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>RTC Initialization mode, calendar and prescalers registers can be written when the APB access is privileged or non-privileged.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>RTC Initialization mode, calendar and prescalers registers can be written only when the APB access is privileged.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIV</name>
              <description>RTC privilege protection</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>All RTC registers can be written when the APB access is privileged or non-privileged, except the registers protected by other privilege protection bits.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>All RTC registers can be written only when the APB access is privileged.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RTC_SECCFGR</name>
          <displayName>RTC_SECCFGR</displayName>
          <description>RTC secure configuration register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ALRASEC</name>
              <description>Alarm A and SSR underflow protection</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>RTC alarm A and SSR underflow configuration and interrupt clear can be written when the APB access is secure or non-secure.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>RTC alarm A and SSR underflow configuration and interrupt clear can be written only when the APB access is secure.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ALRBSEC</name>
              <description>Alarm B protection</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>RTC alarm B configuration and interrupt clear can be written when the APB access is secure or non-secure.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>RTC alarm B configuration and interrupt clear can be written only when the APB access is secure.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WUTSEC</name>
              <description>Wakeup timer protection</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>RTC wakeup timer configuration and interrupt clear can be written when the APB access is secure or non-secure.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>RTC wakeup timer configuration and interrupt clear can be written only when the APB access is secure.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSSEC</name>
              <description>Timestamp protection</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>RTC timestamp configuration and interrupt clear can be written when the APB access is secure or non-secure.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>RTC timestamp configuration and interrupt clear can be written only when the APB access is secure.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CALSEC</name>
              <description>Shift register, daylight saving, calibration and reference clock protection</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Shift register, daylight saving, calibration and reference clock can be written when the APB access is secure or non-secure.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Shift register, daylight saving, calibration and reference clock can be written only when the APB access is secure.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INITSEC</name>
              <description>Initialization protection</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>RTC Initialization mode, calendar and prescalers registers can be written when the APB access is secure or non-secure.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>RTC Initialization mode, calendar and prescalers registers can be written only when the APB access is secure.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEC</name>
              <description>RTC global protection</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>All RTC registers can be written when the APB access is secure or non-secure, except the registers protected by other secure protection bits.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>All RTC registers can be written only when the APB access is secure.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RTC_WPR</name>
          <displayName>RTC_WPR</displayName>
          <description>RTC write protection register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>KEY</name>
              <description>Write protection key
This byte is written by software.
Reading this byte always returns 0x00.
Refer to RTC register write protection for a description of how to unlock RTC register write protection.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RTC_CALR</name>
          <displayName>RTC_CALR</displayName>
          <description>RTC calibration register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CALM</name>
              <description>Calibration minus
The frequency of the calendar is reduced by masking CALM out of 2sup20/sup RTCCLK pulses (32seconds if the input frequency is 32768Hz). This decreases the frequency of the calendar with a resolution of 0.9537ppm.
To increase the frequency of the calendar, this feature should be used in conjunction with CALP. See Section74.3.16: RTC smooth digital calibration on page4278.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LPCAL</name>
              <description>RTC low-power mode</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Calibration window is 2sup20/sup RTCCLK, which is a high-consumption mode. This mode must be set only when less than 32s calibration window is required.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Calibration window is 2sup20/sup ck_apre, which is the required configuration for ultra-low consumption mode.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CALW16</name>
              <description>Use a 16-second calibration cycle period
When CALW16 is set to 1, the 16-second calibration cycle period is selected. This bit must not be set to 1 if CALW8 = 1.
Note: CALM[0] is stuck at 0 when CALW16 = 1. Refer to Section74.3.16: RTC smooth digital calibration.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CALW8</name>
              <description>Use an 8-second calibration cycle period
When CALW8 is set to 1, the 8-second calibration cycle period is selected.
Note: CALM[1:0] are stuck at 00 when CALW8 = 1. Refer to Section74.3.16: RTC smooth digital calibration.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CALP</name>
              <description>Increase frequency of RTC by 488.5ppm. This feature is intended to be used in conjunction with CALM, which lowers the frequency of the calendar with a fine resolution. if the input frequency is 32768 Hz, the number of RTCCLK pulses added during a 32 second window is calculated as follows: (512 * CALP)  CALM.
Refer to Section74.3.16: RTC smooth digital calibration.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No RTCCLK pulses are added.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>One RTCCLK pulse is effectively inserted every 2sup11/sup pulses (frequency increased by 488.5ppm).</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RTC_SHIFTR</name>
          <displayName>RTC_SHIFTR</displayName>
          <description>RTC shift control register</description>
          <addressOffset>0x2C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SUBFS</name>
              <description>Subtract a fraction of a second
These bits are write only and is always read as zero. Writing to this bit has no effect when a shift operation is pending (when SHPF = 1, in RTC_ICSR).
The value which is written to SUBFS is added to the synchronous prescaler counter. Since this counter counts down, this operation effectively subtracts from (delays) the clock by:
Delay (seconds) = SUBFS / (PREDIV_S + 1)
A fraction of a second can effectively be added to the clock (advancing the clock) when the ADD1S function is used in conjunction with SUBFS, effectively advancing the clock by:
Advance (seconds) = (1 - (SUBFS / (PREDIV_S + 1))).
In mixed BCD-binary mode (BIN=10 or 11), the SUBFS[14:BCDU+8] must be written with 0.
Note: Writing to SUBFS causes RSF to be cleared. Software can then wait until RSF = 1 to be sure that the shadow registers have been updated with the shifted time.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>15</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ADD1S</name>
              <description>Add one second
This bit is write only and is always read as zero. Writing to this bit has no effect when a shift operation is pending (when SHPF = 1, in RTC_ICSR).
This function is intended to be used with SUBFS (see description below) in order to effectively add a fraction of a second to the clock in an atomic operation.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Add one second to the clock/calendar</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RTC_TSTR</name>
          <displayName>RTC_TSTR</displayName>
          <description>RTC timestamp time register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SU</name>
              <description>Second units in BCD format.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ST</name>
              <description>Second tens in BCD format.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MNU</name>
              <description>Minute units in BCD format.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MNT</name>
              <description>Minute tens in BCD format.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>HU</name>
              <description>Hour units in BCD format.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>HT</name>
              <description>Hour tens in BCD format.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PM</name>
              <description>AM/PM notation</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>AM or 24-hour format</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>PM</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RTC_TSDR</name>
          <displayName>RTC_TSDR</displayName>
          <description>RTC timestamp date register</description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DU</name>
              <description>Date units in BCD format</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DT</name>
              <description>Date tens in BCD format</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MU</name>
              <description>Month units in BCD format</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MT</name>
              <description>Month tens in BCD format</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WDU</name>
              <description>Week day units</description>
              <bitOffset>13</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RTC_TSSSR</name>
          <displayName>RTC_TSSSR</displayName>
          <description>RTC timestamp subsecond register</description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SS</name>
              <description>Subsecond value/synchronous binary counter values
SS[31:0] is the value of the synchronous prescaler counter when the timestamp event occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RTC_ALRMAR</name>
          <displayName>RTC_ALRMAR</displayName>
          <description>RTC alarm A register</description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SU</name>
              <description>Second units in BCD format.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ST</name>
              <description>Second tens in BCD format.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK1</name>
              <description>Alarm A seconds mask</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Alarm A set if the seconds match</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Seconds don't care in alarm A comparison</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MNU</name>
              <description>Minute units in BCD format</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MNT</name>
              <description>Minute tens in BCD format</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK2</name>
              <description>Alarm A minutes mask</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Alarm A set if the minutes match</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Minutes don't care in alarm A comparison</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HU</name>
              <description>Hour units in BCD format</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HT</name>
              <description>Hour tens in BCD format</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PM</name>
              <description>AM/PM notation</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>AM or 24-hour format</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>PM</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MSK3</name>
              <description>Alarm A hours mask</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Alarm A set if the hours match</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Hours don't care in alarm A comparison</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DU</name>
              <description>Date units or day in BCD format</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DT</name>
              <description>Date tens in BCD format</description>
              <bitOffset>28</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WDSEL</name>
              <description>Week day selection</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>DU[3:0] represents the date units</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>DU[3:0] represents the week day. DT[1:0] is don't care.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MSK4</name>
              <description>Alarm A date mask</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Alarm A set if the date/day match</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Date/day don't care in alarm A comparison</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RTC_ALRMASSR</name>
          <displayName>RTC_ALRMASSR</displayName>
          <description>RTC alarm A subsecond register</description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SS</name>
              <description>Subseconds value
This value is compared with the contents of the synchronous prescaler counter to determine if alarm A is to be activated. Only bits 0 up MASKSS-1 are compared.
This field is the mirror of SS[14:0] in the RTC_ALRMABINR, and so can also be read or written through RTC_ALRMABINR.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>15</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASKSS</name>
              <description>Mask the most-significant bits starting at this bit
...
From 32 to 63: All 32 SS bits are compared and must match to activate alarm.
Note: In BCD mode (BIN=00) the overflow bits of the synchronous counter (bits 31:15) are never compared. These bits can be different from 0 only after a shift operation.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No comparison on subseconds for Alarm A. The alarm is set when the seconds unit is incremented (assuming that the rest of the fields match).</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>SS[31:1] are don't care in Alarm A comparison. Only SS[0] is compared.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SSCLR</name>
              <description>Clear synchronous counter on alarm (Binary mode only)
Note: SSCLR must be kept to 0 when BCD or mixed mode is used (BIN = 00, 10 or 11).</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>The synchronous binary counter (SS[31:0] in RTC_SSR) is free-running.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The synchronous binary counter (SS[31:0] in RTC_SSR) is running from 0xFFFFFFFF to RTC_ALRMABINR.SS[31:0] value and is automatically reloaded with 0xFFFFFFFF one ck_apre cycle after reaching RTC_ALRMABINR.SS[31:0].</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RTC_ALRMBR</name>
          <displayName>RTC_ALRMBR</displayName>
          <description>RTC alarm B register</description>
          <addressOffset>0x48</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SU</name>
              <description>Second units in BCD format</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ST</name>
              <description>Second tens in BCD format</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK1</name>
              <description>Alarm B seconds mask</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Alarm B set if the seconds match</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Seconds don't care in alarm B comparison</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MNU</name>
              <description>Minute units in BCD format</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MNT</name>
              <description>Minute tens in BCD format</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK2</name>
              <description>Alarm B minutes mask</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Alarm B set if the minutes match</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Minutes don't care in alarm B comparison</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HU</name>
              <description>Hour units in BCD format</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HT</name>
              <description>Hour tens in BCD format</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PM</name>
              <description>AM/PM notation</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>AM or 24-hour format</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>PM</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MSK3</name>
              <description>Alarm B hours mask</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Alarm B set if the hours match</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Hours don't care in alarm B comparison</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DU</name>
              <description>Date units or day in BCD format</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DT</name>
              <description>Date tens in BCD format</description>
              <bitOffset>28</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WDSEL</name>
              <description>Week day selection</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>DU[3:0] represents the date units</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>DU[3:0] represents the week day. DT[1:0] is don't care.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MSK4</name>
              <description>Alarm B date mask</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Alarm B set if the date and day match</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Date and day don't care in alarm B comparison</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RTC_ALRMBSSR</name>
          <displayName>RTC_ALRMBSSR</displayName>
          <description>RTC alarm B subsecond register</description>
          <addressOffset>0x4C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SS</name>
              <description>Subseconds value
This value is compared with the contents of the synchronous prescaler counter to determine if alarm B is to be activated. Only bits 0 up to MASKSS-1 are compared.
This field is the mirror of SS[14:0] in the RTC_ALRMBBINR, and so can also be read or written through RTC_ALRMBBINR.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>15</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASKSS</name>
              <description>Mask the most-significant bits starting at this bit
...
From 32 to 63: All 32 SS bits are compared and must match to activate alarm.
Note: In BCD mode (BIN=00)The overflow bits of the synchronous counter (bits 15) is never compared. This bit can be different from 0 only after a shift operation.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No comparison on subseconds for Alarm B. The alarm is set when the seconds unit is incremented (assuming that the rest of the fields match).</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>SS[31:1] are don't care in Alarm B comparison. Only SS[0] is compared.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SSCLR</name>
              <description>Clear synchronous counter on alarm (Binary mode only)
Note: SSCLR must be kept to 0 when BCD or mixed mode is used (BIN = 00, 10 or 11).</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>The synchronous binary counter (SS[31:0] in RTC_SSR) is free-running.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The synchronous binary counter (SS[31:0] in RTC_SSR) is running from 0xFFFFFFFF to RTC_ALRMBBINR.SS[31:0] value and is automatically reloaded with 0xFFFFFFFF one ck_apre cycle after reaching RTC_ALRMBBINR.SS[31:0].</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RTC_SR</name>
          <displayName>RTC_SR</displayName>
          <description>RTC status register</description>
          <addressOffset>0x50</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ALRAF</name>
              <description>Alarm A flag
This flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the alarm A register (RTC_ALRMAR).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ALRBF</name>
              <description>Alarm B flag
This flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the alarm B register (RTC_ALRMBR).</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WUTF</name>
              <description>Wakeup timer flag
This flag is set by hardware when the wakeup auto-reload counter reaches 0.
If WUTOCLR[15:0] is different from 0x0000, WUTF is cleared by hardware when the wakeup
auto-reload counter reaches WUTOCLR value.
If WUTOCLR[15:0] is 0x0000, WUTF must be cleared by software.
This flag must be cleared by software at least 1.5 RTCCLK periods before WUTF is set to 1 again.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TSF</name>
              <description>Timestamp flag
This flag is set by hardware when a timestamp event occurs.
Note: TSF is not set if TAMPTS=1 and the tamper flag is read during the 3 ck_apre cycles following tamper event. Refer to Timestamp on tamper event for more details.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TSOVF</name>
              <description>Timestamp overflow flag
This flag is set by hardware when a timestamp event occurs while TSF is already set.
It is recommended to check and then clear TSOVF only after clearing the TSF bit. Otherwise, an overflow might not be noticed if a timestamp event occurs immediately before the TSF bit is cleared.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SSRUF</name>
              <description>SSR underflow flag
This flag is set by hardware when the SSR rolls under 0. SSRUF is not set when SSCLR=1.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RTC_MISR</name>
          <displayName>RTC_MISR</displayName>
          <description>RTC non-secure masked interrupt status register</description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ALRAMF</name>
              <description>Alarm A masked flag
This flag is set by hardware when the alarm A non-secure interrupt occurs.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ALRBMF</name>
              <description>Alarm B non-secure masked flag
This flag is set by hardware when the alarm B non-secure interrupt occurs.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WUTMF</name>
              <description>Wakeup timer non-secure masked flag
This flag is set by hardware when the wakeup timer non-secure interrupt occurs.
This flag must be cleared by software at least 1.5 RTCCLK periods before WUTF is set to 1 again.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TSMF</name>
              <description>Timestamp non-secure masked flag
This flag is set by hardware when a timestamp non-secure interrupt occurs.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TSOVMF</name>
              <description>Timestamp overflow non-secure masked flag
This flag is set by hardware when a timestamp interrupt occurs while TSMF is already set.
It is recommended to check and then clear TSOVF only after clearing the TSF bit. Otherwise, an overflow might not be noticed if a timestamp event occurs immediately before the TSF bit is cleared.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SSRUMF</name>
              <description>SSR underflow non-secure masked flag
This flag is set by hardware when the SSR underflow non-secure interrupt occurs.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RTC_SMISR</name>
          <displayName>RTC_SMISR</displayName>
          <description>RTC secure masked interrupt status register</description>
          <addressOffset>0x58</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ALRAMF</name>
              <description>Alarm A interrupt secure masked flag
This flag is set by hardware when the alarm A secure interrupt occurs.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ALRBMF</name>
              <description>Alarm B interrupt secure masked flag
This flag is set by hardware when the alarm B secure interrupt occurs.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WUTMF</name>
              <description>Wakeup timer interrupt secure masked flag
This flag is set by hardware when the wakeup timer secure interrupt occurs.
This flag must be cleared by software at least 1.5 RTCCLK periods before WUTF is set to 1 again.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TSMF</name>
              <description>Timestamp interrupt secure masked flag
This flag is set by hardware when a timestamp secure interrupt occurs.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TSOVMF</name>
              <description>Timestamp overflow interrupt secure masked flag
This flag is set by hardware when a timestamp secure interrupt occurs while TSMF is already set.
It is recommended to check and then clear TSOVF only after clearing the TSF bit. Otherwise, an overflow might not be noticed if a timestamp event occurs immediately before the TSF bit is cleared.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SSRUMF</name>
              <description>SSR underflow secure masked flag
This flag is set by hardware when the SSR underflow secure interrupt occurs.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RTC_SCR</name>
          <displayName>RTC_SCR</displayName>
          <description>RTC status clear register</description>
          <addressOffset>0x5C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CALRAF</name>
              <description>Clear alarm A flag
Writing 1 in this bit clears the ALRAF bit in the RTC_SR register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CALRBF</name>
              <description>Clear alarm B flag
Writing 1 in this bit clears the ALRBF bit in the RTC_SR register.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CWUTF</name>
              <description>Clear wakeup timer flag
Writing 1 in this bit clears the WUTF bit in the RTC_SR register.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CTSF</name>
              <description>Clear timestamp flag
Writing 1 in this bit clears the TSF bit in the RTC_SR register.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CTSOVF</name>
              <description>Clear timestamp overflow flag
Writing 1 in this bit clears the TSOVF bit in the RTC_SR register.
It is recommended to check and then clear TSOVF only after clearing the TSF bit. Otherwise, an overflow might not be noticed if a timestamp event occurs immediately before the TSF bit is cleared.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CSSRUF</name>
              <description>Clear SSR underflow flag
Writing '1' in this bit clears the SSRUF in the RTC_SR register.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RTC_ALRABINR</name>
          <displayName>RTC_ALRABINR</displayName>
          <description>RTC alarm A binary mode register</description>
          <addressOffset>0x70</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SS</name>
              <description>Synchronous counter alarm value in Binary mode
This value is compared with the contents of the synchronous counter to determine if Alarm A is to be activated. Only bits 0 up MASKSS-1 are compared.
SS[14:0] is the mirror of SS[14:0] in the RTC_ALRMASSRR, and so can also be read or written through RTC_ALRMASSR.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RTC_ALRBBINR</name>
          <displayName>RTC_ALRBBINR</displayName>
          <description>RTC alarm B binary mode register</description>
          <addressOffset>0x74</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SS</name>
              <description>Synchronous counter alarm value in Binary mode
This value is compared with the contents of the synchronous counter to determine if Alarm Bis to be activated. Only bits 0 up MASKSS-1 are compared.
SS[14:0] is the mirror of SS[14:0] in the RTC_ALRMBSSRR, and so can also be read or written through RTC_ALRMBSSR.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SPI3</name>
      <description>Serial peripheral interface</description>
      <groupName>SPI</groupName>
      <baseAddress>0x46002000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x400</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>SPI3</name>
        <description>SPI3 global interrupt</description>
        <value>63</value>
      </interrupt>
      <registers>
        <register>
          <name>SPI_CR1</name>
          <displayName>SPI_CR1</displayName>
          <description>SPI control register 1</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SPE</name>
              <description>serial peripheral enable
This bit is set by and cleared by software.
When SPE = 1, SPI data transfer is enabled, SPI_CFG1 and SPI_CFG2 configuration registers, CRCPOLY, UDRDR, part of SPI_AUTOCR register and IOLOCK bit in the SPI_CR1 register are write protected. They can be changed only when SPE = 0.
When SPE = 0 any SPI operation is stopped and disabled, all the pending requests of the events with enabled interrupt are blocked except the MODF interrupt request (but their pending still propagates the request of the spi_plck clock), the SS output is deactivated at master, the RDY signal keeps not ready status at slave, the internal state machine is reseted, all the FIFOs content is flushed, CRC calculation initialized, receive data register is read zero.
SPE is cleared and cannot be set when MODF error flag is active.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Serial peripheral disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Serial peripheral enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MASRX</name>
              <description>master automatic suspension in Receive mode 
This bit is set and cleared by software to control continuous SPI transfer in master receiver mode and automatic management in order to avoid overrun condition. 
When SPI communication is suspended by hardware automatically, it could happen that few bits of next frame are already clocked out due to internal synchronization delay. 
This is why, the automatic suspension is not quite reliable when size of data drops below 8 bits. In this case, a safe suspension can be achieved by combination with delay inserted between data frames applied when MIDI parameter keeps a non zero value; sum of data size and the interleaved SPI cycles should always produce interval at length of 8 SPI clock periods at minimum. After software clearing of the SUSP bit, the communication resumes and continues by subsequent bits transaction without any next constraint. Prior the SUSP bit is cleared, the user must release the RxFIFO space as much as possible by reading out all the data packets available at RxFIFO based on the RXP flag indication to prevent any subsequent suspension.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>SPI flow/clock generation is continuous, regardless of overrun condition. (data are lost)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>SPI flow is suspended temporary on RxFIFO full condition, before reaching overrun condition. The SUSP flag is set when the SPI communication is suspended.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CSTART</name>
              <description>master transfer start
This bit can be set by software if SPI is enabled only to start an SPI communication. it is cleared by hardware when end of transfer (EOT) flag is set or when a transaction suspend request is accepted.
In SPI mode, the bit is taken into account at master mode only. If transmission is enabled, communication starts or continues only if any data is available in the transmission FIFO.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>master transfer is at idle</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>master transfer is ongoing or temporary suspended by automatic suspend</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CSUSP</name>
              <description>master suspend request 
This bit reads as zero.
In Master mode, when this bit is set by software, the CSTART bit is reset at the end of the current frame and communication is suspended. The user has to check SUSP flag to check end of the frame transaction.
The Master mode communication must be suspended (using this bit or keeping TXDR empty) before going to Low-power mode. Can be used in SPI or I2S mode.
After software suspension, SUSP flag must be cleared and SPI disabled and re-enabled before the next transaction starts.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>HDDIR</name>
              <description>Rx/Tx direction at Half-duplex mode
In Half-Duplex configuration the HDDIR bit establishes the Rx/Tx direction of the data transfer. This bit is ignored in Full-Duplex or any Simplex configuration.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>SPI is receiver</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>SPI is transmitter</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SSI</name>
              <description>internal SS signal input level
This bit has an effect only when the SSM bit is set. The value of this bit is forced onto the peripheral SS input internally and the I/O value of the SS pin is ignored.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CRC33_17</name>
              <description>32-bit CRC polynomial configuration</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Full size (33-bit or 17-bit) CRC polynomial is not used</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Full size (33-bit or 17-bit) CRC polynomial is used</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RCRCINI</name>
              <description>CRC calculation initialization pattern control for receiver</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>All zero pattern is applied</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>All ones pattern is applied</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TCRCINI</name>
              <description>CRC calculation initialization pattern control for transmitter</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>all zero pattern is applied</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>all ones pattern is applied</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IOLOCK</name>
              <description>locking the AF configuration of associated I/Os
This bit is set by software and cleared by hardware whenever the SPE bit is changed from 1 to 0.
When this bit is set, SPI_CFG2 register content cannot be modified. This bit can be set when SPI is disabled only else it is write protected. It is cleared and cannot be set when MODF bit is set.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>AF configuration is not locked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>AF configuration is locked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_CR2</name>
          <displayName>SPI_CR2</displayName>
          <description>SPI control register 2</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TSIZE</name>
              <description>number of data at current transfer
When these bits are changed by software, the SPI must be disabled.
Endless transaction is initialized when CSTART is set while zero value is stored at TSIZE. TSIZE cannot be set to 0xFFFF respective 0x3FFF value when CRC is enabled.
Note: TSIZE[15:10] bits are reserved at limited feature set instances and must be kept at reset value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_CFG1</name>
          <displayName>SPI_CFG1</displayName>
          <description>SPI configuration register 1</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <resetValue>0x00070007</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DSIZE</name>
              <description>number of bits in at single SPI data frame
.....
Maximum data size can be limited up to 16-bits at some instances. At instances with limited set of features, DSIZE2:0] bits are reserved and must be kept at reset state. DSIZE[4:3] bits then control next settings of data size:
00xxx: 8-bits
01xxx: 16-bits
10xxx: 24-bits
Note: 11xxx: 32-bits.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>not used</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>not used</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>not used</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>4-bits</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>5-bits</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>6-bits</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x6</name>
                  <description>7-bits</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7</name>
                  <description>8-bits</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1D</name>
                  <description>30-bits</description>
                  <value>0x1D</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1E</name>
                  <description>31-bits</description>
                  <value>0x1E</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1F</name>
                  <description>32-bits</description>
                  <value>0x1F</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FTHLV</name>
              <description>FIFO threshold level
Defines number of data frames at single data packet. Size of the packet should not exceed 1/2 of FIFO space.
SPI interface is more efficient if configured packet sizes are aligned with data register access parallelism: 
If SPI data register is accessed as a 16-bit register and DSIZE less than or equal 8 bit, better to select FTHLV = 2, 4, 6.
If SPI data register is accessed as a 32-bit register and DSIZE 8 bit, better to select FTHLV = 2, 4, 6, while if DSIZE less than or equal 8bit, better to select FTHLV = 4, 8, 12.
Note: FTHLV[3:2] bits are reserved at instances with limited set of features</description>
              <bitOffset>5</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>1-data</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>2-data</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>3-data</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>4-data</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>5-data</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>6-data</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x6</name>
                  <description>7-data</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7</name>
                  <description>8-data</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x8</name>
                  <description>9-data</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x9</name>
                  <description>10-data</description>
                  <value>0x9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xA</name>
                  <description>11-data</description>
                  <value>0xA</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xB</name>
                  <description>12-data</description>
                  <value>0xB</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xC</name>
                  <description>13-data</description>
                  <value>0xC</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xD</name>
                  <description>14-data</description>
                  <value>0xD</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xE</name>
                  <description>15-data</description>
                  <value>0xE</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xF</name>
                  <description>16-data</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UDRCFG</name>
              <description>behavior of slave transmitter at underrun condition
For more details see Figure977: Optional configurations of slave detecting underrun condition.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>slave sends a constant pattern defined by the user at the SPI_UDRDR register</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Slave repeats lastly received data from master. When slave is configured at transmit only mode (COMM[1:0] = 01), all zeros pattern is repeated.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXDMAEN</name>
              <description>Rx DMA stream enable</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Rx-DMA disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Rx-DMA enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXDMAEN</name>
              <description>Tx DMA stream enable</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Tx DMA disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Tx DMA enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CRCSIZE</name>
              <description>length of CRC frame to be transacted and compared
Most significant bits are taken into account from polynomial calculation when CRC result is transacted or compared. The length of the polynomial is not affected by this setting.
.....
The value must be set equal or multiply of data size (DSIZE[4:0]). Its maximum size corresponds to DSIZE maximum at the instance.
Note: The most significant bit at CRCSIZE bit field is reserved at the peripheral instances where data size is limited to 16-bit.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>4-bits</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>5-bits</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>6-bits</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x6</name>
                  <description>7-bits</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7</name>
                  <description>8-bits</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1D</name>
                  <description>30-bits</description>
                  <value>0x1D</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1E</name>
                  <description>31-bits</description>
                  <value>0x1E</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1F</name>
                  <description>32-bits</description>
                  <value>0x1F</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CRCEN</name>
              <description>hardware CRC computation enable</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>CRC calculation disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>CRC calculation enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MBR</name>
              <description>master baud rate prescaler setting
Note: MBR setting is considered at slave working at TI mode, too (see Section80.5.1: TI mode).</description>
              <bitOffset>28</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>SPI master clock/2</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>SPI master clock/4</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>SPI master clock/8</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>SPI master clock/16</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>SPI master clock/32</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>SPI master clock/64</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x6</name>
                  <description>SPI master clock/128</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7</name>
                  <description>SPI master clock/256</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BPASS</name>
              <description>bypass of the prescaler at master baud rate clock generator</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>bypass is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>bypass is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_CFG2</name>
          <displayName>SPI_CFG2</displayName>
          <description>SPI configuration register 2</description>
          <addressOffset>0x0C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MSSI</name>
              <description>Master SS Idleness
Specifies an extra delay, expressed in number of SPI clock cycle periods, inserted additionally between active edge of SS opening a session and the beginning of the first data frame of the session in Master mode when SSOE is enabled.
...
This feature is not supported in TI mode.
Note: To include the delay, the SPI must be disabled and re-enabled between sessions.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no extra delay</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>1 clock cycle period delay added</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xF</name>
                  <description>15 clock cycle periods delay added</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MIDI</name>
              <description>master Inter-Data Idleness
Specifies minimum time delay (expressed in SPI clock cycles periods) inserted between two consecutive data frames in Master mode.
...
Note: This feature is not supported in TI mode.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no delay</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>1 clock cycle period delay</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xF</name>
                  <description>15 clock cycle periods delay</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RDIOM</name>
              <description>RDY signal input/output management
Note: When DSIZE at the SPI_CFG1 register is configured shorter than 8-bit, the RDIOM bit must be kept at zero.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>RDY signal is defined internally fixed as permanently active (RDIOP setting has no effect)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>RDY signal is overtaken from alternate function input (at master case) or output (at slave case) of the dedicated pin (RDIOP setting takes effect)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RDIOP</name>
              <description>RDY signal input/output polarity</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>high level of the signal means the slave is ready for communication</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>low level of the signal means the slave is ready for communication</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IOSWP</name>
              <description>swap functionality of MISO and MOSI pins
When this bit is set, the function of MISO and MOSI pins alternate functions are inverted. 
Original MISO pin becomes MOSI and original MOSI pin becomes MISO.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no swap</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>MOSI and MISO are swapped</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>COMM</name>
              <description>SPI Communication Mode</description>
              <bitOffset>17</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>full-duplex</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>simplex transmitter</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>simplex receiver</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>half-duplex</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SP</name>
              <description>serial protocol
others: reserved, must not be used</description>
              <bitOffset>19</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>SPI Motorola</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>SPI TI</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MASTER</name>
              <description>SPI Master</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>SPI Slave</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>SPI Master</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LSBFRST</name>
              <description>data frame format
Note: 1: LSB transmitted first</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>MSB transmitted first</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CPHA</name>
              <description>clock phase</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>the first clock transition is the first data capture edge</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>the second clock transition is the first data capture edge</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CPOL</name>
              <description>clock polarity</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>SCK signal is at 0 when idle</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>SCK signal is at 1 when idle</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SSM</name>
              <description>software management of SS signal input
When master uses hardware SS output (SSM = 0 and SSOE = 1) the SS signal input is forced to not active state internally to prevent master mode fault error.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>SS input value is determined by the SS PAD</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>SS input value is determined by the SSI bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SSIOP</name>
              <description>SS input/output polarity</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>low level is active for SS signal</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>high level is active for SS signal</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SSOE</name>
              <description>SS output enable
This bit is taken into account in Master mode only</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>SS output is disabled and the SPI can work in multi-master configuration</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>SS output is enabled. The SPI cannot work in a multi-master environment. It forces the SS pin at inactive level after the transfer is completed or SPI is disabled with respect to SSOM, MIDI, MSSI, SSIOP bits setting</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SSOM</name>
              <description>SS output management in Master mode
This bit is taken into account in Master mode when SSOE is enabled. It allows the SS output to be configured between two consecutive data transfers.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>SS is kept at active level till data transfer is completed, it becomes inactive with EOT flag</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>SPI data frames are interleaved with SS non active pulses when MIDI[3:0]1</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AFCNTR</name>
              <description>alternate function GPIOs control
This bit is taken into account when SPE = 0 only
Note: When SPI must be disabled temporary for a specific configuration reason (e.g. CRC reset, CPHA or HDDIR change) setting this bit prevents any glitches on the associated outputs configured at alternate function mode by keeping them forced at state corresponding the current SPI configuration.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>The peripheral takes no control of GPIOs while it is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The peripheral keeps always control of all associated GPIOs</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_IER</name>
          <displayName>SPI_IER</displayName>
          <description>SPI interrupt enable register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXPIE</name>
              <description>RXP interrupt enable</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>RXP interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>RXP interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXPIE</name>
              <description>TXP interrupt enable
TXPIE is set by software and cleared by TXTF flag set event.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>TXP interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>TXP interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DXPIE</name>
              <description>DXP interrupt enabled
DXPIE is set by software and cleared by TXTF flag set event.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>DXP interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>DXP interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EOTIE</name>
              <description>EOT, SUSP and TXC interrupt enable</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>EOT/SUSP/TXC interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>EOT/SUSP/TXC interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXTFIE</name>
              <description>TXTFIE interrupt enable</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>TXTF interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>TXTF interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UDRIE</name>
              <description>UDR interrupt enable</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>UDR interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>UDR interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OVRIE</name>
              <description>OVR interrupt enable</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>OVR interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>OVR interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CRCEIE</name>
              <description>CRC error interrupt enable</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>CRC interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>CRC interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TIFREIE</name>
              <description>TIFRE interrupt enable</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>TIFRE interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>TIFRE interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MODFIE</name>
              <description>mode Fault interrupt enable</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>MODF interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>MODF interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_SR</name>
          <displayName>SPI_SR</displayName>
          <description>SPI status register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <resetValue>0x00001002</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXP</name>
              <description>Rx-Packet available
     In I2S mode, it must be interpreted as follow: RxFIFO level is lower than FTHLV
     In I2S mode, it must be interpreted as follow: RxFIFO level is higher or equal to FTHLV
RXP flag is changed by hardware. It monitors number of overall data currently available at RxFIFO if SPI is enabled. It must be checked once a data packet is completely read out from RxFIFO.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>In SPI mode, it must be interpreted as follow: RxFIFO is empty or a not complete data packet is received</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>In SPI mode, it must be interpreted as follow: RxFIFO contains at least 1 data packet</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXP</name>
              <description>Tx-Packet space available
   In I2S mode, it must be interpreted as follow: there is less than FTHLV free locations in the TxFIFO 
   In I2S mode, it must be interpreted as follow: there is FTHLV or more than FTHLV free locations in the TxFIFO 
TXP flag is changed by hardware. It monitors overall space currently available at TxFIFO no matter if SPI is enabled or not. It must be checked once a complete data packet is stored at TxFIFO.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>In SPI mode, it must be interpreted as follow: there is not enough space to locate next data packet at TxFIFO</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>In SPI mode, it must be interpreted as follow: TxFIFO has enough free location to host 1 data packet</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DXP</name>
              <description>duplex packet
DXP flag is set whenever both TXP and RXP flags are set regardless SPI mode.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>TxFIFO is Full and/or RxFIFO is Empty</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>both TxFIFO has space for write and RxFIFO contains for read a single packet at least</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EOT</name>
              <description>end of transfer
EOT is set by hardware as soon as a full transfer is complete, that is when SPI is re-enabled or when TSIZE number of data have been transmitted and/or received on the SPI. EOT is cleared when SPI is re-enabled or by writing 1 to EOTC bit of SPI_IFCR optionally.
EOT flag triggers an interrupt if EOTIE bit is set.
If DXP flag is used until TXTF flag is set and DXPIE is cleared, EOT can be used to download the last packets contained into RxFIFO in one-shot.
In master, EOT event terminates the data transaction and handles SS output optionally. When CRC is applied, the EOT event is extended over the CRC frame transaction.
To restart the internal state machine properly, SPI is strongly suggested to be disabled and re-enabled before next transaction starts despite its setting is not changed.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>transfer is ongoing or not started</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>transfer complete</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXTF</name>
              <description>transmission transfer filled
TXTF is set by hardware as soon as all of the data packets in a transfer have been submitted for transmission by application software or DMA, that is when TSIZE number of data have been pushed into the TxFIFO.
This bit is cleared by software write 1 to TXTFC bit of SPI_IFCR exclusively.
TXTF flag triggers an interrupt if TXTFIE bit is set.
TXTF setting clears the TXPIE and DXPIE masks so to off-load application software from calculating when to disable TXP and DXP interrupts.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>upload of TxFIFO is ongoing or not started</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>TxFIFO upload is finished</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UDR</name>
              <description>underrun
This bit is cleared when SPI is re-enabled or by writing 1 to UDRC bit of SPI_IFCR optionally.
Note: In SPI mode, the UDR flag applies to Slave mode only. In I2S/PCM mode, (when available) this flag applies to Master and Slave mode</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no underrun</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>underrun detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OVR</name>
              <description>overrun
This bit is cleared when SPI is re-enabled or by writing 1 to OVRC bit of SPI_IFCR optionally.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no overrun</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>overrun detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CRCE</name>
              <description>CRC error
This bit is cleared when SPI is re-enabled or by writing 1 to CRCEC bit of SPI_IFCR optionally.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no CRC error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>CRC error detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TIFRE</name>
              <description>TI frame format error
This bit is cleared by writing 1 to TIFREC bit of SPI_IFCR exclusively.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no TI Frame Error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>TI frame error detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MODF</name>
              <description>mode fault
This bit is cleared by writing 1 to MODFC bit of SPI_IFCR exclusively.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no mode fault</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>mode fault detected. When MODF is set, SPE and IOLOCK bits of SPI_CR1 register are reset and their setting is blocked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SUSP</name>
              <description>suspension status 
In Master mode, SUSP is set by hardware either as soon as the current frame is completed after CSUSP request is done or at master automatic suspend receive mode (MASRX bit is set at SPI_CR1 register) on RxFIFO full condition.
SUSP generates an interrupt when EOTIE is set.
This bit must be cleared prior SPI is disabled and this is done by writing 1 to SUSPC bit of SPI_IFCR exclusively.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>SPI not suspended (Master mode active or other mode).</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Master mode is suspended (current frame completed).</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXC</name>
              <description>TxFIFO transmission complete
The flag behavior depends on TSIZE setting.
When TSIZE = 0 the TXC is changed by hardware exclusively and it raises each time the TxFIFO becomes empty and there is no activity on the bus.
If TSIZE different 0 there is no specific reason to monitor TXC as it just copies the EOT flag value including its software clearing. The TXC generates an interrupt when EOTIE is set.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>current data transaction is still ongoing, data is available in TxFIFO or last frame transmission is on going.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>last TxFIFO frame transmission complete</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXPLVL</name>
              <description>RxFIFO packing level 
When RXWNE = 0 and data size is set up to 16-bit, the value gives number of remaining data frames persisting at RxFIFO.
Note: (*): Optional value when data size is set up to 8-bit only.
When data size is greater than 16-bit, these bits are always read as 00. In that consequence, the single data frame received at the FIFO cannot be detected neither by RWNE nor by RXPLVL bits if data size is set from 17 to 24 bits. The user then must apply other methods like TSIZE  0 or FTHLV = 0.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no next frame is available at RxFIFO</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>1 frame is available</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>2 frames are available*</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>3 frames are available*</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXWNE</name>
              <description>RxFIFO word not empty 
Note: This bit value does not depend on DSIZE setting and keeps together with RXPLVL[1:0] information about RxFIFO occupancy by residual data.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>less than four bytes of RxFIFO space is occupied by data</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>at least four bytes of RxFIFO space is occupied by data</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CTSIZE</name>
              <description>number of data frames remaining in current TSIZE session
The value is not quite reliable when traffic is ongoing on bus or during autonomous operation in low-power mode.
Note: CTSIZE[15:0] bits are not available in instances with limited set of features.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_IFCR</name>
          <displayName>SPI_IFCR</displayName>
          <description>SPI interrupt/status flags clear register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EOTC</name>
              <description>end of transfer flag clear
Writing a 1 into this bit clears EOT flag in the SPI_SR register</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>TXTFC</name>
              <description>transmission transfer filled flag clear
Writing a 1 into this bit clears TXTF flag in the SPI_SR register</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>UDRC</name>
              <description>underrun flag clear
Writing a 1 into this bit clears UDR flag in the SPI_SR register</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>OVRC</name>
              <description>overrun flag clear
Writing a 1 into this bit clears OVR flag in the SPI_SR register</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CRCEC</name>
              <description>CRC error flag clear
Writing a 1 into this bit clears CRCE flag in the SPI_SR register</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>TIFREC</name>
              <description>TI frame format error flag clear
Writing a 1 into this bit clears TIFRE flag in the SPI_SR register</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>MODFC</name>
              <description>mode fault flag clear
Writing a 1 into this bit clears MODF flag in the SPI_SR register</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SUSPC</name>
              <description>Suspend flag clear
Writing a 1 into this bit clears SUSP flag in the SPI_SR register</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_AUTOCR</name>
          <displayName>SPI_AUTOCR</displayName>
          <description>SPI autonomous mode control register</description>
          <addressOffset>0x1C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TRIGSEL</name>
              <description>trigger selection (refer Section: Description of SPI interconnections).
...
Note: these bits can be written only when SPE=0.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>spi_trg0 is selected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>spi_trg1 is selected</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xF</name>
                  <description>spi_trg15 is selected</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TRIGPOL</name>
              <description>trigger polarity
Note: This bit can be written only when SPE=0.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>trigger is active on raising edge</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>trigger is active on falling edge</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TRIGEN</name>
              <description>HW control of CSTART triggering enable
Note: if user cannot prevent trigger event during write, the TRIGEN must be changed when SPI is disabled</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>HW control disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>HW control enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_TXDR</name>
          <displayName>SPI_TXDR</displayName>
          <description>SPI transmit data register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXDR</name>
              <description>transmit data register
The register serves as an interface with TxFIFO. A write to it accesses TxFIFO.
Note: data is always right-aligned. Unused bits are ignored when writing to the register, and read as zero when the register is read.
Note: DR can be accessed byte-wise (8-bit access): in this case only one data-byte is written by single access.
Note: halfword-wise (16 bit access) in this case 2 data-bytes or 1 halfword-data can be written by single access.
Note: word-wise (32 bit access). In this case 4 data-bytes or 2 halfword-data or word-data can be written by single access.
Note: Write access of this register less than the configured data size is forbidden.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_RXDR</name>
          <displayName>SPI_RXDR</displayName>
          <description>SPI receive data register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXDR</name>
              <description>receive data register
The register serves as an interface with RxFIFO. When it is read, RxFIFO is accessed.
Note: data is always right-aligned. Unused bits are read as zero when the register is read. Writing to the register is ignored.
Note: DR can be accessed byte-wise (8-bit access): in this case only one data-byte is read by single access
Note: halfword-wise (16 bit access) in this case 2 data-bytes or 1 halfword-data can be read by single access
Note: word-wise (32 bit access). In this case 4 data-bytes or 2 halfword-data or word-data can be read by single access.
Note: Read access of this register less than the configured data size is forbidden.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_CRCPOLY</name>
          <displayName>SPI_CRCPOLY</displayName>
          <description>SPI polynomial register</description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000107</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CRCPOLY</name>
              <description>CRC polynomial register
This register contains the polynomial for the CRC calculation.
The default 9-bit polynomial setting 0x107 corresponds to default 8-bit setting of DSIZE. It is compatible with setting 0x07 used in other ST products with fixed length of the polynomial string, where the most significant bit of the string is always kept hidden.
Length of the polynomial is given by the most significant bit of the value stored in this register. It must be set greater than DSIZE. CRC33_17 bit must be set additionally with CRCPOLY register when DSIZE is configured to maximum 32-bit or 16-bit size and CRC is enabled (to keep polynomial length grater than data size).
Note: CRCPOLY[31:16] bits are reserved at instances with data size limited to 16-bit. There is no constrain when 32-bit access is applied at these addresses. Reserved bits 31-16 are always read zero while any write to them is ignored.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_TXCRC</name>
          <displayName>SPI_TXCRC</displayName>
          <description>SPI transmitter CRC register</description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXCRC</name>
              <description>CRC register for transmitter
When CRC calculation is enabled, the TXCRC[31:0] bits contain the computed CRC value of the subsequently transmitted bytes. CRC calculation is initialized when the CRCEN bit of SPI_CR1 is written to 1 or when a data block is transacted completely. The CRC is calculated serially using the polynomial programmed in the SPI_CRCPOLY register.
The number of bits considered at calculation depends on SPI_CRCPOLY register and CRCSIZE bits settings at SPI_CFG1 register.
Note: a read to this register when the communication is ongoing could return an incorrect value.
Note: TXCRC[31-16] bits are reserved at instances with data size limited to 16-bit. There is no constrain when 32-bit access is applied at these addresses. Reserved bits 31-16 are always read zero while any write to them is ignored.
Note: The configuration of CRCSIZE bit field is not taken into account when the content of this register is read by software. No masking is applied for unused bits in this case.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_RXCRC</name>
          <displayName>SPI_RXCRC</displayName>
          <description>SPI receiver CRC register</description>
          <addressOffset>0x48</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXCRC</name>
              <description>CRC register for receiver
When CRC calculation is enabled, the RXCRC[31:0] bits contain the computed CRC value of the subsequently received bytes. CRC calculation is initialized when the CRCEN bit of SPI_CR1 is written to 1 or when a data block is transacted completely. The CRC is calculated serially using the polynomial programmed in the SPI_CRCPOLY register.
The number of bits considered at calculation depends on SPI_CRCPOLY register and CRCSIZE bits settings at SPI_CFG1 register.
Note: a read to this register when the communication is ongoing could return an incorrect value.
Note: RXCRC[31-16] bits are reserved at the peripheral instances with data size limited to 16-bit. There is no constrain when 32-bit access is applied at these addresses. Reserved bits 31-16 are always read zero while any write to them is ignored.
Note: The configuration of CRCSIZE bit field is not taken into account when the content of this register is read by software. No masking is applied for unused bits in this case.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_UDRDR</name>
          <displayName>SPI_UDRDR</displayName>
          <description>SPI underrun data register</description>
          <addressOffset>0x4C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>UDRDR</name>
              <description>data at slave underrun condition
The register is taken into account in Slave mode and at underrun condition only. The number of bits considered depends on DSIZE bit settings of the SPI_CFG1 register. Underrun condition handling depends on setting UDRCFG bit at SPI_CFG1 register.
Note: UDRDR[31-16] bits are reserved at the peripheral instances with data size limited to 16-bit. There is no constraint when 32-bit access is applied at these addresses. Reserved bits 31-16 are always read zero while any write to them is ignored.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SYSCFG</name>
      <description>System configuration controller</description>
      <groupName>SYSCFG</groupName>
      <baseAddress>0x46000400</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x400</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>SYSCFG_SECCFGR</name>
          <displayName>SYSCFG_SECCFGR</displayName>
          <description>SYSCFG secure configuration register</description>
          <addressOffset>0x000</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SYSCFGSEC</name>
              <description>SYSCFG clock control, memory erase status and compensation cell registers security</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>SYSCFG configuration clock in RCC registers, SYSCFG_MESR and SYSCFG_CCCSR, SYSCFG_CCVR and SYSCFG_CCCR can be read and written by secure and non-secure access.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>SYSCFG configuration clock in RCC registers, SYSCFG_MESR and SYSCFG_CCCSR, SYSCFG_CCVR and SYSCFG_CCCR can be read and written by secure access only.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLASSBSEC</name>
              <description>Class B security</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>SYSCFG_CFGR2 register can be read and written by secure and non-secure access.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>SYSCFG_CFGR2 register can be read and written by secure access only.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FPUSEC</name>
              <description>FPU security</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>SYSCFG_FPUIMR register can be read and written by secure and non-secure access.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>SYSCFG_FPUIMR register can be read and written by secure access only.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SYSCFG_CFGR1</name>
          <displayName>SYSCFG_CFGR1</displayName>
          <description>SYSCFG configuration register 1</description>
          <addressOffset>0x004</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BOOSTEN</name>
              <description>I/O analog switch voltage booster enable
Access can be protected by GTZC_TZSC ADC4SEC.
Note: Refer to Table121 for setting.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>I/O analog switches are supplied by VsubDDA/sub voltage.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>I/O analog switches are supplied by a dedicated voltage booster (supplied by VsubDD/sub).</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ANASWVDD</name>
              <description>GPIO analog switch control voltage selection
Access can be protected by GTZC_TZSC ADC4SEC.
Note: Refer to Table121 for setting.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>I/O analog switches are supplied by VsubDDA/sub or booster when booster is ON.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>I/O analog switches are supplied by VsubDD/sub.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PA6_FMP</name>
              <description>Fast-mode Plus drive capability activation on PA6
This bit can be read and written only with secure access if PA6 is secure in GPIOA. This bit enables the Fast-mode Plus drive mode for PA6 when PA6 is not used by I2C peripheral. This can be used to dive a LED for instance.
Access can be protected by GPIOA SEC6.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>PA6 pin operates in standard mode when not used by I2C peripheral</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Fast-mode Plus mode is enabled on PA6 pin and the GPIO speed control is bypassed.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PA7_FMP</name>
              <description>Fast-mode Plus drive capability activation on PA7
This bit can be read and written only with secure access if PA7 is secure in GPIOA. This bit enables the Fast-mode Plus drive mode for PA7 when PA7 is not used by I2C peripheral. This can be used to dive a LED for instance.
Access can be protected by GPIOA SEC7.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>PA7 pin operates in standard mode when not used by I2C peripheral</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Fast-mode Plus mode is enabled on PA7 pin and the GPIO speed control is bypassed.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PA15_FMP</name>
              <description>Fast-mode Plus drive capability activation on PA15
This bit can be read and written only with secure access if PA15 is secure in GPIOA. This bit enables the Fast-mode Plus drive mode for PA15 when PA15 is not used by I2C peripheral. This can be used to dive a LED for instance.
Access can be protected by GPIOA SEC15.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>PA15 pin operates in standard mode when not used by I2C peripheral</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Fast-mode Plus mode is enabled on PA15 pin and the GPIO speed control is bypassed.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PB3_FMP</name>
              <description>Fast-mode Plus drive capability activation on PB3
This bit can be read and written only with secure access if PB3 is secure in GPIOB. This bit enables the Fast-mode Plus drive mode for PB3 when PB3 is not used by I2C peripheral. This can be used to dive a LED for instance.
Access can be protected by GPIOB SEC3.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>PB3 pin operates in standard mode when not used by I2C peripheral</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Fast-mode Plus mode is enabled on PAB3 pin and the GPIO speed control is bypassed.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SYSCFG_FPUIMR</name>
          <displayName>SYSCFG_FPUIMR</displayName>
          <description>SYSCFG FPU interrupt mask register</description>
          <addressOffset>0x008</addressOffset>
          <size>0x20</size>
          <resetValue>0x0000003F</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FPU_IE</name>
              <description>Floating point unit interrupts enable bits
FPU_IE[5]: Inexact interrupt enable (interrupt disable at reset)
FPU_IE[4]: Input abnormal interrupt enable
FPU_IE[3]: Overflow interrupt enable
FPU_IE[2]: Underflow interrupt enable
FPU_IE[1]: Divide-by-zero interrupt enable
FPU_IE[0]: Invalid operation Interrupt enable</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SYSCFG_CNSLCKR</name>
          <displayName>SYSCFG_CNSLCKR</displayName>
          <description>SYSCFG CPU non-secure lock register</description>
          <addressOffset>0x00C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LOCKNSVTOR</name>
              <description>VTOR_NS register lock
This bit is set by software and cleared only by a system reset.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>VTOR_NS register write enabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>VTOR_NS register write disabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LOCKNSMPU</name>
              <description>Non-secure MPU registers lock
This bit is set by software and cleared only by a system reset. When set, this bit disables write access to non-secure MPU_CTRL_NS, MPU_RNR_NS and MPU_RBAR_NS registers.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Non-secure MPU registers write enabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Non-secure MPU registers write disabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SYSCFG_CSLOCKR</name>
          <displayName>SYSCFG_CSLOCKR</displayName>
          <description>SYSCFG CPU secure lock register</description>
          <addressOffset>0x010</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LOCKSVTAIRCR</name>
              <description>VTOR_S register and AIRCR register bits lock
This bit is set by software and cleared only by a system reset. When set, it disables write access to VTOR_S register, PRIS and BFHFNMINS bits in the AIRCR register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>VTOR_S register PRIS and BFHFNMINS bits in the AIRCR register write enabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>VTOR_S register PRIS and BFHFNMINS bits in the AIRCR register write disabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LOCKSMPU</name>
              <description>Secure MPU registers lock
This bit is set by software and cleared only by a system reset. When set, it disables write access to secure MPU_CTRL, MPU_RNR and MPU_RBAR registers.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Secure MPU registers writes enabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Secure MPU registers writes disabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LOCKSAU</name>
              <description>SAU registers lock
This bit is set by software and cleared only by a system reset. When set, it disables write access to SAU_CTRL, SAU_RNR, SAU_RBAR and SAU_RLAR registers.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>SAU registers write enabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>SAU registers write disabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SYSCFG_CFGR2</name>
          <displayName>SYSCFG_CFGR2</displayName>
          <description>SYSCFG configuration register 2</description>
          <addressOffset>0x014</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLL</name>
              <description>Cortex-M33 LOCKUP (hardfault) output enable
This bit is set by software and cleared only by a system reset. It can be used to enable and lock the connection of Cortex-M33 LOCKUP (hardfault) output to TIM1/16/17 break input.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Cortex-M33 LOCKUP output disconnected from TIM1/16/17 break inputs</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Cortex-M33 LOCKUP output connected to TIM1/16/17 break inputs</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SPL</name>
              <description>SRAM2 parity lock bit
This bit is set by software and cleared only by a system reset. It can be used to enable and lock the SRAM2 parity error signal connection to TIM1/16/17 break inputs.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>SRAM2 parity error disconnected from TIM1/16/17 break inputs</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>SRAM2 parity error connected to TIM1/16/17 break inputs</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PVDL</name>
              <description>PVD lock enable bit
This bit is set by software and cleared only by a system reset. It can be used to enable and lock the PVD connection to TIM1/16/17 break input, as well as the PVDE and PVDLS[2:0] in the PWR register.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>PVD interrupt disconnected from TIM1/16/17 break input. PVDE and PVDLS[2:0] bits can be programmed by the application.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>PVD interrupt connected to TIM1/16/17 break input. PVDE and PVDLS[2:0] bits are read only.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ECCL</name>
              <description>ECC lock
This bit is set by software and cleared only by a system reset. It can be used to enable and lock the Flash ECC double error signal connection to TIM1/16/17 break input.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>ECC double error disconnected from TIM1/16/17 break input</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>ECC double error connected to TIM1/16/17 break input</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SYSCFG_MESR</name>
          <displayName>SYSCFG_MESR</displayName>
          <description>SYSCFG memory erase status register</description>
          <addressOffset>0x018</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MCLR</name>
              <description>Device memories erase status
This bit is set by hardware when SRAM2, ICACHE, PKA SRAM erase is completed after power-on reset or tamper detection (refer to Section75: Tamper and backup registers (TAMP) for more details). This bit is not reset by system reset and is cleared by software by writing 1 to it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Memory erase ongoing if not yet cleared by software</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Memory erase done</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IPMEE</name>
              <description>ICACHE and PKA SRAM erase status
This bit is set by hardware when ICACHE and PKA SRAM erase is completed after potential tamper detection (refer to Section75: Tamper and backup registers (TAMP) for more details). This bit is cleared by software by writing 1 to it.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>ICACHE and PKA SRAM erase ongoing if not yet cleared by software</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>ICACHE and PKA SRAM erase done</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SYSCFG_CCCSR</name>
          <displayName>SYSCFG_CCCSR</displayName>
          <description>SYSCFG compensation cell control/status register</description>
          <addressOffset>0x01C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000002</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EN1</name>
              <description>VDD I/Os compensation cell enable
This bit enables the compensation cell of the I/Os supplied by VsubDD/sub.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>VDD I/Os compensation cell disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>VDD I/Os compensation cell enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CS1</name>
              <description>VDD I/Os code selection
This bit selects the code to be applied for the compensation cell of the I/Os supplied by VsubDD/sub.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>VDD I/Os code from the cell (available in the SYSCFG_CCVR)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>VDD I/Os code from the SYSCFG compensation cell code register (SYSCFG_CCCR)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RDY1</name>
              <description>VDD I/Os compensation cell ready flag
This bit provides the compensation cell status of the I/Os supplied by VsubDD/sub.
Note: The HSI16 clock is required for the compensation cell to work properly. The compensation cell ready bit (RDY1) is not set if the HSI16 clock is not enabled (HSION).</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>VDD I/Os compensation cell not ready</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>VDD I/Os compensation cell ready</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SYSCFG_CCVR</name>
          <displayName>SYSCFG_CCVR</displayName>
          <description>SYSCFG compensation cell value register</description>
          <addressOffset>0x020</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NCV1</name>
              <description>NMOS compensation value of the I/Os supplied by VsubDD/sub
This value is provided by the cell and can be used by the CPU to compute an I/Os compensation cell code for NMOS transistors. This code is applied to the I/Os compensation cell when the CS1 bit of the SYSCFG_CCCSR is reset.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PCV1</name>
              <description>PMOS compensation value of the I/Os supplied by VsubDD/sub
This value is provided by the cell and can be used by the CPU to compute an I/Os compensation cell code for PMOS transistors. This code is applied to the I/Os compensation cell when the CS1 bit of the SYSCFG_CCCSR is reset.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SYSCFG_CCCR</name>
          <displayName>SYSCFG_CCCR</displayName>
          <description>SYSCFG compensation cell code register</description>
          <addressOffset>0x024</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000078</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NCC1</name>
              <description>NMOS compensation code of the I/Os supplied by VsubDD/sub
These bits are written by software to define an I/Os compensation cell code for NMOS transistors. This code is applied to the I/Os compensation cell when the CS1 bit of the SYSCFG_CCCSR is set.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PCC1</name>
              <description>PMOS compensation code of the I/Os supplied by VsubDD/sub
These bits are written by software to define an I/Os compensation cell code for PMOS transistors. This code is applied to the I/Os compensation cell when the CS1 bit of the SYSCFG_CCCSR is set.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SYSCFG_RSSCMDR</name>
          <displayName>SYSCFG_RSSCMDR</displayName>
          <description>SYSCFG RSS command register</description>
          <addressOffset>0x02C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RSSCMD</name>
              <description>RSS commands
This field defines a command to be executed by the RSS.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>TAMP</name>
      <description>Tamper and backup registers</description>
      <groupName>TAMP</groupName>
      <baseAddress>0x46007C00</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x400</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>TAMP</name>
        <description>Tamper global interrupts</description>
        <value>4</value>
      </interrupt>
      <registers>
        <register>
          <name>TAMP_CR1</name>
          <displayName>TAMP_CR1</displayName>
          <description>TAMP control register 1</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TAMP1E</name>
              <description>Tamper detection on TAMP_IN1 enable</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Tamper detection on TAMP_IN1 is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Tamper detection on TAMP_IN1 is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAMP2E</name>
              <description>Tamper detection on TAMP_IN2 enable</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Tamper detection on TAMP_IN2 is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Tamper detection on TAMP_IN2 is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAMP3E</name>
              <description>Tamper detection on TAMP_IN3 enable</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Tamper detection on TAMP_IN3 is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Tamper detection on TAMP_IN3 is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAMP4E</name>
              <description>Tamper detection on TAMP_IN4 enable</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Tamper detection on TAMP_IN4 is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Tamper detection on TAMP_IN4 is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAMP5E</name>
              <description>Tamper detection on TAMP_IN5 enable</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Tamper detection on TAMP_IN5 is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Tamper detection on TAMP_IN5 is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAMP6E</name>
              <description>Tamper detection on TAMP_IN6 enable</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Tamper detection on TAMP_IN6 is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Tamper detection on TAMP_IN6 is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ITAMP3E</name>
              <description>Internal tamper 3 enable</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Internal tamper 3 disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Internal tamper 3 enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ITAMP5E</name>
              <description>Internal tamper 5 enable</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Internal tamper 5 disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Internal tamper 5 enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ITAMP6E</name>
              <description>Internal tamper 6 enable</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Internal tamper 6 disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Internal tamper 6 enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ITAMP7E</name>
              <description>Internal tamper 7 enable</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Internal tamper 7 disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Internal tamper 7 enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ITAMP8E</name>
              <description>Internal tamper 8 enable</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Internal tamper 8 disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Internal tamper 8 enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ITAMP9E</name>
              <description>Internal tamper 9 enable</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Internal tamper 9 disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Internal tamper 9 enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ITAMP11E</name>
              <description>Internal tamper 11 enable</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Internal tamper 11 disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Internal tamper 11 enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ITAMP12E</name>
              <description>Internal tamper 12 enable</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Internal tamper 12 disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Internal tamper 12 enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ITAMP13E</name>
              <description>Internal tamper 13 enable</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Internal tamper 13 disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Internal tamper 13 enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>TAMP_CR2</name>
          <displayName>TAMP_CR2</displayName>
          <description>TAMP control register 2</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TAMP1NOER</name>
              <description>Tamper 1 no erase</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Tamper 1 event erases the backup registers and all device secrets.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Tamper 1 event does not erase the backup registers and device secrets.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAMP2NOER</name>
              <description>Tamper 2 no erase</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Tamper 2 event erases the backup registers and all device secretssup(1)/sup.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Tamper 2 event does not erase the backup registers and device secretssup(2)/sup.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAMP3NOER</name>
              <description>Tamper 3 no erase</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Tamper 3 event erases the backup registers and all device secretssup(1)/sup.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Tamper 3 event does not erase the backup registers and device secretssup(2)/sup.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAMP4NOER</name>
              <description>Tamper 4 no erase</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Tamper 4 event erases the backup registers and all device secretssup(1)/sup.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Tamper 4 event does not erase the backup registers and device secretssup(2)/sup.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAMP5NOER</name>
              <description>Tamper 5 no erase</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Tamper 5 event erases the backup registers and all device secretssup(1)/sup.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Tamper 5 event does not erase the backup registers and device secretssup(2)/sup.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAMP6NOER</name>
              <description>Tamper 6 no erase</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Tamper 6 event erases the backup registers and all device secretssup(1)/sup.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Tamper 6 event does not erase the backup registers and device secretssup(2)/sup.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAMP1MSK</name>
              <description>Tamper 1 mask
The tamper 1 interrupt must not be enabled when TAMP1MSK is set.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Tamper 1 event generates a trigger event and TAMP1F must be cleared by software to allow next tamper event detection.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Tamper 1 event generates a trigger event. TAMP1F is masked and internally cleared by hardware. The backup registers and device secretssup(1)/sup are not erased.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAMP2MSK</name>
              <description>Tamper 2 mask
The tamper 2 interrupt must not be enabled when TAMP2MSK is set.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Tamper 2 event generates a trigger event and TAMP2F must be cleared by software to allow next tamper event detection.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Tamper 2 event generates a trigger event. TAMP2F is masked and internally cleared by hardware. The backup registers and device secretssup(1)/sup are not erased.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAMP3MSK</name>
              <description>Tamper 3 mask
The tamper 3 interrupt must not be enabled when TAMP3MSK is set.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Tamper 3 event generates a trigger event and TAMP3F must be cleared by software to allow next tamper event detection.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Tamper 3 event generates a trigger event. TAMP3F is masked and internally cleared by hardware. The backup registers and device secretssup(1)/sup are not erased.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BKBLOCK</name>
              <description>Backup registers and device secretssup(1)/sup access blocked</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>backup registers and device secretssup(1)/sup can be accessed if no tamper flag is set</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>backup registers and device secretssup(1)/sup cannot be accessed</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BKERASE</name>
              <description>Backup registers and device secretssup(1)/sup erase
Writing '1' to this bit reset the backup registers and device secretssup(1)/sup. Writing 0 has no effect. This bit is always read as 0.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>TAMP1TRG</name>
              <description>Active level for tamper 1 input
If TAMPFLT=00 Tamper 1 input rising edge triggers a tamper detection event.
If TAMPFLT=00 Tamper 1 input falling edge triggers a tamper detection event.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>If TAMPFLT different 00 Tamper 1 input staying low triggers a tamper detection event.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>If TAMPFLT different 00 Tamper 1 input staying high triggers a tamper detection event.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAMP2TRG</name>
              <description>Active level for tamper 2 input
If TAMPFLT = 00 Tamper 2 input rising edge triggers a tamper detection event.
If TAMPFLT=00 Tamper 2 input falling edge triggers a tamper detection event.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>If TAMPFLT different 00 Tamper 2 input staying low triggers a tamper detection event.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>If TAMPFLT different 00 Tamper 2 input staying high triggers a tamper detection event.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAMP3TRG</name>
              <description>Active level for tamper 3 input
If TAMPFLT=00 Tamper 3 input rising edge triggers a tamper detection event.
If TAMPFLT=00 Tamper 3 input falling edge triggers a tamper detection event.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>If TAMPFLT different 00 Tamper 3 input staying low triggers a tamper detection event.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>If TAMPFLT different 00 Tamper 3 input staying high triggers a tamper detection event.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAMP4TRG</name>
              <description>Active level for tamper 4 input (active mode disabled)
If TAMPFLT=00 Tamper 4 input rising edge triggers a tamper detection event.
If TAMPFLT=00 Tamper 4 input falling edge triggers a tamper detection event.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>If TAMPFLT different 00 Tamper 4 input staying low triggers a tamper detection event.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>If TAMPFLT different 00 Tamper 4 input staying high triggers a tamper detection event.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAMP5TRG</name>
              <description>Active level for tamper 5 input (active mode disabled)
If TAMPFLT=00 Tamper 5 input rising edge triggers a tamper detection event.
If TAMPFLT=00 Tamper 5 input falling edge triggers a tamper detection event.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>If TAMPFLT different 00 Tamper 5 input staying low triggers a tamper detection event.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>If TAMPFLT different 00 Tamper 5 input staying high triggers a tamper detection event.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAMP6TRG</name>
              <description>Active level for tamper 6 input (active mode disabled)
If TAMPFLT=00 Tamper 6 input rising edge triggers a tamper detection event.
If TAMPFLT=00 Tamper 6 input falling edge triggers a tamper detection event.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>If TAMPFLT different 00 Tamper 6 input staying low triggers a tamper detection event.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>If TAMPFLT different 00 Tamper 6 input staying high triggers a tamper detection event.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>TAMP_CR3</name>
          <displayName>TAMP_CR3</displayName>
          <description>TAMP control register 3</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ITAMP3NOER</name>
              <description>Internal Tamper 3 no erase</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Internal Tamper 3 event erases the backup registers and all device secretssup(1)/sup.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Internal Tamper 3 event does not erase the backup registers and device secretssup(2)/sup.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ITAMP5NOER</name>
              <description>Internal Tamper 5 no erase</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Internal Tamper 5 event erases the backup registers and all device secretssup(1)/sup.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Internal Tamper 5 event does not erase the backup registers and device secretssup(2)/sup.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ITAMP6NOER</name>
              <description>Internal Tamper 6 no erase</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Internal Tamper 6 event erases the backup registers and all device secretssup(1)/sup.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Internal Tamper 6 event does not erase the backup registers and device secretssup(2)/sup.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ITAMP7NOER</name>
              <description>Internal Tamper 7 no erase</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Internal Tamper 7 event erases the backup registers and all device secretssup(1)/sup.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Internal Tamper 7 event does not erase the backup registers and device secretssup(2)/sup.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ITAMP8NOER</name>
              <description>Internal Tamper 8 no erase</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Internal Tamper 8 event erases the backup registers and all device secretssup(1)/sup.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Internal Tamper 8 event does not erase the backup registers and device secretssup(2)/sup.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ITAMP9NOER</name>
              <description>Internal Tamper 9 no erase</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Internal Tamper 9 event erases the backup registers and all device secretssup(1)/sup.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Internal Tamper 9 event does not erase the backup registers and device secretssup(2)/sup.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ITAMP11NOER</name>
              <description>Internal Tamper 11 no erase</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Internal Tamper 11 event erases the backup registers and all device secretssup(1)/sup.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Internal Tamper 11 event does not erase the backup registers and device secretssup(2)/sup.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ITAMP12NOER</name>
              <description>Internal Tamper 12 no erase</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Internal Tamper 12 event erases the backup registers and all device secretssup(1)/sup.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Internal Tamper 12 event does not erase the backup registers and device secretssup(2)/sup.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ITAMP13NOER</name>
              <description>Internal Tamper 13 no erase</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Internal Tamper 13 event erases the backup registers and all device secretssup(1)/sup.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Internal Tamper 13 event does not erase the backup registers and device secretssup(2)/sup.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>TAMP_FLTCR</name>
          <displayName>TAMP_FLTCR</displayName>
          <description>TAMP filter control register</description>
          <addressOffset>0x0C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TAMPFREQ</name>
              <description>Tamper sampling frequency
Determines the frequency at which each of the TAMP_INx inputs are sampled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>RTCCLK / 32768 (1Hz when RTCCLK = 32768Hz)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>RTCCLK / 16384 (2Hz when RTCCLK = 32768Hz)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>RTCCLK / 8192 (4Hz when RTCCLK = 32768Hz)</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>RTCCLK / 4096 (8Hz when RTCCLK = 32768Hz)</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>RTCCLK / 2048 (16Hz when RTCCLK = 32768Hz)</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>RTCCLK / 1024 (32Hz when RTCCLK = 32768Hz)</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x6</name>
                  <description>RTCCLK / 512 (64Hz when RTCCLK = 32768Hz)</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7</name>
                  <description>RTCCLK / 256 (128Hz when RTCCLK = 32768Hz)</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAMPFLT</name>
              <description>TAMP_INx filter count
These bits determines the number of consecutive samples at the specified level (TAMP*TRG) needed to activate a tamper event. TAMPFLT is valid for each of the TAMP_INx inputs.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Tamper event is activated on edge of TAMP_INx input transitions to the active level (no internal pull-up on TAMP_INx input).</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Tamper event is activated after 2 consecutive samples at the active level.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>Tamper event is activated after 4 consecutive samples at the active level.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>Tamper event is activated after 8 consecutive samples at the active level.</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAMPPRCH</name>
              <description>TAMP_INx precharge duration
These bit determines the duration of time during which the pull-up/is activated before each sample. TAMPPRCH is valid for each of the TAMP_INx inputs.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>1 RTCCLK cycle</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>2 RTCCLK cycles</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>4 RTCCLK cycles</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>8 RTCCLK cycles</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAMPPUDIS</name>
              <description>TAMP_INx pull-up disable
This bit determines if each of the TAMPx pins are precharged before each sample.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Precharge TAMP_INx pins before sampling (enable internal pull-up)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Disable precharge of TAMP_INx pins.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>TAMP_ATCR1</name>
          <displayName>TAMP_ATCR1</displayName>
          <description>TAMP active tamper control register 1</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <resetValue>0x00070000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TAMP1AM</name>
              <description>Tamper 1 active mode</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Tamper 1 detection mode is passive.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Tamper 1 detection mode is active.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAMP2AM</name>
              <description>Tamper 2 active mode</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Tamper 2 detection mode is passive.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Tamper 2 detection mode is active.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAMP3AM</name>
              <description>Tamper 3 active mode</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Tamper 3 detection mode is passive.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Tamper 3 detection mode is active.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAMP4AM</name>
              <description>Tamper 4 active mode</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Tamper 4 detection mode is passive.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Tamper 4 detection mode is active.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAMP5AM</name>
              <description>Tamper 5 active mode</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Tamper 5 detection mode is passive.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Tamper 5 detection mode is active.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAMP6AM</name>
              <description>Tamper 6 active mode</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Tamper 6 detection mode is passive.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Tamper 6 detection mode is active.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ATOSEL1</name>
              <description>Active tamper shared output 1 selection
The selected output must be available in the package pinout</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>TAMPOUTSEL1 = TAMP_OUT1</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>TAMPOUTSEL1 = TAMP_OUT2</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>TAMPOUTSEL1 = TAMP_OUT3</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>TAMPOUTSEL1 = TAMP_OUT4</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ATOSEL2</name>
              <description>Active tamper shared output 2 selection
The selected output must be available in the package pinout</description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>TAMPOUTSEL2 = TAMP_OUT1</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>TAMPOUTSEL2 = TAMP_OUT2</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>TAMPOUTSEL2 = TAMP_OUT3</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>TAMPOUTSEL2 = TAMP_OUT4</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ATOSEL3</name>
              <description>Active tamper shared output 3 selection
The selected output must be available in the package pinout</description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>TAMPOUTSEL3 = TAMP_OUT1</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>TAMPOUTSEL3 = TAMP_OUT2</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>TAMPOUTSEL3 = TAMP_OUT3</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>TAMPOUTSEL3 = TAMP_OUT4</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ATOSEL4</name>
              <description>Active tamper shared output 4 selection
The selected output must be available in the package pinout.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>TAMPOUTSEL4 = TAMP_OUT1</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>TAMPOUTSEL4 = TAMP_OUT2</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>TAMPOUTSEL4 = TAMP_OUT3</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>TAMPOUTSEL4 = TAMP_OUT4</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ATCKSEL</name>
              <description>Active tamper RTC asynchronous prescaler clock selection
These bits selects the RTC asynchronous prescaler stage output. The selected clock is CK_ATPRE. 
...
Note: These bits can be written only when all active tampers are disabled. The write protection remains for up to 1.5 CK_ATPRE cycles after all the active tampers are disable.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>RTCCLK is selected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>RTCCLK/2 is selected</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>RTCCLK/4 is selected</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7</name>
                  <description>RTCCLK/128 is selected</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ATPER</name>
              <description>Active tamper output change period
The tamper output is changed every CK_ATPER = (2supATPER /supx CK_ATPRE) cycles. Refer to Table713: Minimum ATPER value.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ATOSHARE</name>
              <description>Active tamper output sharing
TAMP_IN1 is compared with TAMPOUTSEL1
TAMP_IN2 is compared with TAMPOUTSEL2
TAMP_IN3 is compared with TAMPOUTSEL3
TAMP_IN4 is compared with TAMPOUTSEL4
TAMP_IN5 is compared with TAMPOUTSEL5
TAMP_IN6 is compared with TAMPOUTSEL6</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Each active tamper input TAMP_INi is compared with its dedicated output TAMP_OUTi</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Each active tamper input TAMP_INi is compared with TAMPOUTSELx as defined below, with TAMPOUTSELx defined by ATOSELx bits.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FLTEN</name>
              <description>Active tamper filter enable</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Active tamper filtering disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Active tamper filtering enable: a tamper event is detected when 2 comparison mismatches occur out of 4 consecutive samples.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>TAMP_ATSEEDR</name>
          <displayName>TAMP_ATSEEDR</displayName>
          <description>TAMP active tamper seed register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SEED</name>
              <description>Pseudo-random generator seed value
This register must be written four times with 32-bit values to provide the 128-bit seed to the PRNG. Writing to this register automatically sends the seed value to the PRNG.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TAMP_ATOR</name>
          <displayName>TAMP_ATOR</displayName>
          <description>TAMP active tamper output register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRNG</name>
              <description>Pseudo-random generator value
This field provides the values of the PRNG output. Because of potential inconsistencies due to synchronization delays, PRNG must be read at least twice. The read value is correct if it is equal to previous read value.
This field can only be read when the APB is in secure mode.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SEEDF</name>
              <description>Seed running flag 
This flag is set by hardware when a new seed is written in the TAMP_ATSEEDR. It is cleared by hardware when the PRNG has absorbed this new seed, and by system reset. The TAMP APB cock must not be switched off as long as SEEDF is set.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>INITS</name>
              <description>Active tamper initialization status
This flag is set by hardware when the PRNG has absorbed the first 128-bit seed, meaning that the enabled active tampers are functional. This flag is cleared when the active tampers are disabled.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TAMP_ATCR2</name>
          <displayName>TAMP_ATCR2</displayName>
          <description>TAMP active tamper control register 2</description>
          <addressOffset>0x1C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ATOSEL1</name>
              <description>Active tamper shared output 1 selection
The selected output must be available in the package pinout.
Bits 9:8 are the mirror of ATOSEL1[1:0] in the TAMP_ATCR1, and so can also be read or
written through TAMP_ATCR1.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>TAMPOUTSEL1 = TAMP_OUT1</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>TAMPOUTSEL1 = TAMP_OUT2</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>TAMPOUTSEL1 = TAMP_OUT3</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>TAMPOUTSEL1 = TAMP_OUT4</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>TAMPOUTSEL1 = TAMP_OUT5</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>TAMPOUTSEL1 = TAMP_OUT6</description>
                  <value>0x5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ATOSEL2</name>
              <description>Active tamper shared output 2 selection
The selected output must be available in the package pinout.
Bits 12:11 are the mirror of ATOSEL2[1:0] in the TAMP_ATCR1, and so can also be read or written through TAMP_ATCR1.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>TAMPOUTSEL2 = TAMP_OUT1</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>TAMPOUTSEL2 = TAMP_OUT2</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>TAMPOUTSEL2 = TAMP_OUT3</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>TAMPOUTSEL2 = TAMP_OUT4</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>TAMPOUTSEL2 = TAMP_OUT5</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>TAMPOUTSEL2 = TAMP_OUT6</description>
                  <value>0x5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ATOSEL3</name>
              <description>Active tamper shared output 3 selection
The selected output must be available in the package pinout.
Bits 15:14 are the mirror of ATOSEL3[1:0] in the TAMP_ATCR1, and so can also be read or written through TAMP_ATCR1.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>TAMPOUTSEL3 = TAMP_OUT1</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>TAMPOUTSEL3 = TAMP_OUT2</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>TAMPOUTSEL3 = TAMP_OUT3</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>TAMPOUTSEL3 = TAMP_OUT4</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>TAMPOUTSEL3 = TAMP_OUT5</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>TAMPOUTSEL3 = TAMP_OUT6</description>
                  <value>0x5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ATOSEL4</name>
              <description>Active tamper shared output 4 selection
The selected output must be available in the package pinout.
Bits 18:17 are the mirror of ATOSEL2[1:0] in the TAMP_ATCR1, and so can also be read or written through TAMP_ATCR1.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>TAMPOUTSEL4 = TAMP_OUT1</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>TAMPOUTSEL4 = TAMP_OUT2</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>TAMPOUTSEL4 = TAMP_OUT3</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>TAMPOUTSEL4 = TAMP_OUT4</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>TAMPOUTSEL4 = TAMP_OUT5</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>TAMPOUTSEL4 = TAMP_OUT6</description>
                  <value>0x5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ATOSEL5</name>
              <description>Active tamper shared output 5 selection
The selected output must be available in the package pinout.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>TAMPOUTSEL5 = TAMP_OUT1</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>TAMPOUTSEL5 = TAMP_OUT2</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>TAMPOUTSEL5 = TAMP_OUT3</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>TAMPOUTSEL5 = TAMP_OUT4</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>TAMPOUTSEL5 = TAMP_OUT5</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>TAMPOUTSEL5 = TAMP_OUT6</description>
                  <value>0x5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ATOSEL6</name>
              <description>Active tamper shared output 6 selection
The selected output must be available in the package pinout.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>TAMPOUTSEL6 = TAMP_OUT1</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>TAMPOUTSEL6 = TAMP_OUT2</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>TAMPOUTSEL6 = TAMP_OUT3</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>TAMPOUTSEL6 = TAMP_OUT4</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>TAMPOUTSEL6 = TAMP_OUT5</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>TAMPOUTSEL6 = TAMP_OUT6</description>
                  <value>0x5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>TAMP_SECCFGR</name>
          <displayName>TAMP_SECCFGR</displayName>
          <description>TAMP secure configuration register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BKPRWSEC</name>
              <description>Backup registers read/write protection offset
BKPRWSEC value must be from 0 to 32.
Protection zone 1 is defined for backup registers from TAMP_BKP0R to TAMP_BKPxR (x = BKPRWSEC-1, with BKPRWSEC greater than or equal 1).
if TZEN=1, these backup registers can be read and written only with secure access.
If BKPRWSEC = 0: there is no protection zone 1.
Refer to Figure871: Backup registers protection zones.
Note: If TZEN=0: the protection zone 1 can be read and written with non-secure access.
Note: If BKPRWPRIV is set, BKPRWSEC[7:0] can be written only in privileged mode.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CNT1SEC</name>
              <description>Monotonic counter 1 secure protection</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Monotonic counter 1 (TAMP_COUNT1R) can be read and written when the APB access is secure or non-secure.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Monotonic counter 1 (TAMP_COUNT1R) can be read and written only when the APB access is secure.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BKPWSEC</name>
              <description>Backup registers write protection offset
BKPWSEC value must be from 0 to 32.
Protection zone 2 is defined for backup registers from TAMP_BKPyR (y = BKPRWSEC) to TAMP_BKPzR (z = BKPWSEC-1, with BKPWSECBKPRWSEC): 
if TZEN=1, these backup registers can be written only with secure access.
They can be read with secure or non-secure access.
If BKPWSEC = 0 or if BKPWSEC less than or equal BKPRWSEC: there is no protection zone 2.
Protection zone 3 is defined for backup registers from TAMP_BKPtR (t = BKPWSEC if BKPWSEC greater than or equal BKPRWSEC, else t = BKPRWSEC).
They can be read or written with secure or non-secure access.
If BKPWSEC=32: there is no protection zone 3.
Refer to Figure871: Backup registers protection zones.
Note: If TZEN=0: the protection zone 2 can be read and written with non-secure access.
Note: If BKPWPRIV is set, BKPRWSEC[7:0] can be written only in privileged mode.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BHKLOCK</name>
              <description>Boot hardware key lock
This bit can be read and can only be written to 1 by software. It is cleared by hardware together with the backup registers following a tamper detection event or when the readout protection (RDP) is disabled.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>The Backup registers from TAMP_BKP0R to TAMP_BKP7R can be accessed according to the Protection zone they belong to.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The backup registers from TAMP_BKP0R to TAMP_BKP7R cannot be accessed neither in read nor in write (they are read as 0 and write ignore).</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAMPSEC</name>
              <description>Tamper protection (excluding monotonic counters and backup registers)
Note: Refer to Section75.3.5: TAMP secure protection modes for details on the read protection.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Tamper configuration and interrupt can be written when the APB access is secure or non-secure.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Tamper configuration and interrupt can be written only when the APB access is secure.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>TAMP_PRIVCFGR</name>
          <displayName>TAMP_PRIVCFGR</displayName>
          <description>TAMP privilege configuration register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNT1PRIV</name>
              <description>Monotonic counter 1 privilege protection</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Monotonic counter 1 (TAMP_COUNT1R) can be read and written when the APB access is privileged or non-privileged.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Monotonic counter 1 (TAMP_COUNT1R) can be read and written only when the APB access is privileged.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BKPRWPRIV</name>
              <description>Backup registers zone 1 privilege protection</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Backup registers zone 1 can be read and written with privileged or unprivileged access.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Backup registers zone 1 can be read and written only with privileged access</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BKPWPRIV</name>
              <description>Backup registers zone 2 privilege protection</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Backup registers zone 2 can be written with privileged or unprivileged access.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Backup registers zone 2 can be written only with privileged access.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAMPPRIV</name>
              <description>Tamper privilege protection (excluding backup registers)
Note: Refer to Section75.3.7: TAMP privilege protection modes for details on the read protection.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Tamper configuration and interrupt can be written with privileged or unprivileged access.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Tamper configuration and interrupt can be written only with privileged access.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>TAMP_IER</name>
          <displayName>TAMP_IER</displayName>
          <description>TAMP interrupt enable register</description>
          <addressOffset>0x2C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TAMP1IE</name>
              <description>Tamper 1 interrupt enable</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Tamper 1 interrupt disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Tamper 1 interrupt enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAMP2IE</name>
              <description>Tamper 2 interrupt enable</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Tamper 2 interrupt disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Tamper 2 interrupt enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAMP3IE</name>
              <description>Tamper 3 interrupt enable</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Tamper 3 interrupt disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Tamper 3 interrupt enabled..</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAMP4IE</name>
              <description>Tamper 4 interrupt enable</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Tamper 4 interrupt disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Tamper 4 interrupt enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAMP5IE</name>
              <description>Tamper 5 interrupt enable</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Tamper 5 interrupt disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Tamper 5 interrupt enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAMP6IE</name>
              <description>Tamper 6 interrupt enable</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Tamper 6 interrupt disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Tamper 6 interrupt enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ITAMP3IE</name>
              <description>Internal tamper 3 interrupt enable</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Internal tamper 3 interrupt disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Internal tamper 3 interrupt enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ITAMP5IE</name>
              <description>Internal tamper 5 interrupt enable</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Internal tamper 5 interrupt disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Internal tamper 5 interrupt enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ITAMP6IE</name>
              <description>Internal tamper 6 interrupt enable</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Internal tamper 6 interrupt disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Internal tamper 6 interrupt enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ITAMP7IE</name>
              <description>Internal tamper 7 interrupt enable</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Internal tamper 7 interrupt disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Internal tamper 7 interrupt enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ITAMP8IE</name>
              <description>Internal tamper 8 interrupt enable</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Internal tamper 8 interrupt disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Internal tamper 8 interrupt enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ITAMP9IE</name>
              <description>Internal tamper 9 interrupt enable</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Internal tamper 9 interrupt disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Internal tamper 9 interrupt enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ITAMP11IE</name>
              <description>Internal tamper 11 interrupt enable</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Internal tamper 11 interrupt disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Internal tamper 11 interrupt enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ITAMP12IE</name>
              <description>Internal tamper 12 interrupt enable</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Internal tamper 12 interrupt disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Internal tamper 12 interrupt enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ITAMP13IE</name>
              <description>Internal tamper 13 interrupt enable</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Internal tamper 13 interrupt disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Internal tamper 13 interrupt enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>TAMP_SR</name>
          <displayName>TAMP_SR</displayName>
          <description>TAMP status register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TAMP1F</name>
              <description>TAMP1 detection flag
This flag is set by hardware when a tamper detection event is detected on the TAMP1 input.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TAMP2F</name>
              <description>TAMP2 detection flag
This flag is set by hardware when a tamper detection event is detected on the TAMP2 input.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TAMP3F</name>
              <description>TAMP3 detection flag
This flag is set by hardware when a tamper detection event is detected on the TAMP3 input.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TAMP4F</name>
              <description>TAMP4 detection flag
This flag is set by hardware when a tamper detection event is detected on the TAMP4 input.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TAMP5F</name>
              <description>TAMP5 detection flag
This flag is set by hardware when a tamper detection event is detected on the TAMP5 input.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TAMP6F</name>
              <description>TAMP6 detection flag
This flag is set by hardware when a tamper detection event is detected on the TAMP6 input.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ITAMP3F</name>
              <description>Internal tamper 3 flag
This flag is set by hardware when a tamper detection event is detected on the internal tamper 3.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ITAMP5F</name>
              <description>Internal tamper 5 flag
This flag is set by hardware when a tamper detection event is detected on the internal tamper 5.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ITAMP6F</name>
              <description>Internal tamper 6 flag
This flag is set by hardware when a tamper detection event is detected on the internal tamper 6.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ITAMP7F</name>
              <description>Internal tamper 7 flag
This flag is set by hardware when a tamper detection event is detected on the internal tamper 7.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ITAMP8F</name>
              <description>Internal tamper 8 flag
This flag is set by hardware when a tamper detection event is detected on the internal tamper 8.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ITAMP9F</name>
              <description>Internal tamper 9 flag 
This flag is set by hardware when a tamper detection event is detected on the internal tamper 9.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ITAMP11F</name>
              <description>Internal tamper 11 flag 
This flag is set by hardware when a tamper detection event is detected on the internal tamper 11.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ITAMP12F</name>
              <description>Internal tamper 12 flag 
This flag is set by hardware when a tamper detection event is detected on the internal tamper 12.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ITAMP13F</name>
              <description>Internal tamper 13 flag 
This flag is set by hardware when a tamper detection event is detected on the internal tamper 13.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TAMP_MISR</name>
          <displayName>TAMP_MISR</displayName>
          <description>TAMP non-secure masked interrupt status register</description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TAMP1MF</name>
              <description>TAMP1 non-secure interrupt masked flag
This flag is set by hardware when the tamper 1 non-secure interrupt is raised.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TAMP2MF</name>
              <description>TAMP2 non-secure interrupt masked flag
This flag is set by hardware when the tamper 2 non-secure interrupt is raised.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TAMP3MF</name>
              <description>TAMP3 non-secure interrupt masked flag
This flag is set by hardware when the tamper 3 non-secure interrupt is raised.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TAMP4MF</name>
              <description>TAMP4 non-secure interrupt masked flag
This flag is set by hardware when the tamper 4 non-secure interrupt is raised.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TAMP5MF</name>
              <description>TAMP5 non-secure interrupt masked flag
This flag is set by hardware when the tamper 5 non-secure interrupt is raised.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TAMP6MF</name>
              <description>TAMP6 non-secure interrupt masked flag
This flag is set by hardware when the tamper 6 non-secure interrupt is raised.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ITAMP3MF</name>
              <description>Internal tamper 3 non-secure interrupt masked flag
This flag is set by hardware when the internal tamper 3 non-secure interrupt is raised.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ITAMP5MF</name>
              <description>Internal tamper 5 non-secure interrupt masked flag
This flag is set by hardware when the internal tamper 5 non-secure interrupt is raised.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ITAMP6MF</name>
              <description>Internal tamper 6 non-secure interrupt masked flag
This flag is set by hardware when the internal tamper 6 non-secure interrupt is raised.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ITAMP7MF</name>
              <description>Internal tamper 7 tamper non-secure interrupt masked flag
This flag is set by hardware when the internal tamper 7 non-secure interrupt is raised.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ITAMP8MF</name>
              <description>Internal tamper 8 non-secure interrupt masked flag
This flag is set by hardware when the internal tamper 8 non-secure interrupt is raised.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ITAMP9MF</name>
              <description>internal tamper 9 non-secure interrupt masked flag
This flag is set by hardware when the internal tamper 9 non-secure interrupt is raised.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ITAMP11MF</name>
              <description>internal tamper 11 non-secure interrupt masked flag
This flag is set by hardware when the internal tamper 11 non-secure interrupt is raised.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ITAMP12MF</name>
              <description>internal tamper 12 non-secure interrupt masked flag
This flag is set by hardware when the internal tamper 12 non-secure interrupt is raised.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ITAMP13MF</name>
              <description>internal tamper 13 non-secure interrupt masked flag
This flag is set by hardware when the internal tamper 13 non-secure interrupt is raised.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TAMP_SMISR</name>
          <displayName>TAMP_SMISR</displayName>
          <description>TAMP secure masked interrupt status register</description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TAMP1MF</name>
              <description>TAMP1 secure interrupt masked flag
This flag is set by hardware when the tamper 1 secure interrupt is raised.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TAMP2MF</name>
              <description>TAMP2 secure interrupt masked flag
This flag is set by hardware when the tamper 2 secure interrupt is raised.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TAMP3MF</name>
              <description>TAMP3 secure interrupt masked flag
This flag is set by hardware when the tamper 3 secure interrupt is raised.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TAMP4MF</name>
              <description>TAMP4 secure interrupt masked flag
This flag is set by hardware when the tamper 4 secure interrupt is raised.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TAMP5MF</name>
              <description>TAMP5 secure interrupt masked flag
This flag is set by hardware when the tamper 5 secure interrupt is raised.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TAMP6MF</name>
              <description>TAMP6 secure interrupt masked flag
This flag is set by hardware when the tamper 6 secure interrupt is raised.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ITAMP3MF</name>
              <description>Internal tamper 3 secure interrupt masked flag
This flag is set by hardware when the internal tamper 3 secure interrupt is raised.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ITAMP5MF</name>
              <description>Internal tamper 5 secure interrupt masked flag
This flag is set by hardware when the internal tamper 5 secure interrupt is raised.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ITAMP6MF</name>
              <description>Internal tamper 6 secure interrupt masked flag
This flag is set by hardware when the internal tamper 6 secure interrupt is raised.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ITAMP7MF</name>
              <description>Internal tamper 7 secure interrupt masked flag
This flag is set by hardware when the internal tamper 7 secure interrupt is raised.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ITAMP8MF</name>
              <description>Internal tamper 8 secure interrupt masked flag
This flag is set by hardware when the internal tamper 8 secure interrupt is raised.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ITAMP9MF</name>
              <description>internal tamper 9 secure interrupt masked flag
This flag is set by hardware when the internal tamper 9 secure interrupt is raised.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ITAMP11MF</name>
              <description>internal tamper 11 secure interrupt masked flag
This flag is set by hardware when the internal tamper 11 secure interrupt is raised.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ITAMP12MF</name>
              <description>internal tamper 12 secure interrupt masked flag
This flag is set by hardware when the internal tamper 12 secure interrupt is raised.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ITAMP13MF</name>
              <description>internal tamper 13 secure interrupt masked flag
This flag is set by hardware when the internal tamper 13 secure interrupt is raised.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TAMP_SCR</name>
          <displayName>TAMP_SCR</displayName>
          <description>TAMP status clear register</description>
          <addressOffset>0x3C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CTAMP1F</name>
              <description>Clear TAMP1 detection flag
Writing 1 in this bit clears the TAMP1F bit in the TAMP_SR register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CTAMP2F</name>
              <description>Clear TAMP2 detection flag
Writing 1 in this bit clears the TAMP2F bit in the TAMP_SR register.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CTAMP3F</name>
              <description>Clear TAMP3 detection flag
Writing 1 in this bit clears the TAMP3F bit in the TAMP_SR register.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CTAMP4F</name>
              <description>Clear TAMP4 detection flag
Writing 1 in this bit clears the TAMP4F bit in the TAMP_SR register.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CTAMP5F</name>
              <description>Clear TAMP5 detection flag
Writing 1 in this bit clears the TAMP5F bit in the TAMP_SR register.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CTAMP6F</name>
              <description>Clear TAMP6 detection flag
Writing 1 in this bit clears the TAMP6F bit in the TAMP_SR register.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CITAMP3F</name>
              <description>Clear ITAMP3 detection flag
Writing 1 in this bit clears the ITAMP3F bit in the TAMP_SR register.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CITAMP5F</name>
              <description>Clear ITAMP5 detection flag
Writing 1 in this bit clears the ITAMP5F bit in the TAMP_SR register.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CITAMP6F</name>
              <description>Clear ITAMP6 detection flag
Writing 1 in this bit clears the ITAMP6F bit in the TAMP_SR register.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CITAMP7F</name>
              <description>Clear ITAMP7 detection flag
Writing 1 in this bit clears the ITAMP7F bit in the TAMP_SR register.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CITAMP8F</name>
              <description>Clear ITAMP8 detection flag
Writing 1 in this bit clears the ITAMP8F bit in the TAMP_SR register.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CITAMP9F</name>
              <description>Clear ITAMP9 detection flag
Writing 1 in this bit clears the ITAMP9F bit in the TAMP_SR register.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CITAMP11F</name>
              <description>Clear ITAMP11 detection flag
Writing 1 in this bit clears the ITAMP11F bit in the TAMP_SR register.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CITAMP12F</name>
              <description>Clear ITAMP12 detection flag
Writing 1 in this bit clears the ITAMP12F bit in the TAMP_SR register.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CITAMP13F</name>
              <description>Clear ITAMP13 detection flag
Writing 1 in this bit clears the ITAMP13F bit in the TAMP_SR register.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TAMP_COUNT1R</name>
          <displayName>TAMP_COUNT1R</displayName>
          <description>TAMP monotonic counter 1 register</description>
          <addressOffset>0x040</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNT</name>
              <description>This register is read-only only and is incremented by one when a write access is done to this register. This register cannot roll-over and is frozen when reaching the maximum value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TAMP_ERCFGR</name>
          <displayName>TAMP_ERCFGR</displayName>
          <description>TAMP erase configuration register</description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ERCFG1</name>
              <description>Configurable device secrets configuration</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Configurable device secrets are not included in the device secrets protected by TAMP peripheral</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Configurable device secrets are is included in the device secrets protected by TAMP peripheral</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ERCFG2</name>
              <description>Configurable device secrets configuration</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Configurable device secrets are not included in the device secrets protected by TAMP peripheral</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Configurable device secrets are is included in the device secrets protected by TAMP peripheral</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ERCFG3</name>
              <description>Configurable device secrets configuration</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Configurable device secrets are not included in the device secrets protected by TAMP peripheral</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Configurable device secrets are is included in the device secrets protected by TAMP peripheral</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ERCFG4</name>
              <description>Configurable device secrets configuration</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Configurable device secrets are not included in the device secrets protected by TAMP peripheral</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Configurable device secrets are is included in the device secrets protected by TAMP peripheral</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ERCFG5</name>
              <description>Configurable device secrets configuration</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Configurable device secrets are not included in the device secrets protected by TAMP peripheral</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Configurable device secrets are is included in the device secrets protected by TAMP peripheral</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>TAMP_BKP0R</name>
          <displayName>TAMP_BKP0R</displayName>
          <description>TAMP backup 0 register</description>
          <addressOffset>0x100</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BKP</name>
              <description>The application can write or read data to and from these registers.
In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TAMP_BKP1R</name>
          <displayName>TAMP_BKP1R</displayName>
          <description>TAMP backup 1 register</description>
          <addressOffset>0x104</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BKP</name>
              <description>The application can write or read data to and from these registers.
In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TAMP_BKP2R</name>
          <displayName>TAMP_BKP2R</displayName>
          <description>TAMP backup 2 register</description>
          <addressOffset>0x108</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BKP</name>
              <description>The application can write or read data to and from these registers.
In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TAMP_BKP3R</name>
          <displayName>TAMP_BKP3R</displayName>
          <description>TAMP backup 3 register</description>
          <addressOffset>0x10C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BKP</name>
              <description>The application can write or read data to and from these registers.
In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TAMP_BKP4R</name>
          <displayName>TAMP_BKP4R</displayName>
          <description>TAMP backup 4 register</description>
          <addressOffset>0x110</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BKP</name>
              <description>The application can write or read data to and from these registers.
In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TAMP_BKP5R</name>
          <displayName>TAMP_BKP5R</displayName>
          <description>TAMP backup 5 register</description>
          <addressOffset>0x114</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BKP</name>
              <description>The application can write or read data to and from these registers.
In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TAMP_BKP6R</name>
          <displayName>TAMP_BKP6R</displayName>
          <description>TAMP backup 6 register</description>
          <addressOffset>0x118</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BKP</name>
              <description>The application can write or read data to and from these registers.
In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TAMP_BKP7R</name>
          <displayName>TAMP_BKP7R</displayName>
          <description>TAMP backup 7 register</description>
          <addressOffset>0x11C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BKP</name>
              <description>The application can write or read data to and from these registers.
In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TAMP_BKP8R</name>
          <displayName>TAMP_BKP8R</displayName>
          <description>TAMP backup 8 register</description>
          <addressOffset>0x120</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BKP</name>
              <description>The application can write or read data to and from these registers.
In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TAMP_BKP9R</name>
          <displayName>TAMP_BKP9R</displayName>
          <description>TAMP backup 9 register</description>
          <addressOffset>0x124</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BKP</name>
              <description>The application can write or read data to and from these registers.
In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TAMP_BKP10R</name>
          <displayName>TAMP_BKP10R</displayName>
          <description>TAMP backup 10 register</description>
          <addressOffset>0x128</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BKP</name>
              <description>The application can write or read data to and from these registers.
In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TAMP_BKP11R</name>
          <displayName>TAMP_BKP11R</displayName>
          <description>TAMP backup 11 register</description>
          <addressOffset>0x12C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BKP</name>
              <description>The application can write or read data to and from these registers.
In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TAMP_BKP12R</name>
          <displayName>TAMP_BKP12R</displayName>
          <description>TAMP backup 12 register</description>
          <addressOffset>0x130</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BKP</name>
              <description>The application can write or read data to and from these registers.
In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TAMP_BKP13R</name>
          <displayName>TAMP_BKP13R</displayName>
          <description>TAMP backup 13 register</description>
          <addressOffset>0x134</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BKP</name>
              <description>The application can write or read data to and from these registers.
In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TAMP_BKP14R</name>
          <displayName>TAMP_BKP14R</displayName>
          <description>TAMP backup 14 register</description>
          <addressOffset>0x138</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BKP</name>
              <description>The application can write or read data to and from these registers.
In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TAMP_BKP15R</name>
          <displayName>TAMP_BKP15R</displayName>
          <description>TAMP backup 15 register</description>
          <addressOffset>0x13C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BKP</name>
              <description>The application can write or read data to and from these registers.
In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TAMP_BKP16R</name>
          <displayName>TAMP_BKP16R</displayName>
          <description>TAMP backup 16 register</description>
          <addressOffset>0x140</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BKP</name>
              <description>The application can write or read data to and from these registers.
In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TAMP_BKP17R</name>
          <displayName>TAMP_BKP17R</displayName>
          <description>TAMP backup 17 register</description>
          <addressOffset>0x144</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BKP</name>
              <description>The application can write or read data to and from these registers.
In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TAMP_BKP18R</name>
          <displayName>TAMP_BKP18R</displayName>
          <description>TAMP backup 18 register</description>
          <addressOffset>0x148</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BKP</name>
              <description>The application can write or read data to and from these registers.
In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TAMP_BKP19R</name>
          <displayName>TAMP_BKP19R</displayName>
          <description>TAMP backup 19 register</description>
          <addressOffset>0x14C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BKP</name>
              <description>The application can write or read data to and from these registers.
In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TAMP_BKP20R</name>
          <displayName>TAMP_BKP20R</displayName>
          <description>TAMP backup 20 register</description>
          <addressOffset>0x150</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BKP</name>
              <description>The application can write or read data to and from these registers.
In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TAMP_BKP21R</name>
          <displayName>TAMP_BKP21R</displayName>
          <description>TAMP backup 21 register</description>
          <addressOffset>0x154</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BKP</name>
              <description>The application can write or read data to and from these registers.
In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TAMP_BKP22R</name>
          <displayName>TAMP_BKP22R</displayName>
          <description>TAMP backup 22 register</description>
          <addressOffset>0x158</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BKP</name>
              <description>The application can write or read data to and from these registers.
In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TAMP_BKP23R</name>
          <displayName>TAMP_BKP23R</displayName>
          <description>TAMP backup 23 register</description>
          <addressOffset>0x15C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BKP</name>
              <description>The application can write or read data to and from these registers.
In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TAMP_BKP24R</name>
          <displayName>TAMP_BKP24R</displayName>
          <description>TAMP backup 24 register</description>
          <addressOffset>0x160</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BKP</name>
              <description>The application can write or read data to and from these registers.
In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TAMP_BKP25R</name>
          <displayName>TAMP_BKP25R</displayName>
          <description>TAMP backup 25 register</description>
          <addressOffset>0x164</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BKP</name>
              <description>The application can write or read data to and from these registers.
In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TAMP_BKP26R</name>
          <displayName>TAMP_BKP26R</displayName>
          <description>TAMP backup 26 register</description>
          <addressOffset>0x168</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BKP</name>
              <description>The application can write or read data to and from these registers.
In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TAMP_BKP27R</name>
          <displayName>TAMP_BKP27R</displayName>
          <description>TAMP backup 27 register</description>
          <addressOffset>0x16C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BKP</name>
              <description>The application can write or read data to and from these registers.
In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TAMP_BKP28R</name>
          <displayName>TAMP_BKP28R</displayName>
          <description>TAMP backup 28 register</description>
          <addressOffset>0x170</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BKP</name>
              <description>The application can write or read data to and from these registers.
In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TAMP_BKP29R</name>
          <displayName>TAMP_BKP29R</displayName>
          <description>TAMP backup 29 register</description>
          <addressOffset>0x174</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BKP</name>
              <description>The application can write or read data to and from these registers.
In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TAMP_BKP30R</name>
          <displayName>TAMP_BKP30R</displayName>
          <description>TAMP backup 30 register</description>
          <addressOffset>0x178</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BKP</name>
              <description>The application can write or read data to and from these registers.
In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TAMP_BKP31R</name>
          <displayName>TAMP_BKP31R</displayName>
          <description>TAMP backup 31 register</description>
          <addressOffset>0x17C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BKP</name>
              <description>The application can write or read data to and from these registers.
In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>TIM1</name>
      <description>TIM1 address block description</description>
      <groupName>TIM1</groupName>
      <baseAddress>0x40012C00</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x3E4</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>TIM1_BRK_TERR_IERR</name>
        <description>TIM1 Break - transition error -index error </description>
        <value>37</value>
      </interrupt>
      <interrupt>
        <name>TIM1_UP</name>
        <description>TIM1 Update</description>
        <value>38</value>
      </interrupt>
      <interrupt>
        <name>TIM1_TRG_COM_DIR_IDX</name>
        <description>TIM1 Trigger and Commutation - direction change interrupt -index </description>
        <value>39</value>
      </interrupt>
      <interrupt>
        <name>TIM1_CC</name>
        <description>TIM1 Capture Compare interrupt</description>
        <value>40</value>
      </interrupt>
      <registers>
        <register>
          <name>TIM1_CR1</name>
          <displayName>TIM1_CR1</displayName>
          <description>TIM1 control register 1</description>
          <addressOffset>0x000</addressOffset>
          <size>16</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>CEN</name>
              <description>Counter enable

Note: External clock, gated mode and encoder mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Counter disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Counter enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UDIS</name>
              <description>Update disable

This bit is set and cleared by software to enable/disable UEV event generation.

Counter overflow/underflow

Setting the UG bit

Update generation through the slave mode controller

Buffered registers are then loaded with their preload values.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>UEV enabled. The Update (UEV) event is generated by one of the following events:</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC, CCRx). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>URS</name>
              <description>Update request source

This bit is set and cleared by software to select the UEV event sources.

Counter overflow/underflow

Setting the UG bit

Update generation through the slave mode controller</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Any of the following events generate an update interrupt or DMA request if enabled. These events can be:</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Only counter overflow/underflow generates an update interrupt or DMA request if enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OPM</name>
              <description>One-pulse mode</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Counter is not stopped at update event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Counter stops counting at the next update event (clearing the bit CEN)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIR</name>
              <description>Direction

Note: This bit is read only when the timer is configured in Center-aligned mode or Encoder mode.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Counter used as upcounter</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Counter used as downcounter</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMS</name>
              <description>Center-aligned mode selection

Note: It is not allowed to switch from edge-aligned mode to center-aligned mode as long as the counter is enabled (CEN=1)</description>
              <bitOffset>5</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Edge-aligned mode. The counter counts up or down depending on the direction bit (DIR).</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Center-aligned mode 1. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set only when the counter is counting down.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>Center-aligned mode 2. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set only when the counter is counting up.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>Center-aligned mode 3. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set both when the counter is counting up or down.</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ARPE</name>
              <description>Auto-reload preload enable</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>TIMx_ARR register is not buffered</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>TIMx_ARR register is buffered</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CKD</name>
              <description>Clock division

This bit-field indicates the division ratio between the timer clock (tim_ker_ck) frequency and the dead-time and sampling clock (tsubDTS/sub)used by the dead-time generators and the digital filters (tim_etr_in, tim_tix),</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>tsubDTS/sub=tsubtim_ker_ck/sub</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tsubDTS/sub=2*tsubtim_ker_ck/sub</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>tsubDTS/sub=4*tsubtim_ker_ck/sub</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>Reserved, do not program this value</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UIFREMAP</name>
              <description>UIF status bit remapping</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No remapping. UIF status bit is not copied to TIMx_CNT register bit 31.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Remapping enabled. UIF status bit is copied to TIMx_CNT register bit 31.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DITHEN</name>
              <description>Dithering enable

Note: The DITHEN bit can only be modified when CEN bit is reset.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Dithering disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Dithering enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM1_CR2</name>
          <displayName>TIM1_CR2</displayName>
          <description>TIM1 control register 2</description>
          <addressOffset>0x004</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CCPC</name>
              <description>Capture/compare preloaded control

Note: This bit acts only on channels that have a complementary output.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>CCxE, CCxNE and OCxM bits are not preloaded</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>CCxE, CCxNE and OCxM bits are preloaded, after having been written, they are updated only when a commutation event (COM) occurs (COMG bit set or rising edge detected on tim_trgi, depending on the CCUS bit).</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CCUS</name>
              <description>Capture/compare control update selection

Note: This bit acts only on channels that have a complementary output.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>When capture/compare control bits are preloaded (CCPC=1), they are updated by setting the COMG bit only</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>When capture/compare control bits are preloaded (CCPC=1), they are updated by setting the COMG bit or when an rising edge occurs on tim_trgi</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CCDS</name>
              <description>Capture/compare DMA selection</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>CCx DMA request sent when CCx event occurs</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>CCx DMA requests sent when update event occurs</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MMS</name>
              <description>MMS[2:0]: Master mode selection

These bits select the information to be sent in master mode to slave timers for synchronization (tim_trgo). The combination is as follows: 

Other codes reserved

Note: The clock of the slave timer or ADC must be enabled prior to receive events from the master timer, and must not be changed on-the-fly while triggers are received from the master timer.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Reset - the UG bit from the TIMx_EGR register is used as trigger output (tim_trgo). If the reset is generated by the trigger input (slave mode controller configured in reset mode) then the signal on tim_trgo is delayed compared to the actual reset.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Enable - the Counter Enable signal CNT_EN is used as trigger output (tim_trgo). It is useful to start several timers at the same time or to control a window in which a slave timer is enable. The Counter Enable signal is generated by a logic AND between CEN control bit and the trigger input when configured in gated mode. When the Counter Enable signal is controlled by the trigger input, there is a delay on tim_trgo, except if the master/slave mode is selected (see the MSM bit description in TIMx_SMCR register).</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>Update - The update event is selected as trigger output (tim_trgo). For instance a master timer can then be used as a prescaler for a slave timer.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>Compare Pulse - The trigger output send a positive pulse when the CC1IF flag is to be set (even if it was already high), as soon as a capture or a compare match occurred. (tim_trgo).</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>Compare - tim_oc1refc signal is used as trigger output (tim_trgo)</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>Compare - tim_oc2refc signal is used as trigger output (tim_trgo)</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x6</name>
                  <description>Compare - tim_oc3refc signal is used as trigger output (tim_trgo)</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7</name>
                  <description>Compare - tim_oc4refc signal is used as trigger output (tim_trgo)</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TI1S</name>
              <description>tim_ti1 selection</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>The tim_ti1_in[15:0] multiplexer output is connected to tim_ti1 input</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_ti1_in[15:0], tim_ti2_in[15:0] and tim_ti3_in[15:0] multiplexers outputs are XORed and connected to the tim_ti1 input</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OIS1</name>
              <description>Output idle state 1 (tim_oc1 output)

Note: This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>tim_oc1=0 (after a dead-time) when MOE=0</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_oc1=1 (after a dead-time) when MOE=0</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OIS1N</name>
              <description>Output idle state 1 (tim_oc1n output)

Note: This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>tim_oc1n=0 after a dead-time when MOE=0</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_oc1n=1 after a dead-time when MOE=0</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OIS2</name>
              <description>Output idle state 2 (tim_oc2 output)

Refer to OIS1 bit</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OIS2N</name>
              <description>Output idle state 2 (tim_oc2n output)

Refer to OIS1N bit</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OIS3</name>
              <description>Output idle state 3 (tim_oc3n output)

Refer to OIS1 bit</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OIS3N</name>
              <description>Output idle state 3 (tim_oc3n output)

Refer to OIS1N bit</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OIS4</name>
              <description>Output idle state 4 (tim_oc4 output)

Refer to OIS1 bit</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OIS4N</name>
              <description>Output idle state 4 (tim_oc4n output)

Refer to OIS1N bit</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OIS5</name>
              <description>Output idle state 5 (tim_oc5 output)

Refer to OIS1 bit</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OIS6</name>
              <description>Output idle state 6 (tim_oc6 output)

Refer to OIS1 bit</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MMS2</name>
              <description>Master mode selection 2

These bits allow the information to be sent to ADC for synchronization (tim_trgo2) to be selected. The combination is as follows:

Note: The clock of the slave timer or ADC must be enabled prior to receive events from the master timer, and must not be changed on-the-fly while triggers are received from the master timer.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Reset - the UG bit from the TIMx_EGR register is used as trigger output (tim_trgo2). If the reset is generated by the trigger input (slave mode controller configured in reset mode), the signal on tim_trgo2 is delayed compared to the actual reset.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Enable - the Counter Enable signal CNT_EN is used as trigger output (tim_trgo2). It is useful to start several timers at the same time or to control a window in which a slave timer is enabled. The Counter Enable signal is generated by a logic AND between the CEN control bit and the trigger input when configured in Gated mode. When the Counter Enable signal is controlled by the trigger input, there is a delay on tim_trgo2, except if the Master/Slave mode is selected (see the MSM bit description in TIMx_SMCR register).</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>Update - the update event is selected as trigger output (tim_trgo2). For instance, a master timer can then be used as a prescaler for a slave timer.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>Compare pulse - the trigger output sends a positive pulse when the CC1IF flag is to be set (even if it was already high), as soon as a capture or compare match occurs (tim_trgo2).</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>Compare - tim_oc1refc signal is used as trigger output (tim_trgo2)</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>Compare - tim_oc2refc signal is used as trigger output (tim_trgo2)</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x6</name>
                  <description>Compare - tim_oc3refc signal is used as trigger output (tim_trgo2)</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7</name>
                  <description>Compare - tim_oc4refc signal is used as trigger output (tim_trgo2)</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x8</name>
                  <description>Compare - tim_oc5refc signal is used as trigger output (tim_trgo2)</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x9</name>
                  <description>Compare - tim_oc6refc signal is used as trigger output (tim_trgo2)</description>
                  <value>0x9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xA</name>
                  <description>Compare Pulse - tim_oc4refc rising or falling edges generate pulses on tim_trgo2</description>
                  <value>0xA</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xB</name>
                  <description>Compare pulse - tim_oc6refc rising or falling edges generate pulses on tim_trgo2</description>
                  <value>0xB</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xC</name>
                  <description>Compare pulse - tim_oc4refc or tim_oc6refc rising edges generate pulses on tim_trgo2</description>
                  <value>0xC</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xD</name>
                  <description>Compare pulse - tim_oc4refc rising or tim_oc6refc falling edges generate pulses on tim_trgo2</description>
                  <value>0xD</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xE</name>
                  <description>Compare pulse - tim_oc5refc or tim_oc6refc rising edges generate pulses on tim_trgo2</description>
                  <value>0xE</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xF</name>
                  <description>Compare pulse - tim_oc5refc rising or tim_oc6refc falling edges generate pulses on tim_trgo2</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MMS_1</name>
              <description>MMS[3]</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM1_SMCR</name>
          <displayName>TIM1_SMCR</displayName>
          <description>TIM1 slave mode control register</description>
          <addressOffset>0x008</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SMS</name>
              <description>SMS[2:0]: Slave mode selection

When external signals are selected the active edge of the trigger signal (tim_trgi) is linked to the polarity selected on the external input (see Input Control register and Control Register description.

Note: The gated mode must not be used if tim_ti1f_ed is selected as the trigger input (TS=00100). Indeed, tim_ti1f_ed outputs 1 pulse for each transition on TI1F, whereas the gated mode checks the level of the trigger signal.

Note: The clock of the slave peripherals (timer, ADC, ...) receiving the tim_trgo or the tim_trgo2 signals must be enabled prior to receive events from the master timer, and the clock frequency (prescaler) must not be changed on-the-fly while triggers are received from the master timer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Slave mode disabled - if CEN = '1' then the prescaler is clocked directly by the internal clock.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Quadrature encoder mode 1, x2 mode- Counter counts up/down on tim_ti1fp1 edge depending on tim_ti2fp2 level.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>Quadrature encoder mode 2, x2 mode - Counter counts up/down on tim_ti2fp2 edge depending on tim_ti1fp1 level.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>Quadrature encoder mode 3, x4 mode - Counter counts up/down on both tim_ti1fp1 and tim_ti2fp2 edges depending on the level of the other input.</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>Reset Mode - Rising edge of the selected trigger input (tim_trgi) reinitializes the counter and generates an update of the registers.</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>Gated Mode - The counter clock is enabled when the trigger input (tim_trgi) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled.</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x6</name>
                  <description>Trigger Mode - The counter starts at a rising edge of the trigger tim_trgi (but it is not reset). Only the start of the counter is controlled.</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7</name>
                  <description>External Clock Mode 1 - Rising edges of the selected trigger (tim_trgi) clock the counter.</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OCCS</name>
              <description>OCREF clear selection

This bit is used to select the OCREF clear source.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>tim_ocref_clr_int is connected to the tim_ocref_clr input</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_ocref_clr_int is connected to tim_etrf</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TS</name>
              <description>TS[2:0]: Trigger selection

This bitfield is combined with TS[4:3] bits.

This bit-field selects the trigger input to be used to synchronize the counter. 

Others: Reserved

See Table 257: TIMx internal trigger connection for more details on tim_itrx meaning for each Timer.

Note: These bits must be changed only when they are not used (e.g. when SMS=000) to avoid wrong edge detections at the transition.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Internal Trigger 0 (tim_itr0)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Internal Trigger 1 (tim_itr1)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>Internal Trigger 2 (tim_itr2)</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>Internal Trigger 3 (tim_itr3)</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>tim_ti1 Edge Detector (tim_ti1f_ed)</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>Filtered Timer Input 1 (tim_ti1fp1)</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x6</name>
                  <description>Filtered Timer Input 2 (tim_ti2fp2)</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7</name>
                  <description>External Trigger input (tim_etrf)</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MSM</name>
              <description>Master/slave mode</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The effect of an event on the trigger input (tim_trgi) is delayed to allow a perfect synchronization between the current timer and its slaves (through tim_trgo). It is useful if we want to synchronize several timers on a single external event.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ETF</name>
              <description>External trigger filter

This bit-field then defines the frequency used to sample tim_etrp signal and the length of the digital filter applied to tim_etrp. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No filter, sampling is done at fsubDTS/sub</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>fsubSAMPLING/sub=fsubtim_ker_ck/sub, N=2</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>fsubSAMPLING/sub=fsubtim_ker_ck/sub, N=4</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>fsubSAMPLING/sub=fsubtim_ker_ck/sub, N=8</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/2, N=6</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/2, N=8</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x6</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/4, N=6</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/4, N=8</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x8</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/8, N=6</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x9</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/8, N=8</description>
                  <value>0x9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xA</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/16, N=5</description>
                  <value>0xA</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xB</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/16, N=6</description>
                  <value>0xB</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xC</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/16, N=8</description>
                  <value>0xC</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xD</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/32, N=5</description>
                  <value>0xD</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xE</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/32, N=6</description>
                  <value>0xE</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xF</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/32, N=8</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ETPS</name>
              <description>External trigger prescaler

External trigger signal tim_etrp frequency must be at most 1/4 of TIMxCLK frequency. A prescaler can be enabled to reduce tim_etrp frequency. It is useful when inputting fast external clocks on tim_etr_in.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Prescaler OFF</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_etr_in frequency divided by 2</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>tim_etr_in frequency divided by 4</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>tim_etr_in frequency divided by 8</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ECE</name>
              <description>External clock enable

This bit enables External clock mode 2. 

Note: Setting the ECE bit has the same effect as selecting external clock mode 1 with tim_trgi connected to tim_etrf (SMS=111 and TS=00111).

It is possible to simultaneously use external clock mode 2 with the following slave modes: reset mode, gated mode and trigger mode. Nevertheless, tim_trgi must not be connected to tim_etrf in this case (TS bits must not be 00111).

Note: If external clock mode 1 and external clock mode 2 are enabled at the same time, the external clock input is tim_etrf.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>External clock mode 2 disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>External clock mode 2 enabled. The counter is clocked by any active edge on the tim_etrf signal.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ETP</name>
              <description>External trigger polarity

This bit selects whether tim_etr_in or tim_etr_in is used for trigger operations</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>tim_etr_in is non-inverted, active at high level or rising edge.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_etr_in is inverted, active at low level or falling edge.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SMS_1</name>
              <description>SMS[3]</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TS_1</name>
              <description>TS[4:3]</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SMSPE</name>
              <description>SMS preload enable

This bit selects whether the SMS[3:0] bitfield is preloaded</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>SMS[3:0] bitfield is not preloaded</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>SMS[3:0] preload is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SMSPS</name>
              <description>SMS preload source

This bit selects whether the events that triggers the SMS[3:0] bitfield transfer from preload to active</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>The transfer is triggered by the Timer's Update event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The transfer is triggered by the Index event</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM1_DIER</name>
          <displayName>TIM1_DIER</displayName>
          <description>TIM1 DMA/interrupt enable register</description>
          <addressOffset>0x00C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>UIE</name>
              <description>Update interrupt enable</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Update interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Update interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CC1IE</name>
              <description>Capture/compare 1 interrupt enable</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>CC1 interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>CC1 interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CC2IE</name>
              <description>Capture/compare 2 interrupt enable</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>CC2 interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>CC2 interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CC3IE</name>
              <description>Capture/compare 3 interrupt enable</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>CC3 interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>CC3 interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CC4IE</name>
              <description>Capture/compare 4 interrupt enable</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>CC4 interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>CC4 interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>COMIE</name>
              <description>COM interrupt enable</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>COM interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>COM interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TIE</name>
              <description>Trigger interrupt enable</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Trigger interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Trigger interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BIE</name>
              <description>Break interrupt enable</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Break interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Break interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UDE</name>
              <description>Update DMA request enable</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Update DMA request disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Update DMA request enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CC1DE</name>
              <description>Capture/compare 1 DMA request enable</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>CC1 DMA request disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>CC1 DMA request enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CC2DE</name>
              <description>Capture/compare 2 DMA request enable</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>CC2 DMA request disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>CC2 DMA request enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CC3DE</name>
              <description>Capture/compare 3 DMA request enable</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>CC3 DMA request disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>CC3 DMA request enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CC4DE</name>
              <description>Capture/compare 4 DMA request enable</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>CC4 DMA request disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>CC4 DMA request enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>COMDE</name>
              <description>COM DMA request enable</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>COM DMA request disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>COM DMA request enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TDE</name>
              <description>Trigger DMA request enable</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Trigger DMA request disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Trigger DMA request enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IDXIE</name>
              <description>Index interrupt enable</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Index interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Index Change interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIRIE</name>
              <description>Direction change interrupt enable</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Direction Change interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Direction Change interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IERRIE</name>
              <description>Index error interrupt enable</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Index error interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Index error interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TERRIE</name>
              <description>Transition error interrupt enable</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Transition error interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Transition error interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM1_SR</name>
          <displayName>TIM1_SR</displayName>
          <description>TIM1 status register</description>
          <addressOffset>0x010</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>UIF</name>
              <description>Update interrupt flag

This bit is set by hardware on an update event. It is cleared by software. 

At overflow or underflow regarding the repetition counter value (update if repetition counter = 0) and if the UDIS=0 in the TIMx_CR1 register.

When CNT is reinitialized by software using the UG bit in TIMx_EGR register, if URS=0 and UDIS=0 in the TIMx_CR1 register.

When CNT is reinitialized by a trigger event (refer to Section 28.6.3: TIM1 slave mode control register (TIM1_SMCR)), if URS=0 and UDIS=0 in the TIMx_CR1 register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No update occurred.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Update interrupt pending. This bit is set by hardware when the registers are updated:</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CC1IF</name>
              <description>Capture/compare 1 interrupt flag

This flag is set by hardware. It is cleared by software (input capture or output compare mode) or by reading the TIMx_CCR1 register (input capture mode only).

If channel CC1 is configured as output: this flag is set when the content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. When the content of TIMx_CCR1 is greater than the content of TIMx_ARR, the CC1IF bit goes high on the counter overflow (in up-counting and up/down-counting modes) or underflow (in downcounting mode). There are 3 possible options for flag setting in center-aligned mode, refer to the CMS bits in the TIMx_CR1 register for the full description.

If channel CC1 is configured as input: this bit is set when counter value has been captured in TIMx_CCR1 register (an edge has been detected on IC1, as per the edge sensitivity defined with the CC1P and CC1NP bits setting, in TIMx_CCER).</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No compare match / No input capture occurred</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>A compare match or an input capture occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CC2IF</name>
              <description>Capture/compare 2 interrupt flag

Refer to CC1IF description</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CC3IF</name>
              <description>Capture/compare 3 interrupt flag

Refer to CC1IF description</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CC4IF</name>
              <description>Capture/compare 4 interrupt flag

Refer to CC1IF description</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COMIF</name>
              <description>COM interrupt flag

This flag is set by hardware on COM event (when capture/compare Control bits - CCxE, CCxNE, OCxM - have been updated). It is cleared by software.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No COM event occurred.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>COM interrupt pending.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TIF</name>
              <description>Trigger interrupt flag

This flag is set by hardware on the TRG trigger event (active edge detected on tim_trgi input when the slave mode controller is enabled in all modes but gated mode. It is set when the counter starts or stops when gated mode is selected. It is cleared by software.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No trigger event occurred.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Trigger interrupt pending.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BIF</name>
              <description>Break interrupt flag

This flag is set by hardware as soon as the break input goes active. It can be cleared by software if the break input is not active.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No break event occurred.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>An active level has been detected on the break input. An interrupt is generated if BIE=1 in the TIMx_DIER register.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>B2IF</name>
              <description>Break 2 interrupt flag

This flag is set by hardware as soon as the break 2 input goes active. It can be cleared by software if the break 2 input is not active.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No break event occurred.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>An active level has been detected on the break 2 input. An interrupt is generated if BIE=1 in the TIMx_DIER register.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CC1OF</name>
              <description>Capture/compare 1 overcapture flag

This flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing it to '0'.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No overcapture has been detected.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The counter value has been captured in TIMx_CCR1 register while CC1IF flag was already set</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CC2OF</name>
              <description>Capture/compare 2 overcapture flag

Refer to CC1OF description</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CC3OF</name>
              <description>Capture/compare 3 overcapture flag

Refer to CC1OF description</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CC4OF</name>
              <description>Capture/compare 4 overcapture flag

Refer to CC1OF description</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SBIF</name>
              <description>System break interrupt flag

This flag is set by hardware as soon as the system break input goes active. It can be cleared by software if the system break input is not active.

This flag must be reset to re-start PWM operation.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No break event occurred.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>An active level has been detected on the system break input. An interrupt is generated if BIE=1 in the TIMx_DIER register.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CC5IF</name>
              <description>Compare 5 interrupt flag

Refer to CC1IF description

Note: Channel 5 can only be configured as output.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CC6IF</name>
              <description>Compare 6 interrupt flag

Refer to CC1IF description

Note: Channel 6 can only be configured as output.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IDXF</name>
              <description>Index interrupt flag

This flag is set by hardware when an index event is detected. It is cleared by software by writing it to '0'.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No index event occurred.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>An index event has occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIRF</name>
              <description>Direction change interrupt flag

This flag is set by hardware when the direction changes in encoder mode (DIR bit value in TIMx_CR is changing). It is cleared by software by writing it to '0'.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No direction change</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Direction change</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IERRF</name>
              <description>Index error interrupt flag

This flag is set by hardware when an index error is detected. It is cleared by software by writing it to '0'.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No index error has been detected.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>An index error has been detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TERRF</name>
              <description>Transition error interrupt flag

This flag is set by hardware when a transition error is detected in encoder mode. It is cleared by software by writing it to '0'.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No encoder transition error has been detected.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>An encoder transition error has been detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM1_EGR</name>
          <displayName>TIM1_EGR</displayName>
          <description>TIM1 event generation register</description>
          <addressOffset>0x014</addressOffset>
          <size>16</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>UG</name>
              <description>Update generation

This bit can be set by software, it is automatically cleared by hardware.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reinitialize the counter and generates an update of the registers. Note that the prescaler counter is cleared too (anyway the prescaler ratio is not affected). The counter is cleared if the center-aligned mode is selected or if DIR=0 (upcounting), else it takes the auto-reload value (TIMx_ARR) if DIR=1 (downcounting).</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CC1G</name>
              <description>Capture/compare 1 generation

This bit is set by software in order to generate an event, it is automatically cleared by hardware. 

If channel CC1 is configured as output:

CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled.

If channel CC1 is configured as input:

The current value of the counter is captured in TIMx_CCR1 register. The CC1IF flag is set, the corresponding interrupt or DMA request is sent if enabled. The CC1OF flag is set if the CC1IF flag was already high.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>A capture/compare event is generated on channel 1:</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CC2G</name>
              <description>Capture/compare 2 generation

Refer to CC1G description</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CC3G</name>
              <description>Capture/compare 3 generation

Refer to CC1G description</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CC4G</name>
              <description>Capture/compare 4 generation

Refer to CC1G description</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>COMG</name>
              <description>Capture/compare control update generation

This bit can be set by software, it is automatically cleared by hardware

Note: This bit acts only on channels having a complementary output.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>When CCPC bit is set, it allows to update CCxE, CCxNE and OCxM bits</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TG</name>
              <description>Trigger generation

This bit is set by software in order to generate an event, it is automatically cleared by hardware.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The TIF flag is set in TIMx_SR register. Related interrupt or DMA transfer can occur if enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BG</name>
              <description>Break generation

This bit is set by software in order to generate an event, it is automatically cleared by hardware.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>A break event is generated. MOE bit is cleared and BIF flag is set. Related interrupt or DMA transfer can occur if enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>B2G</name>
              <description>Break 2 generation

This bit is set by software in order to generate an event, it is automatically cleared by hardware.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>A break 2 event is generated. MOE bit is cleared and B2IF flag is set. Related interrupt can occur if enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM1_CCMR1</name>
          <displayName>TIM1_CCMR1</displayName>
          <description>TIM1 capture/compare mode register 1 [alternate]</description>
          <addressOffset>0x018</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CC1S</name>
              <description>Capture/compare 1 Selection

This bit-field defines the direction of the channel (input/output) as well as the used input. 

Note: CC1S bits are writable only when the channel is OFF (CC1E = '0' in TIMx_CCER).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>CC1 channel is configured as output</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>CC1 channel is configured as input, tim_ic1 is mapped on tim_ti1</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>CC1 channel is configured as input, tim_ic1 is mapped on tim_ti2</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>CC1 channel is configured as input, tim_ic1 is mapped on tim_trc. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IC1PSC</name>
              <description>Input capture 1 prescaler

This bit-field defines the ratio of the prescaler acting on CC1 input (tim_ic1). The prescaler is reset as soon as CC1E='0' (TIMx_CCER register).</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no prescaler, capture is done each time an edge is detected on the capture input</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>capture is done once every 2 events</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>capture is done once every 4 events</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>capture is done once every 8 events</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IC1F</name>
              <description>Input capture 1 filter

This bit-field defines the frequency used to sample tim_ti1 input and the length of the digital filter applied to tim_ti1. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No filter, sampling is done at fsubDTS/sub</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>fsubSAMPLING/sub=fsubtim_ker_ck/sub, N=2</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>fsubSAMPLING/sub=fsubtim_ker_ck/sub, N=4</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>fsubSAMPLING/sub=fsubtim_ker_ck/sub, N=8</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/2, N=6</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/2, N=8</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x6</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/4, N=6</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/4, N=8</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x8</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/8, N=6</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x9</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/8, N=8</description>
                  <value>0x9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xA</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/16, N=5</description>
                  <value>0xA</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xB</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/16, N=6</description>
                  <value>0xB</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xC</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/16, N=8</description>
                  <value>0xC</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xD</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/32, N=5</description>
                  <value>0xD</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xE</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/32, N=6</description>
                  <value>0xE</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xF</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/32, N=8</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CC2S</name>
              <description>Capture/compare 2 selection

This bit-field defines the direction of the channel (input/output) as well as the used input. 

Note: CC2S bits are writable only when the channel is OFF (CC2E = '0' in TIMx_CCER).</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>CC2 channel is configured as output</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>CC2 channel is configured as input, tim_ic2 is mapped on tim_ti2</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>CC2 channel is configured as input, tim_ic2 is mapped on tim_ti1</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>CC2 channel is configured as input, tim_ic2 is mapped on tim_trc. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IC2PSC</name>
              <description>Input capture 2 prescaler</description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IC2F</name>
              <description>Input capture 2 filter</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM1_CCMR1_ALTERNATE1</name>
          <displayName>TIM1_CCMR1_ALTERNATE1</displayName>
          <description>TIM1 capture/compare mode register 1 [alternate]</description>
          <alternateRegister>TIM1_CCMR1</alternateRegister>
          <addressOffset>0x018</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CC1S</name>
              <description>Capture/compare 1 selection

This bit-field defines the direction of the channel (input/output) as well as the used input. 

Note: CC1S bits are writable only when the channel is OFF (CC1E = '0' in TIMx_CCER).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>CC1 channel is configured as output</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>CC1 channel is configured as input, tim_ic1 is mapped on tim_ti1</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>CC1 channel is configured as input, tim_ic1 is mapped on tim_ti2</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>CC1 channel is configured as input, tim_ic1 is mapped on tim_trc. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OC1FE</name>
              <description>Output compare 1 fast enable

This bit decreases the latency between a trigger event and a transition on the timer output. It must be used in one-pulse mode (OPM bit set in TIMx_CR1 register), to have the output pulse starting as soon as possible after the starting trigger.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>CC1 behaves normally depending on counter and CCR1 values even when the trigger is ON. The minimum delay to activate CC1 output when an edge occurs on the trigger input is 5 clock cycles.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>An active edge on the trigger input acts like a compare match on CC1 output. Then, OC is set to the compare level independently from the result of the comparison. Delay to sample the trigger input and to activate CC1 output is reduced to 3 clock cycles. OCFE acts only if the channel is configured in PWM1 or PWM2 mode.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OC1PE</name>
              <description>Output compare 1 preload enable

Note: These bits can not be modified as long as LOCK level 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S='00' (the channel is configured in output).</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Preload register on TIMx_CCR1 disabled. TIMx_CCR1 can be written at anytime, the new value is taken in account immediately.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Preload register on TIMx_CCR1 enabled. Read/Write operations access the preload register. TIMx_CCR1 preload value is loaded in the active register at each update event.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OC1M</name>
              <description>OC1M[2:0]: Output compare 1 mode

These bits define the behavior of the output reference signal tim_oc1ref from which tim_oc1 and tim_oc1n are derived. tim_oc1ref is active high whereas tim_oc1 and tim_oc1n active level depends on CC1P and CC1NP bits.

Note: These bits can not be modified as long as LOCK level 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S='00' (the channel is configured in output).

Note: In PWM mode, the OCREF level changes only when the result of the comparison changes or when the output compare mode switches from 'frozen' mode to 'PWM' mode.

Note: On channels having a complementary output, this bit field is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the OC1M active bits take the new value from the preloaded bits only when a COM event is generated.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Frozen - The comparison between the output compare register TIMx_CCR1 and the counter TIMx_CNT has no effect on the outputs.(this mode is used to generate a timing base).</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Set channel 1 to active level on match. tim_oc1ref signal is forced high when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>Set channel 1 to inactive level on match. tim_oc1ref signal is forced low when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>Toggle - tim_oc1ref toggles when TIMx_CNT=TIMx_CCR1.</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>Force inactive level - tim_oc1ref is forced low.</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>Force active level - tim_oc1ref is forced high.</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x6</name>
                  <description>PWM mode 1 - In upcounting, channel 1 is active as long as TIMx_CNTTIMx_CCR1 else inactive. In downcounting, channel 1 is inactive (tim_oc1ref='0') as long as TIMx_CNTTIMx_CCR1 else active (tim_oc1ref='1').</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7</name>
                  <description>PWM mode 2 - In upcounting, channel 1 is inactive as long as TIMx_CNTTIMx_CCR1 else active. In downcounting, channel 1 is active as long as TIMx_CNTTIMx_CCR1 else inactive.</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OC1CE</name>
              <description>Output compare 1 clear enable</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>tim_oc1ref is not affected by the tim_ocref_clr_int signal</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_oc1ref is cleared as soon as a High level is detected on tim_ocref_clr_int signal (tim_ocref_clr input or tim_etrf input)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CC2S</name>
              <description>Capture/compare 2 selection

This bit-field defines the direction of the channel (input/output) as well as the used input. 

Note: CC2S bits are writable only when the channel is OFF (CC2E = '0' in TIMx_CCER).</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>CC2 channel is configured as output</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>CC2 channel is configured as input, tim_ic2 is mapped on tim_ti2</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>CC2 channel is configured as input, tim_ic2 is mapped on tim_ti1</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>CC2 channel is configured as input, tim_ic2 is mapped on tim_trc. This mode is working only if an internal trigger input is selected through the TS bit (TIMx_SMCR register)</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OC2FE</name>
              <description>Output compare 2 fast enable</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OC2PE</name>
              <description>Output compare 2 preload enable</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OC2M</name>
              <description>OC2M[2:0]: Output compare 2 mode</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OC2CE</name>
              <description>Output compare 2 clear enable</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OC1M_1</name>
              <description>OC1M[3]</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OC2M_1</name>
              <description>OC2M[3]</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM1_CCMR2</name>
          <displayName>TIM1_CCMR2</displayName>
          <description>TIM1 capture/compare mode register 2 [alternate]</description>
          <addressOffset>0x01C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CC3S</name>
              <description>Capture/compare 3 selection

This bit-field defines the direction of the channel (input/output) as well as the used input. 

Note: CC3S bits are writable only when the channel is OFF (CC3E = '0' in TIMx_CCER).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>CC3 channel is configured as output</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>CC3 channel is configured as input, tim_ic3 is mapped on tim_ti3</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>CC3 channel is configured as input, tim_ic3 is mapped on tim_ti4</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>CC3 channel is configured as input, tim_ic3 is mapped on tim_trc. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IC3PSC</name>
              <description>Input capture 3 prescaler</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IC3F</name>
              <description>Input capture 3 filter</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CC4S</name>
              <description>Capture/compare 4 selection

This bit-field defines the direction of the channel (input/output) as well as the used input. 

Note: CC4S bits are writable only when the channel is OFF (CC4E = '0' in TIMx_CCER).</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>CC4 channel is configured as output</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>CC4 channel is configured as input, tim_ic4 is mapped on tim_ti4</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>CC4 channel is configured as input, tim_ic4 is mapped on tim_ti3</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>CC4 channel is configured as input, tim_ic4 is mapped on tim_trc. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IC4PSC</name>
              <description>Input capture 4 prescaler</description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IC4F</name>
              <description>Input capture 4 filter</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM1_CCMR2_ALTERNATE1</name>
          <displayName>TIM1_CCMR2_ALTERNATE1</displayName>
          <description>TIM1 capture/compare mode register 2 [alternate]</description>
          <alternateRegister>TIM1_CCMR2</alternateRegister>
          <addressOffset>0x01C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CC3S</name>
              <description>Capture/compare 3 selection

This bit-field defines the direction of the channel (input/output) as well as the used input. 

Note: CC3S bits are writable only when the channel is OFF (CC3E = '0' in TIMx_CCER).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>CC3 channel is configured as output</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>CC3 channel is configured as input, tim_ic3 is mapped on tim_ti3</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>CC3 channel is configured as input, tim_ic3 is mapped on tim_ti4</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>CC3 channel is configured as input, tim_ic3 is mapped on tim_trc. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OC3FE</name>
              <description>Output compare 3 fast enable</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OC3PE</name>
              <description>Output compare 3 preload enable</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OC3M</name>
              <description>OC3M[2:0]: Output compare 3 mode

These bits define the behavior of the output reference signal tim_oc3ref from which tim_oc3 and tim_oc3n are derived. tim_oc3ref is active high whereas tim_oc3 and tim_oc3n active level depends on CC3P and CC3NP bits.

Note: These bits can not be modified as long as LOCK level 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S='00' (the channel is configured in output).

Note: In PWM mode, the OCREF level changes only when the result of the comparison changes or when the output compare mode switches from 'frozen' mode to 'PWM' mode.

On channels having a complementary output, this bit field is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the OC3M active bits take the new value from the preloaded bits only when a COM event is generated.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Frozen - The comparison between the output compare register TIMx_CCR3 and the counter TIMx_CNT has no effect on the outputs.(this mode is used to generate a timing base).</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Set channel 3 to active level on match. tim_oc3ref signal is forced high when the counter TIMx_CNT matches the capture/compare register 3 (TIMx_CCR3).</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>Set channel 3 to inactive level on match. tim_oc3ref signal is forced low when the counter TIMx_CNT matches the capture/compare register 3 (TIMx_CCR3).</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>Toggle - tim_oc3ref toggles when TIMx_CNT=TIMx_CCR3.</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>Force inactive level - tim_oc3ref is forced low.</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>Force active level - tim_oc3ref is forced high.</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x6</name>
                  <description>PWM mode 1 - In upcounting, channel 3 is active as long as TIMx_CNTTIMx_CCR3 else inactive. In downcounting, channel 3 is inactive (tim_oc3ref='0') as long as TIMx_CNTTIMx_CCR3 else active (tim_oc3ref='1').</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7</name>
                  <description>PWM mode 2 - In upcounting, channel 3 is inactive as long as TIMx_CNTTIMx_CCR3 else active. In downcounting, channel 3 is active as long as TIMx_CNTTIMx_CCR3 else inactive.</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OC3CE</name>
              <description>Output compare 3 clear enable</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CC4S</name>
              <description>Capture/compare 4 selection

This bit-field defines the direction of the channel (input/output) as well as the used input. 

Note: CC4S bits are writable only when the channel is OFF (CC4E = '0' in TIMx_CCER).</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>CC4 channel is configured as output</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>CC4 channel is configured as input, tim_ic4 is mapped on tim_ti4</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>CC4 channel is configured as input, tim_ic4 is mapped on tim_ti3</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>CC4 channel is configured as input, tim_ic4 is mapped on tim_trc. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OC4FE</name>
              <description>Output compare 4 fast enable</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OC4PE</name>
              <description>Output compare 4 preload enable</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OC4M</name>
              <description>OC4M[2:0]: Output compare 4 mode

Refer to OC3M[3:0] bit description</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OC4CE</name>
              <description>Output compare 4 clear enable</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OC3M_1</name>
              <description>OC3M[3]</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OC4M_1</name>
              <description>OC4M[3]</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM1_CCER</name>
          <displayName>TIM1_CCER</displayName>
          <description>TIM1 capture/compare enable register</description>
          <addressOffset>0x020</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CC1E</name>
              <description>Capture/compare 1 output enable

When CC1 channel is configured as output, the OC1 level depends on MOE, OSSI, OSSR, OIS1, OIS1N and CC1NE bits, regardless of the CC1E bits state. Refer to Table 272 for details.

Note: On channels having a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1E active bit takes the new value from the preloaded bit only when a Commutation event is generated.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Capture mode disabled / OC1 is not active (see below)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Capture mode enabled / OC1 signal is output on the corresponding output pin</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CC1P</name>
              <description>Capture/compare 1 output polarity

When CC1 channel is configured as input, both CC1NP/CC1P bits select the active polarity of TI1FP1 and TI2FP1 for trigger or capture operations.

CC1NP=0, CC1P=0:	non-inverted/rising edge. The circuit is sensitive to TIxFP1 rising edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is not inverted (trigger operation in gated mode or encoder mode).

CC1NP=0, CC1P=1:	inverted/falling edge. The circuit is sensitive to TIxFP1 falling edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is inverted (trigger operation in gated mode or encoder mode).

CC1NP=1, CC1P=1:	non-inverted/both edges/ The circuit is sensitive to both TIxFP1 rising and falling edges (capture or trigger operations in reset, external clock or trigger mode), TIxFP1is not inverted (trigger operation in gated mode). This configuration must not be used in encoder mode.

CC1NP=1, CC1P=0:	the configuration is reserved, it must not be used.

Note: This bit is not writable as soon as LOCK level 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).

Note: On channels having a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1P active bit takes the new value from the preloaded bit only when a Commutation event is generated.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>OC1 active high (output mode) / Edge sensitivity selection (input mode, see below)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>OC1 active low (output mode) / Edge sensitivity selection (input mode, see below)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CC1NE</name>
              <description>Capture/compare 1 complementary output enable

Note: On channels having a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1NE active bit takes the new value from the preloaded bit only when a Commutation event is generated.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Off - tim_oc1n is not active. tim_oc1n level is then function of MOE, OSSI, OSSR, OIS1, OIS1N and CC1E bits.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>On - tim_oc1n signal is output on the corresponding output pin depending on MOE, OSSI, OSSR, OIS1, OIS1N and CC1E bits.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CC1NP</name>
              <description>Capture/compare 1 complementary output polarity

CC1 channel configured as output:

CC1 channel configured as input:

This bit is used in conjunction with CC1P to define the polarity of tim_ti1fp1 and tim_ti2fp1. Refer to CC1P description.

Note: This bit is not writable as soon as LOCK level 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S='00' (channel configured as output).

Note: On channels having a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1NP active bit takes the new value from the preloaded bit only when a Commutation event is generated.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>tim_oc1n active high.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_oc1n active low.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CC2E</name>
              <description>Capture/compare 2 output enable

Refer to CC1E description</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CC2P</name>
              <description>Capture/compare 2 output polarity

Refer to CC1P description</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CC2NE</name>
              <description>Capture/compare 2 complementary output enable

Refer to CC1NE description</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CC2NP</name>
              <description>Capture/compare 2 complementary output polarity

Refer to CC1NP description</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CC3E</name>
              <description>Capture/compare 3 output enable

Refer to CC1E description</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CC3P</name>
              <description>Capture/compare 3 output polarity

Refer to CC1P description</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CC3NE</name>
              <description>Capture/compare 3 complementary output enable

Refer to CC1NE description</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CC3NP</name>
              <description>Capture/compare 3 complementary output polarity

Refer to CC1NP description</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CC4E</name>
              <description>Capture/compare 4 output enable

Refer to CC1E description</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CC4P</name>
              <description>Capture/compare 4 output polarity

Refer to CC1P description</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CC4NE</name>
              <description>Capture/compare 4 complementary output enable

Refer to CC1NE description</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CC4NP</name>
              <description>Capture/compare 4 complementary output polarity

Refer to CC1NP description</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CC5E</name>
              <description>Capture/compare 5 output enable

Refer to CC1E description</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CC5P</name>
              <description>Capture/compare 5 output polarity

Refer to CC1P description</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CC6E</name>
              <description>Capture/compare 6 output enable

Refer to CC1E description</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CC6P</name>
              <description>Capture/compare 6 output polarity

Refer to CC1P description</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM1_CNT</name>
          <displayName>TIM1_CNT</displayName>
          <description>TIM1 counter</description>
          <addressOffset>0x024</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNT</name>
              <description>Counter value

Non-dithering mode (DITHEN = 0)

The register holds the counter value.

Dithering mode (DITHEN = 1)

The register only holds the non-dithered part in CNT[15:0]. The fractional part is not available.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UIFCPY</name>
              <description>UIF copy

This bit is a read-only copy of the UIF bit of the TIMx_ISR register. If the UIFREMAP bit in the TIMxCR1 is reset, bit 31 is reserved and read at 0.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM1_PSC</name>
          <displayName>TIM1_PSC</displayName>
          <description>TIM1 prescaler</description>
          <addressOffset>0x028</addressOffset>
          <size>16</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>PSC</name>
              <description>Prescaler value

The counter clock frequency (fsubtim_cnt_ck/sub) is equal to fsubtim_psc_ck/sub / (PSC[15:0] + 1).

PSC contains the value to be loaded in the active prescaler register at each update event (including when the counter is cleared through UG bit of TIMx_EGR register or through trigger controller when configured in 'reset mode').</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM1_ARR</name>
          <displayName>TIM1_ARR</displayName>
          <description>TIM1 auto-reload register</description>
          <addressOffset>0x02C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000FFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ARR</name>
              <description>Auto-reload value

ARR is the value to be loaded in the actual auto-reload register.

Refer to the Section 28.3.3: Time-base unit on page 1112 for more details about ARR update and behavior.

The counter is blocked while the auto-reload value is null.

Non-dithering mode (DITHEN = 0)

The register holds the auto-reload value.

Dithering mode (DITHEN = 1)

The register holds the integer part in ARR[19:4]. The ARR[3:0] bitfield contains the dithered part.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>20</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM1_RCR</name>
          <displayName>TIM1_RCR</displayName>
          <description>TIM1 repetition counter register</description>
          <addressOffset>0x030</addressOffset>
          <size>16</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>REP</name>
              <description>Repetition counter reload value

This bitfield defines the update rate of the compare registers (i.e. periodic transfers from preload to active registers) when preload registers are enable. It also defines the update interrupt generation rate, if this interrupt is enable.

When the repetition down-counter reaches zero, an update event is generated and it restarts counting from REP value. As the repetition counter is reloaded with REP value only at the repetition update event UEV, any write to the TIMx_RCR register is not taken in account until the next repetition update event.

It means in PWM mode (REP+1) corresponds to:

the number of PWM periods in edge-aligned mode

the number of half PWM period in center-aligned mode.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM1_CCR1</name>
          <displayName>TIM1_CCR1</displayName>
          <description>TIM1 capture/compare register 1</description>
          <addressOffset>0x034</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CCR1</name>
              <description>Capture/compare 1 value

If channel CC1 is configured as output: CCR1 is the value to be loaded in the actual capture/compare 1 register (preload value).

It is loaded permanently if the preload feature is not selected in the TIMx_CCMR1 register (bit OC1PE). Else the preload value is copied in the active capture/compare 1 register when an update event occurs.

The active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on tim_oc1 output.

Non-dithering mode (DITHEN = 0)

The register holds the compare value in CCR1[15:0]. The CCR1[19:16] bits are reset.

Dithering mode (DITHEN = 1)

The register holds the integer part in CCR1[19:4]. The CCR1[3:0] bitfield contains the dithered part.

If channel CC1 is configured as input: CR1 is the counter value transferred by the last input capture 1 event (tim_ic1). The TIMx_CCR1 register is read-only and cannot be programmed.

Non-dithering mode (DITHEN = 0)

The register holds the capture value in CCR1[15:0]. The CCR1[19:16] bits are reset.

Dithering mode (DITHEN = 1)

The register holds the capture in CCR1[19:4]. The CCR1[3:0] bits are reset.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>20</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM1_CCR2</name>
          <displayName>TIM1_CCR2</displayName>
          <description>TIM1 capture/compare register 2</description>
          <addressOffset>0x038</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CCR2</name>
              <description>Capture/compare 2 value

If channel CC2 is configured as output: CCR2 is the value to be loaded in the actual capture/compare 2 register (preload value).

It is loaded permanently if the preload feature is not selected in the TIMx_CCMR1 register (bit OC2PE). Else the preload value is copied in the active capture/compare 2 register when an update event occurs.

The active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on tim_oc2 output.

Non-dithering mode (DITHEN = 0)

The register holds the compare value in CCR2[15:0]. The CCR2[19:16] bits are reset.

Dithering mode (DITHEN = 1)

The register holds the integer part in CCR2[19:4]. The CCR2[3:0] bitfield contains the dithered part.

If channel CC2 is configured as input: CCR2 is the counter value transferred by the last input capture 2 event (tim_ic2). The TIMx_CCR2 register is read-only and cannot be programmed.

Non-dithering mode (DITHEN = 0)

The register holds the capture value in CCR2[15:0]. The CCR2[19:16] bits are reset.

Dithering mode (DITHEN = 1)

The register holds the capture in CCR2[19:4]. The CCR2[3:0] bits are reset.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>20</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM1_CCR3</name>
          <displayName>TIM1_CCR3</displayName>
          <description>TIM1 capture/compare register 3</description>
          <addressOffset>0x03C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CCR3</name>
              <description>Capture/compare value

If channel CC3 is configured as output: CCR3 is the value to be loaded in the actual capture/compare 3 register (preload value).

It is loaded permanently if the preload feature is not selected in the TIMx_CCMR2 register (bit OC3PE). Else the preload value is copied in the active capture/compare 3 register when an update event occurs.

The active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on tim_oc3 output.

Non-dithering mode (DITHEN = 0)

The register holds the compare value in CCR3[15:0]. The CCR3[19:16] bits are reset.

Dithering mode (DITHEN = 1)

The register holds the integer part in CCR3[19:4]. The CCR3[3:0] bitfield contains the dithered part.

If channel CC3 is configured as input: CCR3 is the counter value transferred by the last input capture 3 event (tim_ic3). The TIMx_CCR3 register is read-only and cannot be programmed.

Non-dithering mode (DITHEN = 0)

The register holds the capture value in CCR3[15:0]. The CCR3[19:16] bits are reset.

Dithering mode (DITHEN = 1)

The register holds the capture in CCR3[19:4]. The CCR3[3:0] bits are reset.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>20</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM1_CCR4</name>
          <displayName>TIM1_CCR4</displayName>
          <description>TIM1 capture/compare register 4</description>
          <addressOffset>0x040</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CCR4</name>
              <description>Capture/compare value

If channel CC4 is configured as output: CCR4 is the value to be loaded in the actual capture/compare 4 register (preload value).

It is loaded permanently if the preload feature is not selected in the TIMx_CCMR2 register (bit OC4PE). Else the preload value is copied in the active capture/compare 4 register when an update event occurs.

The active capture/compare register contains the value to be compared to the counter TIMx_CNT and signalled on tim_oc4 output.

Non-dithering mode (DITHEN = 0)

The register holds the compare value in CCR4[15:0]. The CCR4[19:16] bits are reset.

Dithering mode (DITHEN = 1)

The register holds the integer part in CCR4[19:4]. The CCR4[3:0] bitfield contains the dithered part.

If channel CC4 is configured as input: CCR4 is the counter value transferred by the last input capture 4 event (tim_ic4). The TIMx_CCR4 register is read-only and cannot be programmed.

Non-dithering mode (DITHEN = 0)

The register holds the capture value in CCR4[15:0]. The CCR4[19:16] bits are reset.

Dithering mode (DITHEN = 1)

The register holds the capture in CCR4[19:4]. The CCR4[3:0] bits are reset.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>20</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM1_BDTR</name>
          <displayName>TIM1_BDTR</displayName>
          <description>TIM1 break and dead-time register</description>
          <addressOffset>0x044</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DTG</name>
              <description>Dead-time generator setup

This bit-field defines the duration of the dead-time inserted between the complementary outputs. DT correspond to this duration.

DTG[7:5]=0xx = DT=DTG[7:0]x tsubdtg/sub with tsubdtg/sub=tsubDTS/sub.

DTG[7:5]=10x = DT=(64+DTG[5:0])xtsubdtg/sub with Tsubdtg/sub=2xtsubDTS/sub.

DTG[7:5]=110 = DT=(32+DTG[4:0])xtsubdtg/sub with Tsubdtg/sub=8xtsubDTS/sub.

DTG[7:5]=111 = DT=(32+DTG[4:0])xtsubdtg/sub with Tsubdtg/sub=16xtsubDTS/sub.

Example if TsubDTS/sub=125ns (8MHz), dead-time possible values are:

0 to 15875 ns by 125 ns steps,

16 us to 31750 ns by 250 ns steps,

32 us to 63us by 1 us steps,

64 us to 126 us by 2 us steps

Note: This bit-field can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCK</name>
              <description>Lock configuration

These bits offer a write protection against software errors.

Note: The LOCK bits can be written only once after the reset. Once the TIMx_BDTR register has been written, their content is frozen until the next reset.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>LOCK OFF - No bit is write protected.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>LOCK Level 1 = DTG bits in TIMx_BDTR register, OISx and OISxN bits in TIMx_CR2 register and BKBID/BK2BID/BKE/BKP/AOE bits in TIMx_BDTR register can no longer be written.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>LOCK Level 2 = LOCK Level 1 + CC Polarity bits (CCxP/CCxNP bits in TIMx_CCER register, as long as the related channel is configured in output through the CCxS bits) as well as OSSR and OSSI bits can no longer be written.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>LOCK Level 3 = LOCK Level 2 + CC Control bits (OCxM and OCxPE bits in TIMx_CCMRx registers, as long as the related channel is configured in output through the CCxS bits) can no longer be written.</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OSSI</name>
              <description>Off-state selection for idle mode

This bit is used when MOE=0 due to a break event or by a software write, on channels configured as outputs.

See OC/OCN enable description for more details (Section 28.6.11: TIM1 capture/compare enable register (TIM1_CCER)).

Note: This bit can not be modified as soon as the LOCK level 2 has been programmed (LOCK bits in TIMx_BDTR register).</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>When inactive, OC/OCN outputs are disabled (the timer releases the output control which is taken over by the GPIO logic and which imposes a Hi-Z state).</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>When inactive, OC/OCN outputs are first forced with their inactive level then forced to their idle level after the deadtime. The timer maintains its control over the output.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OSSR</name>
              <description>Off-state selection for Run mode

This bit is used when MOE=1 on channels having a complementary output which are configured as outputs. OSSR is not implemented if no complementary output is implemented in the timer.

See OC/OCN enable description for more details (Section 28.6.11: TIM1 capture/compare enable register (TIM1_CCER)).

Note: This bit can not be modified as soon as the LOCK level 2 has been programmed (LOCK bits in TIMx_BDTR register).</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>When inactive, OC/OCN outputs are disabled (the timer releases the output control which is taken over by the GPIO logic, which forces a Hi-Z state).</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>When inactive, OC/OCN outputs are enabled with their inactive level as soon as CCxE=1 or CCxNE=1 (the output is still controlled by the timer).</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BKE</name>
              <description>Break enable

This bit enables the complete break protection (including all sources connected to bk_acth and BKIN sources, as per Figure 316: Break and Break2 circuitry overview).

Note: This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).

Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Break function disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Break function enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BKP</name>
              <description>Break polarity

Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).

Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Break input tim_brk is active low</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Break input tim_brk is active high</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AOE</name>
              <description>Automatic output enable

Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>MOE can be set only by software</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>MOE can be set by software or automatically at the next update event (if none of the break inputs tim_brk and tim_brk2 is active)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MOE</name>
              <description>Main output enable

This bit is cleared asynchronously by hardware as soon as one of the break inputs is active (tim_brk or tim_brk2). It is set by software or automatically depending on the AOE bit. It is acting only on the channels which are configured in output. 

In response to a break event or if MOE is written to 0: OC and OCN outputs are disabled or forced to idle state depending on the OSSI bit.

See OC/OCN enable description for more details (Section 28.6.11: TIM1 capture/compare enable register (TIM1_CCER)).</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>In response to a break 2 event. OC and OCN outputs are disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>OC and OCN outputs are enabled if their respective enable bits are set (CCxE, CCxNE in TIMx_CCER register).</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BKF</name>
              <description>Break filter

This bit-field defines the frequency used to sample tim_brk input and the length of the digital filter applied to tim_brk. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:

Note: This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No filter, tim_brk acts asynchronously</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>fsubSAMPLING/sub=fsubtim_ker_ck/sub, N=2</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>fsubSAMPLING/sub=fsubtim_ker_ck/sub, N=4</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>fsubSAMPLING/sub=fsubtim_ker_ck/sub, N=8</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/2, N=6</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/2, N=8</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x6</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/4, N=6</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/4, N=8</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x8</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/8, N=6</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x9</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/8, N=8</description>
                  <value>0x9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xA</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/16, N=5</description>
                  <value>0xA</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xB</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/16, N=6</description>
                  <value>0xB</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xC</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/16, N=8</description>
                  <value>0xC</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xD</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/32, N=5</description>
                  <value>0xD</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xE</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/32, N=6</description>
                  <value>0xE</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xF</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/32, N=8</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BK2F</name>
              <description>Break 2 filter

This bit-field defines the frequency used to sample tim_brk2 input and the length of the digital filter applied to tim_brk2. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:

Note: This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No filter, tim_brk2 acts asynchronously</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>fsubSAMPLING/sub=fsubtim_ker_ck/sub, N=2</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>fsubSAMPLING/sub=fsubtim_ker_ck/sub, N=4</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>fsubSAMPLING/sub=fsubtim_ker_ck/sub, N=8</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/2, N=6</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/2, N=8</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x6</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/4, N=6</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/4, N=8</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x8</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/8, N=6</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x9</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/8, N=8</description>
                  <value>0x9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xA</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/16, N=5</description>
                  <value>0xA</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xB</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/16, N=6</description>
                  <value>0xB</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xC</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/16, N=8</description>
                  <value>0xC</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xD</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/32, N=5</description>
                  <value>0xD</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xE</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/32, N=6</description>
                  <value>0xE</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xF</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/32, N=8</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BK2E</name>
              <description>Break 2 enable

This bit enables the complete break 2 protection (including all sources connected to bk_acth and BKIN sources, as per Figure 316: Break and Break2 circuitry overview).

Note: The BRKIN2 must only be used with OSSR = OSSI = 1.

Note: This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).

Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Break2 function disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Break2 function enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BK2P</name>
              <description>Break 2 polarity

Note: This bit cannot be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).

Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Break input tim_brk2 is active low</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Break input tim_brk2 is active high</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BKDSRM</name>
              <description>Break disarm

This bit is cleared by hardware when no break source is active.

The BKDSRM bit must be set by software to release the bidirectional output control (open-drain output in Hi-Z state) and then be polled it until it is reset by hardware, indicating that the fault condition has disappeared.

Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Break input tim_brk is armed</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Break input tim_brk is disarmed</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BK2DSRM</name>
              <description>Break2 disarm

Refer to BKDSRM description</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BKBID</name>
              <description>Break bidirectional

In the bidirectional mode (BKBID bit set to 1), the break input is configured both in input mode and in open drain output mode. Any active break event asserts a low logic level on the Break input to indicate an internal break event to external devices.

Note: This bit cannot be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).

Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Break input tim_brk in input mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Break input tim_brk in bidirectional mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BK2BID</name>
              <description>Break2 bidirectional

Refer to BKBID description</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM1_CCR5</name>
          <displayName>TIM1_CCR5</displayName>
          <description>TIM1 capture/compare register 5</description>
          <addressOffset>0x048</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CCR5</name>
              <description>Capture/compare 5 value

CCR5 is the value to be loaded in the actual capture/compare 5 register (preload value).

It is loaded permanently if the preload feature is not selected in the TIMx_CCMR3 register (bit OC5PE). Else the preload value is copied in the active capture/compare 5 register when an update event occurs.

The active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on tim_oc5 output.

Non-dithering mode (DITHEN = 0)

The register holds the compare value in CCR5[15:0]. The CCR5[19:16] bits are reset.

Dithering mode (DITHEN = 1)

The register holds the integer part in CCR5[19:4]. The CCR5[3:0] bitfield contains the dithered part.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>20</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GC5C1</name>
              <description>Group channel 5 and channel 1

Distortion on channel 1 output:

This bit can either have immediate effect or be preloaded and taken into account after an update event (if preload feature is selected in TIMxCCMR1).

Note: it is also possible to apply this distortion on combined PWM signals.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No effect of oc5ref on oc1refc</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>oc1refc is the logical AND of oc1ref and oc5ref</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>GC5C2</name>
              <description>Group channel 5 and channel 2

Distortion on channel 2 output:

This bit can either have immediate effect or be preloaded and taken into account after an update event (if preload feature is selected in TIMxCCMR1).

Note: it is also possible to apply this distortion on combined PWM signals.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No effect of tim_oc5ref on tim_oc2refc</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_oc2refc is the logical AND of tim_oc2ref and tim_oc5ref</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>GC5C3</name>
              <description>Group channel 5 and channel 3

Distortion on channel 3 output:

This bit can either have immediate effect or be preloaded and taken into account after an update event (if preload feature is selected in TIMxCCMR2).

Note: it is also possible to apply this distortion on combined PWM signals.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No effect of tim_oc5ref on tim_oc3refc</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_oc3refc is the logical AND of tim_oc3ref and tim_oc5ref</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM1_CCR6</name>
          <displayName>TIM1_CCR6</displayName>
          <description>TIM1 capture/compare register 6</description>
          <addressOffset>0x04C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CCR6</name>
              <description>Capture/compare 6 value

CCR6 is the value to be loaded in the actual capture/compare 6 register (preload value).

It is loaded permanently if the preload feature is not selected in the TIMx_CCMR3 register (bit OC6PE). Else the preload value is copied in the active capture/compare 6 register when an update event occurs.

The active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on tim_oc6 output.

Non-dithering mode (DITHEN = 0)

The register holds the compare value in CCR6[15:0]. The CCR6[19:16] bits are reset.

Dithering mode (DITHEN = 1)

The register holds the integer part in CCR6[19:4]. The CCR6[3:0] bitfield contains the dithered part.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>20</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM1_CCMR3</name>
          <displayName>TIM1_CCMR3</displayName>
          <description>TIM1 capture/compare mode register 3</description>
          <addressOffset>0x050</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OC5FE</name>
              <description>Output compare 5 fast enable</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OC5PE</name>
              <description>Output compare 5 preload enable</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OC5M</name>
              <description>OC5M[2:0]: Output compare 5 mode</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OC5CE</name>
              <description>Output compare 5 clear enable</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OC6FE</name>
              <description>Output compare 6 fast enable</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OC6PE</name>
              <description>Output compare 6 preload enable</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OC6M</name>
              <description>OC6M[2:0]: Output compare 6 mode</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OC6CE</name>
              <description>Output compare 6 clear enable</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OC5M_1</name>
              <description>OC5M[3]</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OC6M_1</name>
              <description>OC6M[3]</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM1_DTR2</name>
          <displayName>TIM1_DTR2</displayName>
          <description>TIM1 timer deadtime register 2</description>
          <addressOffset>0x054</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DTGF</name>
              <description>Dead-time falling edge generator setup

This bit-field defines the duration of the dead-time inserted between the complementary outputs, on the falling edge.

DTGF[7:5]=0xx = DTF=DTGF[7:0]x tsubdtg/sub with tsubdtg/sub=tsubDTS/sub.

DTGF[7:5]=10x = DTF=(64+DTGF[5:0])xtsubdtg/sub with Tsubdtg/sub=2xtsubDTS/sub.

DTGF[7:5]=110 = DTF=(32+DTGF[4:0])xtsubdtg/sub with Tsubdtg/sub=8xtsubDTS/sub.

DTGF[7:5]=111 = DTF=(32+DTGF[4:0])xtsubdtg/sub with Tsubdtg/sub=16xtsubDTS/sub.

Example if TsubDTS/sub=125ns (8MHz), dead-time possible values are:

0 to 15875 ns by 125 ns steps,

16 us to 31750 ns by 250 ns steps,

32 us to 63us by 1 us steps,

64 us to 126 us by 2 us steps

Note: This bit-field can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DTAE</name>
              <description>Deadtime asymmetric enable

Note: This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Deadtime on rising and falling edges are identical, and defined with DTG[7:0] register</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Deadtime on rising edge is defined with DTG[7:0] register and deadtime on falling edge is defined with DTGF[7:0] bits.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DTPE</name>
              <description>Deadtime preload enable

Note: This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Deadtime value is not preloaded</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Deadtime value preload is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM1_ECR</name>
          <displayName>TIM1_ECR</displayName>
          <description>TIM1 timer encoder control register</description>
          <addressOffset>0x058</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IE</name>
              <description>Index enable

This bit indicates if the Index event resets the counter.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Index disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Index enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IDIR</name>
              <description>Index direction

This bit indicates in which direction the Index event resets the counter.

Note: The IDR[1:0] bitfield must be written when IE bit is reset (index disabled).</description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Index resets the counter whatever the direction</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Index resets the counter when up-counting only</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>Index resets the counter when down-counting only</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IBLK</name>
              <description>Index blanking

This bit indicates if the Index event is conditioned by the tim_ti3 or tim_ti4 input</description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Index always active</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Index disabled when tim_ti3 input is active, as per CC3P bitfield</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>Index disabled when tim_ti4 input is active, as per CC4P bitfield</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FIDX</name>
              <description>First index 

This bit indicates if the first index only is taken into account</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Index is always active</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>the first Index only resets the counter</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IPOS</name>
              <description>Index positioning

In quadrature encoder mode (SMS[3:0] = 0001, 0010, 0011, 1110, 1111), this bit indicates in which AB input configuration the Index event resets the counter.

In directional clock mode or clock plus direction mode (SMS[3:0] = 1010, 1011, 1100, 1101), these bits indicates on which level the Index event resets the counter. In bidirectional clock mode, this applies for both clock inputs.

x0: Index resets the counter when clock is 0

x1: Index resets the counter when clock is 1

Note: IPOS[1] bit is not significant</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Index resets the counter when AB = 00</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Index resets the counter when AB = 01</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>Index resets the counter when AB = 10</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>Index resets the counter when AB = 11</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PW</name>
              <description>Pulse width

This bitfield defines the pulse duration, as following:

tsubPW/sub = PW[7:0] x tsubPWG/sub</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWPRSC</name>
              <description>Pulse width prescaler

This bitfield sets the clock prescaler for the pulse generator, as following:

tsubPWG/sub = (2sup(PWPRSC[2:0])/sup) x tsubtim_ker_ck/sub</description>
              <bitOffset>24</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM1_TISEL</name>
          <displayName>TIM1_TISEL</displayName>
          <description>TIM1 timer input selection register</description>
          <addressOffset>0x05C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TI1SEL</name>
              <description>Selects tim_ti1[15:0] input

...

Refer to Section 28.3.2: TIM1 pins and internal signals for interconnects list.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>tim_ti1_in0: TIMx_CH1</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_ti1_in1</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xF</name>
                  <description>tim_ti1_in15</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TI2SEL</name>
              <description>Selects tim_ti2[15:0] input

...

Refer to Section 28.3.2: TIM1 pins and internal signals for interconnects list.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>tim_ti2_in0: TIMx_CH2</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_ti2_in1</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xF</name>
                  <description>tim_ti2_in15</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TI3SEL</name>
              <description>Selects tim_ti3[15:0] input

...

Refer to Section 28.3.2: TIM1 pins and internal signals for interconnects list.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>tim_ti3_in0: TIMx_CH2</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_ti3_in1</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xF</name>
                  <description>tim_ti3_in15</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TI4SEL</name>
              <description>Selects tim_ti4[15:0] input

...

Refer to Section 28.3.2: TIM1 pins and internal signals for interconnects list.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>tim_ti4_in0: TIMx_CH4</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_ti4_in1</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xF</name>
                  <description>tim_ti4_in15</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM1_AF1</name>
          <displayName>TIM1_AF1</displayName>
          <description>TIM1 alternate function option register 1</description>
          <addressOffset>0x060</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BKINE</name>
              <description>TIMx_BKIN input enable

This bit enables the TIMx_BKIN alternate function input for the timer's tim_brk input. TIMx_BKIN input is 'ORed' with the other tim_brk sources.

Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>TIMx_BKIN input disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>TIMx_BKIN input enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BKCMP1E</name>
              <description>tim_brk_cmp1 enable

This bit enables the tim_brk_cmp1 for the timer's tim_brk input. tim_brk_cmp1 output is 'ORed' with the other tim_brk sources.

Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>tim_brk_cmp1 input disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_brk_cmp1 input enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BKCMP2E</name>
              <description>tim_brk_cmp2 enable

This bit enables the tim_brk_cmp2 for the timer's tim_brk input. tim_brk_cmp2 output is 'ORed' with the other tim_brk sources.

Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>tim_brk_cmp2 input disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_brk_cmp2 input enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BKCMP3E</name>
              <description>tim_brk_cmp3 enable

This bit enables the tim_brk_cmp3 for the timer's tim_brk input. tim_brk_cmp3 output is 'ORed' with the other tim_brk sources.

Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>tim_brk_cmp3 input disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_brk_cmp3 input enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BKCMP4E</name>
              <description>tim_brk_cmp4 enable

This bit enables the tim_brk_cmp4 for the timer's tim_brk input. tim_brk_cmp4 output is 'ORed' with the other tim_brk sources.

Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>tim_brk_cmp4 input disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_brk_cmp4 input enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BKCMP5E</name>
              <description>tim_brk_cmp5 enable

This bit enables the tim_brk_cmp5 for the timer's tim_brk input. tim_brk_cmp5 output is 'ORed' with the other tim_brk sources.

Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>tim_brk_cmp5 input disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_brk_cmp5 input enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BKCMP6E</name>
              <description>tim_brk_cmp6 enable

This bit enables the tim_brk_cmp6 for the timer's tim_brk input. tim_brk_cmp6 output is 'ORed' with the other tim_brk sources.

Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>tim_brk_cmp6 input disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_brk_cmp6 input enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BKCMP7E</name>
              <description>tim_brk_cmp7 enable

This bit enables the tim_brk_cmp7 for the timer's tim_brk input. tim_brk_cmp7 output is 'ORed' with the other tim_brk sources.

Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>tim_brk_cmp7 input disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_brk_cmp7 input enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BKCMP8E</name>
              <description>tim_brk_cmp8 enable

This bit enables the tim_brk_cmp8 for the timer's tim_brk input. tim_brk_cmp8 output is 'ORed' with the other tim_brk sources.

Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>tim_brk_cmp8 input disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_brk_cmp8 input enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BKINP</name>
              <description>TIMx_BKIN input polarity

This bit selects the TIMx_BKIN alternate function input sensitivity. It must be programmed together with the BKP polarity bit.

Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>TIMx_BKIN input polarity is not inverted (active low if BKP = 0, active high if BKP = 1)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>TIMx_BKIN input polarity is inverted (active high if BKP = 0, active low if BKP = 1)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BKCMP1P</name>
              <description>tim_brk_cmp1 input polarity

This bit selects the tim_brk_cmp1 input sensitivity. It must be programmed together with the BKP polarity bit.

Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>tim_brk_cmp1 input polarity is not inverted (active low if BKP = 0, active high if BKP = 1)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_brk_cmp1 input polarity is inverted (active high if BKP = 0, active low if BKP = 1)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BKCMP2P</name>
              <description>tim_brk_cmp2 input polarity

This bit selects the tim_brk_cmp2 input sensitivity. It must be programmed together with the BKP polarity bit.

Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>tim_brk_cmp2 input polarity is not inverted (active low if BKP = 0, active high if BKP = 1)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_brk_cmp2 input polarity is inverted (active high if BKP = 0, active low if BKP = 1)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BKCMP3P</name>
              <description>tim_brk_cmp3 input polarity

This bit selects the tim_brk_cmp3 input sensitivity. It must be programmed together with the BKP polarity bit.

Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>tim_brk_cmp3 input polarity is not inverted (active low if BKP = 0, active high if BKP = 1)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_brk_cmp3 input polarity is inverted (active high if BKP = 0, active low if BKP = 1)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BKCMP4P</name>
              <description>tim_brk_cmp4 input polarity

This bit selects the tim_brk_cmp4 input sensitivity. It must be programmed together with the BKP polarity bit.

Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>tim_brk_cmp4 input polarity is not inverted (active low if BKP = 0, active high if BKP = 1)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_brk_cmp4 input polarity is inverted (active high if BKP = 0, active low if BKP = 1)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ETRSEL</name>
              <description>etr_in source selection

These bits select the etr_in input source.

...

Refer to Section 28.3.2: TIM1 pins and internal signals for product specific implementation.

Note: These bits can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
              <bitOffset>14</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>tim_etr0: TIMx_ETR input</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_etr1</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xF</name>
                  <description>tim_etr15</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM1_AF2</name>
          <displayName>TIM1_AF2</displayName>
          <description>TIM1 alternate function register 2</description>
          <addressOffset>0x064</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BK2INE</name>
              <description>TIMx_BKIN2 input enable

This bit enables the TIMx_BKIN2 alternate function input for the timer's tim_brk2 input. TIMx_BKIN2 input is 'ORed' with the other tim_brk2 sources.

Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>TIMx_BKIN2 input disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>TIMx_BKIN2 input enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BK2CMP1E</name>
              <description>tim_brk2_cmp1 enable

This bit enables the tim_brk2_cmp1 for the timer's tim_brk2 input. tim_brk2_cmp1 output is 'ORed' with the other tim_brk2 sources.

Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>tim_brk2_cmp1 input disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_brk2_cmp1 input enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BK2CMP2E</name>
              <description>tim_brk2_cmp2 enable

This bit enables the tim_brk2_cmp2 for the timer's tim_brk2 input. tim_brk2_cmp2 output is 'ORed' with the other tim_brk2 sources.

Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>tim_brk2_cmp2 input disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_brk2_cmp2 input enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BK2CMP3E</name>
              <description>tim_brk2_cmp3 enable

This bit enables the tim_brk2_cmp3 for the timer's tim_brk2 input. tim_brk2_cmp3 output is 'ORed' with the other tim_brk2 sources.

Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>tim_brk2_cmp3 input disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_brk2_cmp3 input enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BK2CMP4E</name>
              <description>tim_brk2_cmp4 enable

This bit enables the tim_brk2_cmp4 for the timer's tim_brk2 input. tim_brk2_cmp4 output is 'ORed' with the other tim_brk2 sources.

Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>tim_brk2_cmp4 input disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_brk2_cmp4 input enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BK2CMP5E</name>
              <description>tim_brk2_cmp5 enable

This bit enables the tim_brk2_cmp5 for the timer's tim_brk2 input. tim_brk2_cmp5 output is 'ORed' with the other tim_brk2 sources.

Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>tim_brk2_cmp5 input disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_brk2_cmp5 input enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BK2CMP6E</name>
              <description>tim_brk2_cmp6 enable

This bit enables the tim_brk2_cmp6 for the timer's tim_brk2 input. tim_brk2_cmp6 output is 'ORed' with the other tim_brk2 sources.

Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>tim_brk2_cmp6 input disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_brk2_cmp6 input enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BK2CMP7E</name>
              <description>tim_brk2_cmp7 enable

This bit enables the tim_brk2_cmp7 for the timer's tim_brk2 input. tim_brk2_cmp7 output is 'ORed' with the other tim_brk2 sources.

Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>tim_brk2_cmp7 input disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_brk2_cmp7 input enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BK2CMP8E</name>
              <description>tim_brk2_cmp8 enable

This bit enables the tim_brk2_cmp8 for the timer's tim_brk2 input. tim_brk2_cmp8 output is 'ORed' with the other tim_brk2 sources.

Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>tim_brk2_cmp8 input disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_brk2_cmp8 input enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BK2INP</name>
              <description>TIMx_BKIN2 input polarity

This bit selects the TIMx_BKIN2 alternate function input sensitivity. It must be programmed together with the BK2P polarity bit.

Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>TIMx_BKIN2 input polarity is not inverted (active low if BK2P = 0, active high if BK2P = 1)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>TIMx_BKIN2 input polarity is inverted (active high if BK2P = 0, active low if BK2P = 1)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BK2CMP1P</name>
              <description>tim_brk2_cmp1 input polarity

This bit selects the tim_brk2_cmp1 input sensitivity. It must be programmed together with the BK2P polarity bit.

Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>tim_brk2_cmp1 input polarity is not inverted (active low if BK2P = 0, active high if BK2P = 1)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_brk2_cmp1 input polarity is inverted (active high if BK2P = 0, active low if BK2P = 1)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BK2CMP2P</name>
              <description>tim_brk2_cmp2 input polarity

This bit selects the tim_brk2_cmp2 input sensitivity. It must be programmed together with the BK2P polarity bit.

Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>tim_brk2_cmp2 input polarity is not inverted (active low if BK2P = 0, active high if BK2P = 1)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_brk2_cmp2 input polarity is inverted (active high if BK2P = 0, active low if BK2P = 1)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BK2CMP3P</name>
              <description>tim_brk2_cmp3 input polarity

This bit selects the tim_brk2_cmp3 input sensitivity. It must be programmed together with the BK2P polarity bit.

Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>tim_brk2_cmp3 input polarity is not inverted (active low if BK2P = 0, active high if BK2P = 1)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_brk2_cmp3 input polarity is inverted (active high if BK2P = 0, active low if BK2P = 1)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BK2CMP4P</name>
              <description>tim_brk2_cmp4 input polarity

This bit selects the tim_brk2_cmp4 input sensitivity. It must be programmed together with the BK2P polarity bit.

Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>tim_brk2_cmp4 input polarity is not inverted (active low if BK2P = 0, active high if BK2P = 1)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_brk2_cmp4 input polarity is inverted (active high if BK2P = 0, active low if BK2P = 1)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OCRSEL</name>
              <description>ocref_clr source selection

These bits select the ocref_clr input source.

...

Refer to Section 28.3.2: TIM1 pins and internal signals for product specific information.

Note: These bits can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>tim_ocref_clr0</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_ocref_clr1</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7</name>
                  <description>tim_ocref_clr7</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM1_DCR</name>
          <displayName>TIM1_DCR</displayName>
          <description>TIM1 DMA control register</description>
          <addressOffset>0x3DC</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DBA</name>
              <description>DMA base address

This 5-bits vector defines the base-address for DMA transfers (when read/write access are done through the TIMx_DMAR address). DBA is defined as an offset starting from the address of the TIMx_CR1 register.

Example:

...</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>TIMx_CR1</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>TIMx_CR2</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>TIMx_SMCR</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DBL</name>
              <description>DMA burst length

This 5-bit vector defines the length of DMA transfers (the timer recognizes a burst transfer when a read or a write access is done to the TIMx_DMAR address), i.e. the number of transfers. Transfers can be in half-words or in bytes (see example below).

...

Example: Let us consider the following transfer: DBL = 7 bytes &amp; DBA = TIM2_CR1.

If DBL = 7 bytes and DBA = TIM2_CR1 represents the address of the byte to be transferred, the address of the transfer should be given by the following equation:

(TIMx_CR1 address) + DBA + (DMA index), where DMA index = DBL

In this example, 7 bytes are added to (TIMx_CR1 address) + DBA, which gives us the address from/to which the data are copied. In this case, the transfer is done to 7 registers starting from the following address: (TIMx_CR1 address) + DBA

According to the configuration of the DMA Data Size, several cases may occur:

If the DMA Data Size is configured in half-words, 16-bit data are transferred to each of the 7 registers.

If the DMA Data Size is configured in bytes, the data are also transferred to 7 registers: the first register contains the first MSB byte, the second register, the first LSB byte and so on. So with the transfer Timer, one also has to specify the size of data transferred by DMA.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>1 transfer</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>2 transfers</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>3 transfers</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1A</name>
                  <description>26 transfers</description>
                  <value>0x1A</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DBSS</name>
              <description>DMA burst source selection

This bitfield defines the interrupt source that triggers the DMA burst transfers (the timer recognizes a burst transfer when a read or a write access is done to the TIMx_DMAR address).

Others: reserved</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Update</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>CC1</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>CC2</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>CC3</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>CC4</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x6</name>
                  <description>COM</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7</name>
                  <description>Trigger</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM1_DMAR</name>
          <displayName>TIM1_DMAR</displayName>
          <description>TIM1 DMA address for full transfer</description>
          <addressOffset>0x3E0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMAB</name>
              <description>DMA register for burst accesses

A read or write operation to the DMAR register accesses the register located at the address (TIMx_CR1 address) + (DBA + DMA index) x 4 

where TIMx_CR1 address is the address of the control register 1, DBA is the DMA base address configured in TIMx_DCR register, DMA index is automatically controlled by the DMA transfer, and ranges from 0 to DBL (DBL configured in TIMx_DCR).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>TIM2</name>
      <description>TIM2 address block description</description>
      <groupName>TIM2</groupName>
      <baseAddress>0x40000000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x3E4</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>TIM2</name>
        <description>TIM2 global interrupt</description>
        <value>41</value>
      </interrupt>
      <registers>
        <register>
          <name>TIM2_CR1</name>
          <displayName>TIM2_CR1</displayName>
          <description>TIM2 control register 1</description>
          <addressOffset>0x000</addressOffset>
          <size>16</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>CEN</name>
              <description>Counter enable

Note: External clock, gated mode and encoder mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware. 

CEN is cleared automatically in one-pulse mode, when an update event occurs.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Counter disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Counter enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UDIS</name>
              <description>Update disable

This bit is set and cleared by software to enable/disable UEV event generation.

Counter overflow/underflow

Setting the UG bit

Update generation through the slave mode controller

Buffered registers are then loaded with their preload values.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>UEV enabled. The Update (UEV) event is generated by one of the following events:</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC, CCRx). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>URS</name>
              <description>Update request source

This bit is set and cleared by software to select the UEV event sources.

Counter overflow/underflow

Setting the UG bit

Update generation through the slave mode controller</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Any of the following events generate an update interrupt or DMA request if enabled. These events can be:</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Only counter overflow/underflow generates an update interrupt or DMA request if enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OPM</name>
              <description>One-pulse mode</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Counter is not stopped at update event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Counter stops counting at the next update event (clearing the bit CEN)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIR</name>
              <description>Direction

Note: This bit is read only when the timer is configured in Center-aligned mode or Encoder mode.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Counter used as upcounter</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Counter used as downcounter</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMS</name>
              <description>Center-aligned mode selection

Note: It is not allowed to switch from edge-aligned mode to center-aligned mode as long as the counter is enabled (CEN=1)</description>
              <bitOffset>5</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Edge-aligned mode. The counter counts up or down depending on the direction bit (DIR).</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Center-aligned mode 1. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set only when the counter is counting down.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>Center-aligned mode 2. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set only when the counter is counting up.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>Center-aligned mode 3. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set both when the counter is counting up or down.</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ARPE</name>
              <description>Auto-reload preload enable</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>TIMx_ARR register is not buffered</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>TIMx_ARR register is buffered</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CKD</name>
              <description>Clock division

This bit-field indicates the division ratio between the timer clock (tim_ker_ck) frequency and sampling clock used by the digital filters (tim_etr_in, tim_tix),</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>tsubDTS/sub = tsubtim_ker_ck/sub</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tsubDTS/sub = 2  tsubtim_ker_ck/sub</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>tsubDTS/sub = 4  tsubtim_ker_ck/sub</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UIFREMAP</name>
              <description>UIF status bit remapping</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No remapping. UIF status bit is not copied to TIMx_CNT register bit 31.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Remapping enabled. UIF status bit is copied to TIMx_CNT register bit 31.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DITHEN</name>
              <description>Dithering Enable

Note: The DITHEN bit can only be modified when CEN bit is reset.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Dithering disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Dithering enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM2_CR2</name>
          <displayName>TIM2_CR2</displayName>
          <description>TIM2 control register 2</description>
          <addressOffset>0x004</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CCDS</name>
              <description>Capture/compare DMA selection</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>CCx DMA request sent when CCx event occurs</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>CCx DMA requests sent when update event occurs</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MMS</name>
              <description>MMS[0]: Master mode selection

These bits allow to select the information to be sent in master mode to slave timers for synchronization (tim_trgo). The combination is as follows:

When the Counter Enable signal is controlled by the trigger input, there is a delay on tim_trgo, except if the master/slave mode is selected (see the MSM bit description in TIMx_SMCR register).

Others: Reserved

Note: The clock of the slave timer or ADC must be enabled prior to receive events from the master timer, and must not be changed on-the-fly while triggers are received from the master timer.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Reset - the UG bit from the TIMx_EGR register is used as trigger output (tim_trgo). If the reset is generated by the trigger input (slave mode controller configured in reset mode) then the signal on tim_trgo is delayed compared to the actual reset.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Enable - the Counter enable signal, CNT_EN, is used as trigger output (tim_trgo). It is useful to start several timers at the same time or to control a window in which a slave timer is enabled. The Counter Enable signal is generated by a logic AND between CEN control bit and the trigger input when configured in gated mode.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>Update - The update event is selected as trigger output (tim_trgo). For instance a master timer can then be used as a prescaler for a slave timer.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>Compare Pulse - The trigger output send a positive pulse when the CC1IF flag is to be set (even if it was already high), as soon as a capture or a compare match occurred (tim_trgo).</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>Compare - tim_oc1refc signal is used as trigger output (tim_trgo)</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>Compare - tim_oc2refc signal is used as trigger output (tim_trgo)</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x6</name>
                  <description>Compare - tim_oc3refc signal is used as trigger output (tim_trgo)</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7</name>
                  <description>Compare - tim_oc4refc signal is used as trigger output (tim_trgo)</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TI1S</name>
              <description>tim_ti1 selection</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>The tim_ti1_in[15:0] multiplexer output is to tim_ti1 input</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The tim_ti1_in[15:0], tim_ti2_in[15:0] and tim_ti3_in[15:0] multiplexers outputs are XORed and connected to the tim_ti1 input. See also Section 42.3.25: Interfacing with Hall sensors on page 1483.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MMS_1</name>
              <description>MMS[3]</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM2_SMCR</name>
          <displayName>TIM2_SMCR</displayName>
          <description>TIM2 slave mode control register</description>
          <addressOffset>0x008</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SMS</name>
              <description>SMS[0]: Slave mode selection

When external signals are selected the active edge of the trigger signal (tim_trgi) is linked to the polarity selected on the external input (see Input Control register and Control Register description.

Note: The gated mode must not be used if tim_ti1f_ed is selected as the trigger input (TS=00100). Indeed, tim_ti1f_ed outputs 1 pulse for each transition on tim_ti1f, whereas the gated mode checks the level of the trigger signal.

Note: The clock of the slave peripherals (timer, ADC, ...) receiving the tim_trgo signal must be enabled prior to receive events from the master timer, and the clock frequency (prescaler) must not be changed on-the-fly while triggers are received from the master timer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Slave mode disabled - if CEN = '1 then the prescaler is clocked directly by the internal clock.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Encoder mode 1 - Counter counts up/down on tim_ti1fp1 edge depending on tim_ti2fp2 level.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>Encoder mode 2 - Counter counts up/down on tim_ti2fp2 edge depending on tim_ti1fp1 level.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>Encoder mode 3 - Counter counts up/down on both tim_ti1fp1 and tim_ti2fp2 edges depending on the level of the other input.</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>Reset Mode - Rising edge of the selected trigger input (tim_trgi) reinitializes the counter and generates an update of the registers.</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>Gated Mode - The counter clock is enabled when the trigger input (tim_trgi) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled.</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x6</name>
                  <description>Trigger Mode - The counter starts at a rising edge of the trigger tim_trgi (but it is not reset). Only the start of the counter is controlled.</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7</name>
                  <description>External Clock Mode 1 - Rising edges of the selected trigger (tim_trgi) clock the counter.</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OCCS</name>
              <description>OCREF clear selection

This bit is used to select the OCREF clear source

Note: If the OCREF clear selection feature is not supported, this bit is reserved and forced by hardware to '0'. Section 29.3: TIM2/TIM3 implementation.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>tim_ocref_clr_int is connected to the tim_ocref_clr input</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_ocref_clr_int is connected to tim_etrf</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TS</name>
              <description>TS[0]: Trigger selection

This bit-field selects the trigger input to be used to synchronize the counter.

Others: Reserved

See Section 29.4.2: TIM2/TIM3 pins and internal signals for product specific implementation details.

Note: These bits must be changed only when they are not used (e.g. when SMS=000) to avoid wrong edge detections at the transition.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Internal trigger 0 (tim_itr0)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Internal trigger 1 (tim_itr1)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>Internal trigger 2 (tim_itr2)</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>Internal trigger 3 (tim_itr3)</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>tim_ti1 edge detector (tim_ti1f_ed)</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>Filtered timer input 1 (tim_ti1fp1)</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x6</name>
                  <description>Filtered timer input 2 (tim_ti2fp2)</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7</name>
                  <description>External trigger input (tim_etrf)</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MSM</name>
              <description>Master/Slave mode</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The effect of an event on the trigger input (tim_trgi) is delayed to allow a perfect synchronization between the current timer and its slaves (through tim_trgo). It is useful if we want to synchronize several timers on a single external event.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ETF</name>
              <description>External trigger filter

This bit-field then defines the frequency used to sample tim_etrp signal and the length of the digital filter applied to tim_etrp. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No filter, sampling is done at fsubDTS/sub</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>fsubSAMPLING/sub=fsubtim_ker_ck/sub, N=2</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>fsubSAMPLING/sub=fsubtim_ker_ck/sub, N=4</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>fsubSAMPLING/sub=fsubtim_ker_ck/sub, N=8</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/2, N=6</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/2, N=8</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x6</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/4, N=6</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/4, N=8</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x8</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/8, N=6</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x9</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/8, N=8</description>
                  <value>0x9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xA</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/16, N=5</description>
                  <value>0xA</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xB</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/16, N=6</description>
                  <value>0xB</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xC</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/16, N=8</description>
                  <value>0xC</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xD</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/32, N=5</description>
                  <value>0xD</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xE</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/32, N=6</description>
                  <value>0xE</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xF</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/32, N=8</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ETPS</name>
              <description>External trigger prescaler

External trigger signal tim_etrp frequency must be at most 1/4 of tim_ker_ck frequency. A prescaler can be enabled to reduce tim_etrp frequency. It is useful when inputting fast external clocks on tim_etr_in.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Prescaler OFF</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_etrp frequency divided by 2</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>tim_etrp frequency divided by 4</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>tim_etrp frequency divided by 8</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ECE</name>
              <description>External clock enable

This bit enables External clock mode 2.

Setting the ECE bit has the same effect as selecting external clock mode 1 with tim_trgi connected to tim_etrf (SMS=111 and TS=00111).

It is possible to simultaneously use external clock mode 2 with the following slave modes: reset mode, gated mode and trigger mode. Nevertheless, tim_trgi must not be connected to tim_etrf in this case (TS bits must not be 00111).

Note: If external clock mode 1 and external clock mode 2 are enabled at the same time, the external clock input is tim_etrf.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>External clock mode 2 disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>External clock mode 2 enabled. The counter is clocked by any active edge on the tim_etrf signal.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ETP</name>
              <description>External trigger polarity

This bit selects whether tim_etr_in or tim_etr_in is used for trigger operations</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>tim_etr_in is non-inverted, active at high level or rising edge</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_etr_in is inverted, active at low level or falling edge</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SMS_1</name>
              <description>SMS[3]</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TS_1</name>
              <description>TS[4:3]</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SMSPE</name>
              <description>SMS preload enable

This bit selects whether the SMS[3:0] bitfield is preloaded</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>SMS[3:0] bitfield is not preloaded</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>SMS[3:0] preload is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SMSPS</name>
              <description>SMS preload source

This bit selects whether the events that triggers the SMS[3:0] bitfield transfer from preload to active</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>The transfer is triggered by the Timer's Update event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The transfer is triggered by the Index event</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM2_DIER</name>
          <displayName>TIM2_DIER</displayName>
          <description>TIM2 DMA/Interrupt enable register</description>
          <addressOffset>0x00C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>UIE</name>
              <description>Update interrupt enable</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Update interrupt disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Update interrupt enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CC1IE</name>
              <description>Capture/Compare 1 interrupt enable</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>CC1 interrupt disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>CC1 interrupt enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CC2IE</name>
              <description>Capture/Compare 2 interrupt enable</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>CC2 interrupt disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>CC2 interrupt enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CC3IE</name>
              <description>Capture/Compare 3 interrupt enable</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>CC3 interrupt disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>CC3 interrupt enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CC4IE</name>
              <description>Capture/Compare 4 interrupt enable</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>CC4 interrupt disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>CC4 interrupt enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TIE</name>
              <description>Trigger interrupt enable</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Trigger interrupt disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Trigger interrupt enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UDE</name>
              <description>Update DMA request enable</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Update DMA request disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Update DMA request enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CC1DE</name>
              <description>Capture/Compare 1 DMA request enable</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>CC1 DMA request disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>CC1 DMA request enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CC2DE</name>
              <description>Capture/Compare 2 DMA request enable</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>CC2 DMA request disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>CC2 DMA request enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CC3DE</name>
              <description>Capture/Compare 3 DMA request enable</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>CC3 DMA request disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>CC3 DMA request enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CC4DE</name>
              <description>Capture/Compare 4 DMA request enable</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>CC4 DMA request disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>CC4 DMA request enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TDE</name>
              <description>Trigger DMA request enable</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Trigger DMA request disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Trigger DMA request enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IDXIE</name>
              <description>Index interrupt enable</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Index interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Index interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIRIE</name>
              <description>Direction change interrupt enable</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Direction change interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Direction change interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IERRIE</name>
              <description>Index error interrupt enable</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Index error interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Index error interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TERRIE</name>
              <description>Transition error interrupt enable</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Transition error interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Transition error interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM2_SR</name>
          <displayName>TIM2_SR</displayName>
          <description>TIM2 status register</description>
          <addressOffset>0x010</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>UIF</name>
              <description>Update interrupt flag

This bit is set by hardware on an update event. It is cleared by software.

At overflow or underflow and if UDIS=0 in the TIMx_CR1 register.

When CNT is reinitialized by software using the UG bit in TIMx_EGR register, if URS=0 and UDIS=0 in the TIMx_CR1 register.

When CNT is reinitialized by a trigger event (refer to the synchro control register description), if URS=0 and UDIS=0 in the TIMx_CR1 register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No update occurred</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Update interrupt pending. This bit is set by hardware when the registers are updated:</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CC1IF</name>
              <description>Capture/compare 1 interrupt flag

This flag is set by hardware. It is cleared by software (input capture or output compare mode) or by reading the TIMx_CCR1 register (input capture mode only).

If channel CC1 is configured as output: this flag is set when the content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. When the content of TIMx_CCR1 is greater than the content of TIMx_ARR, the CC1IF bit goes high on the counter overflow (in up-counting and up/down-counting modes) or underflow (in downcounting mode). There are 3 possible options for flag setting in center-aligned mode, refer to the CMS bits in the TIMx_CR1 register for the full description.

If channel CC1 is configured as input: this bit is set when counter value has been captured in TIMx_CCR1 register (an edge has been detected on IC1, as per the edge sensitivity defined with the CC1P and CC1NP bits setting, in TIMx_CCER).</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No compare match / No input capture occurred</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>A compare match or an input capture occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CC2IF</name>
              <description>Capture/Compare 2 interrupt flag

Refer to CC1IF description</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CC3IF</name>
              <description>Capture/Compare 3 interrupt flag

Refer to CC1IF description</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CC4IF</name>
              <description>Capture/Compare 4 interrupt flag

Refer to CC1IF description</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TIF</name>
              <description>Trigger interrupt flag

This flag is set by hardware on the TRG trigger event (active edge detected on tim_trgi input when the slave mode controller is enabled in all modes but gated mode. It is set when the counter starts or stops when gated mode is selected. It is cleared by software.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No trigger event occurred.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Trigger interrupt pending.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CC1OF</name>
              <description>Capture/Compare 1 overcapture flag

This flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing it to '0'.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No overcapture has been detected.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The counter value has been captured in TIMx_CCR1 register while CC1IF flag was already set</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CC2OF</name>
              <description>Capture/compare 2 overcapture flag

refer to CC1OF description</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CC3OF</name>
              <description>Capture/Compare 3 overcapture flag

refer to CC1OF description</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CC4OF</name>
              <description>Capture/Compare 4 overcapture flag

refer to CC1OF description</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IDXF</name>
              <description>Index interrupt flag

This flag is set by hardware when an index event is detected. It is cleared by software by

writing it to '0'.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No index event occurred.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>An index event has occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIRF</name>
              <description>Direction change interrupt flag

This flag is set by hardware when the direction changes in encoder mode (DIR bit value in

TIMx_CR is changing). It is cleared by software by writing it to '0'.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No direction change</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Direction change</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IERRF</name>
              <description>Index error interrupt flag

This flag is set by hardware when an index error is detected. It is cleared by software by

writing it to '0'.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No index error has been detected.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>An index error has been detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TERRF</name>
              <description>Transition error interrupt flag

This flag is set by hardware when a transition error is detected in encoder mode. It is cleared

by software by writing it to '0'.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No encoder transition error has been detected.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>An encoder transition error has been detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM2_EGR</name>
          <displayName>TIM2_EGR</displayName>
          <description>TIM2 event generation register</description>
          <addressOffset>0x014</addressOffset>
          <size>16</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>UG</name>
              <description>Update generation

This bit can be set by software, it is automatically cleared by hardware.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Re-initialize the counter and generates an update of the registers. Note that the prescaler counter is cleared too (anyway the prescaler ratio is not affected). The counter is cleared if the center-aligned mode is selected or if DIR=0 (upcounting), else it takes the auto-reload value (TIMx_ARR) if DIR=1 (downcounting).</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CC1G</name>
              <description>Capture/compare 1 generation

This bit is set by software in order to generate an event, it is automatically cleared by hardware.

If channel CC1 is configured as output:

CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled.

If channel CC1 is configured as input:

The current value of the counter is captured in TIMx_CCR1 register. The CC1IF flag is set, the corresponding interrupt or DMA request is sent if enabled. The CC1OF flag is set if the CC1IF flag was already high.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>A capture/compare event is generated on channel 1:</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CC2G</name>
              <description>Capture/compare 2 generation

Refer to CC1G description</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CC3G</name>
              <description>Capture/compare 3 generation

Refer to CC1G description</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CC4G</name>
              <description>Capture/compare 4 generation

Refer to CC1G description</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>TG</name>
              <description>Trigger generation

This bit is set by software in order to generate an event, it is automatically cleared by hardware.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The TIF flag is set in TIMx_SR register. Related interrupt or DMA transfer can occur if enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM2_CCMR1</name>
          <displayName>TIM2_CCMR1</displayName>
          <description>TIM2 capture/compare mode register 1 [alternate]</description>
          <addressOffset>0x018</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CC1S</name>
              <description>Capture/Compare 1 selection

This bit-field defines the direction of the channel (input/output) as well as the used input. 

Note: CC1S bits are writable only when the channel is OFF (CC1E = 0 in TIMx_CCER).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>CC1 channel is configured as output</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>CC1 channel is configured as input, tim_ic1 is mapped on tim_ti1</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>CC1 channel is configured as input, tim_ic1 is mapped on tim_ti2</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>CC1 channel is configured as input, tim_ic1 is mapped on tim_trc. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IC1PSC</name>
              <description>Input capture 1 prescaler

This bit-field defines the ratio of the prescaler acting on CC1 input (tim_ic1). The prescaler is reset as soon as CC1E=0 (TIMx_CCER register).</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no prescaler, capture is done each time an edge is detected on the capture input</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>capture is done once every 2 events</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>capture is done once every 4 events</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>capture is done once every 8 events</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IC1F</name>
              <description>Input capture 1 filter

This bit-field defines the frequency used to sample tim_ti1 input and the length of the digital filter applied to tim_ti1. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No filter, sampling is done at fsubDTS/sub</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>fsubSAMPLING/sub=fsubtim_ker_ck/sub, N=2</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>fsubSAMPLING/sub=fsubtim_ker_ck/sub, N=4</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>fsubSAMPLING/sub=fsubtim_ker_ck/sub, N=8</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/2, N=6</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/2, N=8</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x6</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/4, N=6</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/4, N=8</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x8</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/8, N=6</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x9</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/8, N=8</description>
                  <value>0x9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xA</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/16, N=5</description>
                  <value>0xA</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xB</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/16, N=6</description>
                  <value>0xB</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xC</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/16, N=8</description>
                  <value>0xC</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xD</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/32, N=5</description>
                  <value>0xD</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xE</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/32, N=6</description>
                  <value>0xE</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xF</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/32, N=8</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CC2S</name>
              <description>Capture/compare 2 selection

This bit-field defines the direction of the channel (input/output) as well as the used input. 

Note: CC2S bits are writable only when the channel is OFF (CC2E = 0 in TIMx_CCER).</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>CC2 channel is configured as output.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>CC2 channel is configured as input, tim_ic2 is mapped on tim_ti2.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>CC2 channel is configured as input, tim_ic2 is mapped on tim_ti1.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>CC2 channel is configured as input, tim_ic2 is mapped on tim_trc. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IC2PSC</name>
              <description>Input capture 2 prescaler</description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IC2F</name>
              <description>Input capture 2 filter</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM2_CCMR1_ALTERNATE</name>
          <displayName>TIM2_CCMR1_ALTERNATE</displayName>
          <description>TIM2 capture/compare mode register 1 [alternate]</description>
          <alternateRegister>TIM2_CCMR1</alternateRegister>
          <addressOffset>0x018</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CC1S</name>
              <description>Capture/Compare 1 selection

This bit-field defines the direction of the channel (input/output) as well as the used input. 

Note: CC1S bits are writable only when the channel is OFF (CC1E = 0 in TIMx_CCER).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>CC1 channel is configured as output.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>CC1 channel is configured as input, tim_ic1 is mapped on tim_ti1.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>CC1 channel is configured as input, tim_ic1 is mapped on tim_ti2.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>CC1 channel is configured as input, tim_ic1 is mapped on tim_trc. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OC1FE</name>
              <description>Output compare 1 fast enable

This bit decreases the latency between a trigger event and a transition on the timer output. It must be used in one-pulse mode (OPM bit set in TIMx_CR1 register), to have the output pulse starting as soon as possible after the starting trigger.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>CC1 behaves normally depending on counter and CCR1 values even when the trigger is ON. The minimum delay to activate CC1 output when an edge occurs on the trigger input is 5 clock cycles.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>An active edge on the trigger input acts like a compare match on CC1 output. Then, OC is set to the compare level independently from the result of the comparison. Delay to sample the trigger input and to activate CC1 output is reduced to 3 clock cycles. OCFE acts only if the channel is configured in PWM1 or PWM2 mode.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OC1PE</name>
              <description>Output compare 1 preload enable</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Preload register on TIMx_CCR1 disabled. TIMx_CCR1 can be written at anytime, the new value is taken in account immediately.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Preload register on TIMx_CCR1 enabled. Read/Write operations access the preload register. TIMx_CCR1 preload value is loaded in the active register at each update event.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OC1M</name>
              <description>OC1M[2:0]: Output compare 1 mode

These bits define the behavior of the output reference signal tim_oc1ref from which tim_oc1 is derived. tim_oc1ref is active high whereas tim_oc1 active level depends on CC1P bit.

Note: In PWM mode, the tim_ocref_clr level changes only when the result of the comparison changes or when the output compare mode switches from 'frozen' mode to 'PWM' mode.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Frozen - The comparison between the output compare register TIMx_CCR1 and the counter TIMx_CNT has no effect on the outputs.(this mode is used to generate a timing base).</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Set channel 1 to active level on match. tim_oc1ref signal is forced high when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>Set channel 1 to inactive level on match. tim_oc1ref signal is forced low when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>Toggle - tim_oc1ref toggles when TIMx_CNT=TIMx_CCR1.</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>Force inactive level - tim_oc1ref is forced low.</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>Force active level - tim_oc1ref is forced high.</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x6</name>
                  <description>PWM mode 1 - In upcounting, channel 1 is active as long as TIMx_CNTTIMx_CCR1 else inactive. In downcounting, channel 1 is inactive (tim_oc1ref=0) as long as TIMx_CNTTIMx_CCR1 else active (tim_oc1ref=1).</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7</name>
                  <description>PWM mode 2 - In upcounting, channel 1 is inactive as long as TIMx_CNTTIMx_CCR1 else active. In downcounting, channel 1 is active as long as TIMx_CNTTIMx_CCR1 else inactive.</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OC1CE</name>
              <description>Output compare 1 clear enable</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>tim_oc1ref is not affected by the tim_ocref_clr_int input</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_oc1ref is cleared as soon as a High level is detected on tim_ocref_clr_int input</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CC2S</name>
              <description>Capture/Compare 2 selection

This bit-field defines the direction of the channel (input/output) as well as the used input. 

Note: CC2S bits are writable only when the channel is OFF (CC2E = 0 in TIMx_CCER).</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>CC2 channel is configured as output</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>CC2 channel is configured as input, tim_ic2 is mapped on tim_ti2</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>CC2 channel is configured as input, tim_ic2 is mapped on tim_ti1</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>CC2 channel is configured as input, tim_ic2 is mapped on tim_trc. This mode is working only if an internal trigger input is selected through the TS bit (TIMx_SMCR register)</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OC2FE</name>
              <description>Output compare 2 fast enable</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OC2PE</name>
              <description>Output compare 2 preload enable</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OC2M</name>
              <description>OC2M[2:0]: Output compare 2 mode

refer to OC1M description on bits 6:4</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OC2CE</name>
              <description>Output compare 2 clear enable</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OC1M_1</name>
              <description>OC1M[3]</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OC2M_1</name>
              <description>OC2M[3]</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM2_CCMR2</name>
          <displayName>TIM2_CCMR2</displayName>
          <description>TIM2 capture/compare mode register 2 [alternate]</description>
          <addressOffset>0x01C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CC3S</name>
              <description>Capture/Compare 3 selection

This bit-field defines the direction of the channel (input/output) as well as the used input. 

Note: CC3S bits are writable only when the channel is OFF (CC3E = 0 in TIMx_CCER).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>CC3 channel is configured as output</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>CC3 channel is configured as input, tim_ic3 is mapped on tim_ti3</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>CC3 channel is configured as input, tim_ic3 is mapped on tim_ti4</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>CC3 channel is configured as input, tim_ic3 is mapped on tim_trc. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IC3PSC</name>
              <description>Input capture 3 prescaler</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IC3F</name>
              <description>Input capture 3 filter</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CC4S</name>
              <description>Capture/Compare 4 selection

This bit-field defines the direction of the channel (input/output) as well as the used input. 

Note: CC4S bits are writable only when the channel is OFF (CC4E = 0 in TIMx_CCER).</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>CC4 channel is configured as output</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>CC4 channel is configured as input, tim_ic4 is mapped on tim_ti4</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>CC4 channel is configured as input, tim_ic4 is mapped on tim_ti3</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>CC4 channel is configured as input, tim_ic4 is mapped on tim_trc. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IC4PSC</name>
              <description>Input capture 4 prescaler</description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IC4F</name>
              <description>Input capture 4 filter</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM2_CCMR2_ALTERNATE</name>
          <displayName>TIM2_CCMR2_ALTERNATE</displayName>
          <description>TIM2 capture/compare mode register 2 [alternate]</description>
          <alternateRegister>TIM2_CCMR2</alternateRegister>
          <addressOffset>0x01C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CC3S</name>
              <description>Capture/Compare 3 selection

This bit-field defines the direction of the channel (input/output) as well as the used input. 

Note: CC3S bits are writable only when the channel is OFF (CC3E = 0 in TIMx_CCER).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>CC3 channel is configured as output</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>CC3 channel is configured as input, tim_ic3 is mapped on tim_ti3</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>CC3 channel is configured as input, tim_ic3 is mapped on tim_ti4</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>CC3 channel is configured as input, tim_ic3 is mapped on tim_trc. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OC3FE</name>
              <description>Output compare 3 fast enable</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OC3PE</name>
              <description>Output compare 3 preload enable</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OC3M</name>
              <description>OC3M[2:0]: Output compare 3 mode

Refer to OC1M description (bits 6:4 in TIMx_CCMR1 register)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OC3CE</name>
              <description>Output compare 3 clear enable</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CC4S</name>
              <description>Capture/Compare 4 selection

This bit-field defines the direction of the channel (input/output) as well as the used input. 

Note: CC4S bits are writable only when the channel is OFF (CC4E = 0 in TIMx_CCER).</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>CC4 channel is configured as output</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>CC4 channel is configured as input, tim_ic4 is mapped on tim_ti4</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>CC4 channel is configured as input, tim_ic4 is mapped on tim_ti3</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>CC4 channel is configured as input, tim_ic4 is mapped on tim_trc. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OC4FE</name>
              <description>Output compare 4 fast enable</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OC4PE</name>
              <description>Output compare 4 preload enable</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OC4M</name>
              <description>OC4M[2:0]: Output compare 4 mode

Refer to OC1M description (bits 6:4 in TIMx_CCMR1 register)</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OC4CE</name>
              <description>Output compare 4 clear enable</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OC3M_1</name>
              <description>OC3M[3]</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OC4M_1</name>
              <description>OC4M[3]</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM2_CCER</name>
          <displayName>TIM2_CCER</displayName>
          <description>TIM2 capture/compare enable register</description>
          <addressOffset>0x020</addressOffset>
          <size>16</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>CC1E</name>
              <description>Capture/Compare 1 output enable.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Capture mode disabled / OC1 is not active</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Capture mode enabled / OC1 signal is output on the corresponding output pin</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CC1P</name>
              <description>Capture/Compare 1 output Polarity.

When CC1 channel is configured as input, both CC1NP/CC1P bits select the active polarity of TI1FP1 and TI2FP1 for trigger or capture operations.

CC1NP=0, CC1P=0:	non-inverted/rising edge. The circuit is sensitive to TIxFP1 rising edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is not inverted (trigger operation in gated mode or encoder mode).

CC1NP=0, CC1P=1:	inverted/falling edge. The circuit is sensitive to TIxFP1 falling edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is inverted (trigger operation in gated mode or encoder mode).

CC1NP=1, CC1P=1:	non-inverted/both edges. The circuit is sensitive to both TIxFP1 rising and falling edges (capture or trigger operations in reset, external clock or trigger mode), TIxFP1is not inverted (trigger operation in gated mode). This configuration must not be used in encoder mode.

CC1NP=1, CC1P=0:	this configuration is reserved, it must not be used.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>OC1 active high (output mode) / Edge sensitivity selection (input mode, see below)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>OC1 active low (output mode) / Edge sensitivity selection (input mode, see below)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CC1NP</name>
              <description>Capture/Compare 1 output Polarity.

CC1 channel configured as output: CC1NP must be kept cleared in this case.

CC1 channel configured as input: This bit is used in conjunction with CC1P to define tim_ti1fp1/tim_ti2fp1 polarity. refer to CC1P description.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CC2E</name>
              <description>Capture/Compare 2 output enable.

Refer to CC1E description</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CC2P</name>
              <description>Capture/Compare 2 output Polarity.

refer to CC1P description</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CC2NP</name>
              <description>Capture/Compare 2 output Polarity.

Refer to CC1NP description</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CC3E</name>
              <description>Capture/Compare 3 output enable.

Refer to CC1E description</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CC3P</name>
              <description>Capture/Compare 3 output Polarity.

Refer to CC1P description</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CC3NP</name>
              <description>Capture/Compare 3 output Polarity.

Refer to CC1NP description</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CC4E</name>
              <description>Capture/Compare 4 output enable.

refer to CC1E description</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CC4P</name>
              <description>Capture/Compare 4 output Polarity.

Refer to CC1P description</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CC4NP</name>
              <description>Capture/Compare 4 output Polarity.

Refer to CC1NP description</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM2_CNT</name>
          <displayName>TIM2_CNT</displayName>
          <description>TIM2 counter</description>
          <addressOffset>0x024</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNT</name>
              <description>Least significant part of counter value

Non-dithering mode (DITHEN = 0)

The register holds the counter value.

Dithering mode (DITHEN = 1)

The register holds the non-dithered part in CNT[30:0]. The fractional part is not available.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>31</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UIFCPY</name>
              <description>UIF copy or CNT bit 31

If TIMx_CR1.UIFREMAP = 0, thisbit means CNT[31], the most significant bit of counter value

If TIMx_CRT1.UIFREMAP = 1, this bit means UIF Copy, and is a read-only copy of the UIF bit of the TIMx_ISR register</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM2_PSC</name>
          <displayName>TIM2_PSC</displayName>
          <description>TIM2 prescaler</description>
          <addressOffset>0x028</addressOffset>
          <size>16</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>PSC</name>
              <description>Prescaler value

The counter clock frequency tim_cnt_ck is equal to fsubtim_psc_ck/sub / (PSC[15:0] + 1).

PSC contains the value to be loaded in the active prescaler register at each update event (including when the counter is cleared through UG bit of TIMx_EGR register or through trigger controller when configured in 'reset mode').</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM2_ARR</name>
          <displayName>TIM2_ARR</displayName>
          <description>TIM2 auto-reload register</description>
          <addressOffset>0x02C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ARR</name>
              <description>Auto-reload value

ARR is the value to be loaded in the actual auto-reload register.

Refer to the Section 29.4.3: Time-base unit on page 1245 for more details about ARR update and behavior.

The counter is blocked while the auto-reload value is null.

Non-dithering mode (DITHEN = 0)

The register holds the auto-reload value.

Dithering mode (DITHEN = 1)

The register holds the integer part in ARR[31:4]. The ARR[3:0] bitfield contains the dithered part.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM2_CCR1</name>
          <displayName>TIM2_CCR1</displayName>
          <description>TIM2 capture/compare register 1</description>
          <addressOffset>0x034</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CCR1</name>
              <description>Capture/compare 1 value

If channel CC1 is configured as output:

CCR1 is the value to be loaded in the actual capture/compare 1 register (preload value). It is loaded permanently if the preload feature is not selected in the TIMx_CCMR1 register (bit OC1PE). Else the preload value is copied in the active capture/compare 1 register when an update event occurs.

The active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on tim_oc1 output.

Non-dithering mode (DITHEN = 0)

The register holds the compare value.

Dithering mode (DITHEN = 1)

The register holds the integer part in CCR1[31:4]. The CCR1[3:0] bitfield contains the dithered part.

If channel CC1 is configured as input:

CCR1 is the counter value transferred by the last input capture 1 event (tim_ic1). The TIMx_CCR1 register is read-only and cannot be programmed.

Non-dithering mode (DITHEN = 0)

The register holds the capture value.

Dithering mode (DITHEN = 1)

The register holds the capture in CCR1[31:0]. The CCR1[3:0] bits are reset.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM2_CCR2</name>
          <displayName>TIM2_CCR2</displayName>
          <description>TIM2 capture/compare register 2</description>
          <addressOffset>0x038</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CCR2</name>
              <description>Capture/compare 2 value

If channel CC2 is configured as output:

CCR2 is the value to be loaded in the actual capture/compare 2 register (preload value). It is loaded permanently if the preload feature is not selected in the TIMx_CCMR2 register (bit OC2PE). Else the preload value is copied in the active capture/compare 2 register when an update event occurs.

The active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on tim_oc2 output.

Non-dithering mode (DITHEN = 0)

The register holds the compare value.

Dithering mode (DITHEN = 1)

The register holds the integer part in CCR2[31:4]. The CCR2[3:0] bitfield contains the dithered part.

If channel CC2 is configured as input:

CCR2 is the counter value transferred by the last input capture 2 event (tim_ic2). The TIMx_CCR2 register is read-only and cannot be programmed.

Non-dithering mode (DITHEN = 0)

The register holds the capture value.

Dithering mode (DITHEN = 1)

The register holds the capture in CCR2[31:0]. The CCR2[3:0] bits are reset.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM2_CCR3</name>
          <displayName>TIM2_CCR3</displayName>
          <description>TIM2 capture/compare register 3</description>
          <addressOffset>0x03C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CCR3</name>
              <description>Capture/compare 3 value

If channel CC3 is configured as output:

CCR3 is the value to be loaded in the actual capture/compare 3 register (preload value). It is loaded permanently if the preload feature is not selected in the TIMx_CCMR3 register (bit OC3PE). Else the preload value is copied in the active capture/compare 3 register when an update event occurs.

The active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on tim_oc3 output.

Non-dithering mode (DITHEN = 0)

The register holds the compare value.

Dithering mode (DITHEN = 1)

The register holds the integer part in CCR3[31:4]. The CCR3[3:0] bitfield contains the dithered part.

If channel CC3 is configured as input:

CCR3 is the counter value transferred by the last input capture 3 event (tim_ic3). The TIMx_CCR3 register is read-only and cannot be programmed.

Non-dithering mode (DITHEN = 0)

The register holds the capture value.

Dithering mode (DITHEN = 1)

The register holds the capture in CCR3[31:0]. The CCR3[3:0] bits are reset.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM2_CCR4</name>
          <displayName>TIM2_CCR4</displayName>
          <description>TIM2 capture/compare register 4</description>
          <addressOffset>0x040</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CCR4</name>
              <description>Capture/compare 4 value

If channel CC4 is configured as output:

CCR4 is the value to be loaded in the actual capture/compare 4 register (preload value). It is loaded permanently if the preload feature is not selected in the TIMx_CCMR4 register (bit OC4PE). Else the preload value is copied in the active capture/compare 4 register when an update event occurs.

The active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on tim_oc4 output.

Non-dithering mode (DITHEN = 0)

The register holds the compare value.

Dithering mode (DITHEN = 1)

The register holds the integer part in CCR4[31:4]. The CCR4[3:0] bitfield contains the dithered part.

If channel CC4 is configured as input:

CCR4 is the counter value transferred by the last input capture 4 event (tim_ic4). The TIMx_CCR4 register is read-only and cannot be programmed.

Non-dithering mode (DITHEN = 0)

The register holds the capture value.

Dithering mode (DITHEN = 1)

The register holds the capture in CCR4[31:0]. The CCR4[3:0] bits are reset.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM2_ECR</name>
          <displayName>TIM2_ECR</displayName>
          <description>TIM2 timer encoder control register</description>
          <addressOffset>0x058</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IE</name>
              <description>Index enable

This bit indicates if the Index event resets the counter.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Index disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Index enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IDIR</name>
              <description>Index direction

This bit indicates in which direction the Index event resets the counter.

Note: The IDR[1:0] bitfield must be written when IE bit is reset (index disabled).</description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Index resets the counter whatever the direction</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Index resets the counter when up-counting only</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>Index resets the counter when down-counting only</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IBLK</name>
              <description>Index blanking

This bit indicates if the Index event is conditioned by the tim_ti3 input</description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Index always active</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Index disabled hen tim_ti3 input is active, as per CC3P bitfield</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>Index disabled when tim_ti4 input is active, as per CC4P bitfield</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FIDX</name>
              <description>First index 

This bit indicates if the first index only is taken into account</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Index is always active</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>the first Index only resets the counter</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IPOS</name>
              <description>Index positioning

In quadrature encoder mode (SMS[3:0] = 0001, 0010, 0011, 1110, 1111), this bit indicates in which AB input configuration the Index event resets the counter.

In directional clock mode or clock plus direction mode (SMS[3:0] = 1010, 1011, 1100, 1101), these bits indicates on which level the Index event resets the counter. In bidirectional clock mode, this applies for both clock inputs.

x0: Index resets the counter when clock is 0

x1: Index resets the counter when clock is 1

Note: IPOS[1] bit is not significant</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Index resets the counter when AB = 00</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Index resets the counter when AB = 01</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>Index resets the counter when AB = 10</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>Index resets the counter when AB = 11</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PW</name>
              <description>Pulse width

This bitfield defines the pulse duration, as following:

tsubPW/sub = PW[7:0] x tsubPWG/sub</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWPRSC</name>
              <description>Pulse width prescaler

This bitfield sets the clock prescaler for the pulse generator, as following:

tsubPWG/sub = (2sup(PWPRSC[2:0])/sup) x tsubtim_ker_ck/sub</description>
              <bitOffset>24</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM2_TISEL</name>
          <displayName>TIM2_TISEL</displayName>
          <description>TIM2 timer input selection register</description>
          <addressOffset>0x05C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TI1SEL</name>
              <description>Selects tim_ti1[15:0] input

...

Refer to Section 29.4.2: TIM2/TIM3 pins and internal signals for product specific implementation.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>tim_ti1_in0: TIMx_CH1</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_ti1_in1</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xF</name>
                  <description>tim_ti1_in15</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TI2SEL</name>
              <description>Selects tim_ti2[15:0] input

...

Refer to Section 29.4.2: TIM2/TIM3 pins and internal signals for product specific implementation.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>tim_ti2_in0: TIMx_CH2</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_ti2_in1</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xF</name>
                  <description>tim_ti2_in15</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TI3SEL</name>
              <description>Selects tim_ti3[15:0] input

...

Refer to Section 29.4.2: TIM2/TIM3 pins and internal signals for product specific implementation.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>tim_ti3_in0: TIMx_CH3</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_ti3_in1</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xF</name>
                  <description>tim_ti3_in15</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TI4SEL</name>
              <description>Selects tim_ti4[15:0] input

...

Refer to Section 29.4.2: TIM2/TIM3 pins and internal signals for product specific implementation.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>tim_ti4_in0: TIMx_CH4</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_ti4_in1</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xF</name>
                  <description>tim_ti4_in15</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM2_AF1</name>
          <displayName>TIM2_AF1</displayName>
          <description>TIM2 alternate function register 1</description>
          <addressOffset>0x060</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ETRSEL</name>
              <description>etr_in source selection

These bits select the etr_in input source.

...

Refer to Section 29.4.2: TIM2/TIM3 pins and internal signals for product specific implementation.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>tim_etr0: TIMx_ETR input</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_etr1</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xF</name>
                  <description>tim_etr15</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM2_AF2</name>
          <displayName>TIM2_AF2</displayName>
          <description>TIM2 alternate function register 2</description>
          <addressOffset>0x064</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OCRSEL</name>
              <description>ocref_clr source selection

These bits select the ocref_clr input source.

...

Refer to Section 29.4.2: TIM2/TIM3 pins and internal signals for product specific implementation.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>tim_ocref_clr0</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_ocref_clr1</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7</name>
                  <description>tim_ocref_clr7</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM2_DCR</name>
          <displayName>TIM2_DCR</displayName>
          <description>TIM2 DMA control register</description>
          <addressOffset>0x3DC</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DBA</name>
              <description>DMA base address

This 5-bits vector defines the base-address for DMA transfers (when read/write access are done through the TIMx_DMAR address). DBA is defined as an offset starting from the address of the TIMx_CR1 register.

Example:

...</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>TIMx_CR1,</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>TIMx_CR2,</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>TIMx_SMCR,</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DBL</name>
              <description>DMA burst length

This 5-bit vector defines the length of DMA transfers (the timer recognizes a burst transfer when a read or a write access is done to the TIMx_DMAR address), i.e. the number of transfers. Transfers can be in half-words or in bytes (see example below).

...

Example: Let us consider the following transfer: DBL = 7 bytes &amp; DBA = TIM2_CR1.

If DBL = 7 bytes and DBA = TIM2_CR1 represents the address of the byte to be transferred, the address of the transfer should be given by the following equation:

(TIMx_CR1 address) + DBA + (DMA index), where DMA index = DBL

In this example, 7 bytes are added to (TIMx_CR1 address) + DBA, which gives us the address from/to which the data are copied. In this case, the transfer is done to 7 registers starting from the following address: (TIMx_CR1 address) + DBA

According to the configuration of the DMA Data Size, several cases may occur:

If the DMA Data Size is configured in half-words, 16-bit data are transferred to each of the 7 registers.

If the DMA Data Size is configured in bytes, the data are also transferred to 7 registers: the first register contains the first MSB byte, the second register, the first LSB byte and so on. So with the transfer Timer, one also has to specify the size of data transferred by DMA.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>1 transfer</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>2 transfers</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>3 transfers</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1A</name>
                  <description>26 transfers</description>
                  <value>0x1A</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DBSS</name>
              <description>DMA burst source selection

This bitfield defines the interrupt source that triggers the DMA burst transfers (the timer recognizes a burst transfer when a read or a write access is done to the TIMx_DMAR address).

Others: reserved</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Update</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>CC1</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>CC2</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>CC3</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>CC4</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x6</name>
                  <description>COM</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7</name>
                  <description>Trigger</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM2_DMAR</name>
          <displayName>TIM2_DMAR</displayName>
          <description>TIM2 DMA address for full transfer</description>
          <addressOffset>0x3E0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMAB</name>
              <description>DMA register for burst accesses

A read or write operation to the DMAR register accesses the register located at the address

(TIMx_CR1 address) + (DBA + DMA index) x 4 

where TIMx_CR1 address is the address of the control register 1, DBA is the DMA base address configured in TIMx_DCR register, DMA index is automatically controlled by the DMA transfer, and ranges from 0 to DBL (DBL configured in TIMx_DCR).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>TIM16</name>
      <description>TIM16 address block description</description>
      <groupName>TIM16</groupName>
      <baseAddress>0x40014400</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x3E4</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>TIM16</name>
        <description>TIM16 global interrupt</description>
        <value>51</value>
      </interrupt>
      <registers>
        <register>
          <name>TIM16_CR1</name>
          <displayName>TIM16_CR1</displayName>
          <description>TIM16 control register 1</description>
          <addressOffset>0x00</addressOffset>
          <size>16</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>CEN</name>
              <description>Counter enable

Note: External clock and gated mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Counter disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Counter enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UDIS</name>
              <description>Update disable

This bit is set and cleared by software to enable/disable UEV event generation.

Counter overflow/underflow

Setting the UG bit

Update generation through the slave mode controller

	Buffered registers are then loaded with their preload values.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>UEV enabled. The Update (UEV) event is generated by one of the following events:</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC, CCRx). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>URS</name>
              <description>Update request source

This bit is set and cleared by software to select the UEV event sources.

Counter overflow/underflow

Setting the UG bit

Update generation through the slave mode controller</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Any of the following events generate an update interrupt or DMA request if enabled. These events can be:</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>nly counter overflow/underflow generates an update interrupt or DMA request if enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OPM</name>
              <description>One pulse mode</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Counter is not stopped at update event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Counter stops counting at the next update event (clearing the bit CEN)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ARPE</name>
              <description>Auto-reload preload enable</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>TIMx_ARR register is not buffered</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>TIMx_ARR register is buffered</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CKD</name>
              <description>Clock division

This bit-field indicates the division ratio between the timer clock (tim_ker_ck) frequency and the dead-time and sampling clock (tsubDTS/sub)used by the dead-time generators and the digital filters (tim_tix),</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>tsubDTS/sub=tsubtim_ker_ck/sub</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tsubDTS/sub=2*tsubtim_ker_ck/sub</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>tsubDTS/sub=4*tsubtim_ker_ck/sub</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UIFREMAP</name>
              <description>UIF status bit remapping</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No remapping. UIF status bit is not copied to TIMx_CNT register bit 31.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Remapping enabled. UIF status bit is copied to TIMx_CNT register bit 31.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DITHEN</name>
              <description>Dithering enable

Note: The DITHEN bit can only be modified when CEN bit is reset.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Dithering disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Dithering enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM16_CR2</name>
          <displayName>TIM16_CR2</displayName>
          <description>TIM16 control register 2</description>
          <addressOffset>0x04</addressOffset>
          <size>16</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>CCPC</name>
              <description>Capture/compare preloaded control

Note: This bit acts only on channels that have a complementary output.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>CCxE, CCxNE and OCxM bits are not preloaded</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>CCxE, CCxNE and OCxM bits are preloaded, after having been written, they are updated only when COM bit is set.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CCUS</name>
              <description>Capture/compare control update selection

Note: This bit acts only on channels that have a complementary output.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>When capture/compare control bits are preloaded (CCPC=1), they are updated by setting the COMG bit only.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>When capture/compare control bits are preloaded (CCPC=1), they are updated by setting the COMG bit or when a rising edge occurs on tim_trgi (if available).</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CCDS</name>
              <description>Capture/compare DMA selection</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>CCx DMA request sent when CCx event occurs</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>CCx DMA requests sent when update event occurs</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OIS1</name>
              <description>Output Idle state 1 (tim_oc1 output)

Note: This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BKR register).</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>tim_oc1=0 after a dead-time when MOE=0</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_oc1=1 after a dead-time when MOE=0</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OIS1N</name>
              <description>Output Idle state 1 (tim_oc1n output)

Note: This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BKR register).</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>tim_oc1n=0 after a dead-time when MOE=0</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_oc1n=1 after a dead-time when MOE=0</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM16_DIER</name>
          <displayName>TIM16_DIER</displayName>
          <description>TIM16 DMA/interrupt enable register</description>
          <addressOffset>0x0C</addressOffset>
          <size>16</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>UIE</name>
              <description>Update interrupt enable</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Update interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Update interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CC1IE</name>
              <description>Capture/Compare 1 interrupt enable</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>CC1 interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>CC1 interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>COMIE</name>
              <description>COM interrupt enable</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>COM interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>COM interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BIE</name>
              <description>Break interrupt enable</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Break interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Break interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UDE</name>
              <description>Update DMA request enable</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Update DMA request disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Update DMA request enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CC1DE</name>
              <description>Capture/Compare 1 DMA request enable</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>CC1 DMA request disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>CC1 DMA request enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM16_SR</name>
          <displayName>TIM16_SR</displayName>
          <description>TIM16 status register</description>
          <addressOffset>0x10</addressOffset>
          <size>16</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>UIF</name>
              <description>Update interrupt flag

This bit is set by hardware on an update event. It is cleared by software.

At overflow regarding the repetition counter value (update if repetition counter = 0) and if the UDIS=0 in the TIMx_CR1 register.

When CNT is reinitialized by software using the UG bit in TIMx_EGR register, if URS=0 and UDIS=0 in the TIMx_CR1 register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No update occurred.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Update interrupt pending. This bit is set by hardware when the registers are updated:</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CC1IF</name>
              <description>Capture/Compare 1 interrupt flag

This flag is set by hardware. It is cleared by software (input capture or output compare mode) or by reading the TIMx_CCR1 register (input capture mode only).

If channel CC1 is configured as output: this flag is set when the content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. When the content of TIMx_CCR1 is greater than the content of TIMx_ARR, the CC1IF bit goes high on the counter overflow (in up-counting and up/down-counting modes) or underflow (in down-counting mode). There are 3 possible options for flag setting in center-aligned mode, refer to the CMS bits in the TIMx_CR1 register for the full description.

If channel CC1 is configured as input: this bit is set when counter value has been captured in TIMx_CCR1 register (an edge has been detected on IC1, as per the edge sensitivity defined with the CC1P and CC1NP bits setting, in TIMx_CCER).</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No compare match / No input capture occurred</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>A compare match or an input capture occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>COMIF</name>
              <description>COM interrupt flag
This flag is set by hardware on a COM event (once the capture compare control bits CCxE, CCxNE, OCxM have been updated). It is cleared by software.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No COM event occurred</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>COM interrupt pending</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BIF</name>
              <description>Break interrupt flag

This flag is set by hardware as soon as the tim_brk input goes active. It can be cleared by software if the break input is not active.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No break event occurred</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>An active level has been detected on the break input</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CC1OF</name>
              <description>Capture/Compare 1 overcapture flag

This flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing it to '0'.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No overcapture has been detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The counter value has been captured in TIMx_CCR1 register while CC1IF flag was already set</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM16_EGR</name>
          <displayName>TIM16_EGR</displayName>
          <description>TIM16 event generation register</description>
          <addressOffset>0x14</addressOffset>
          <size>16</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>UG</name>
              <description>Update generation

This bit can be set by software, it is automatically cleared by hardware.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reinitialize the counter and generates an update of the registers. Note that the prescaler counter is cleared too (anyway the prescaler ratio is not affected).</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CC1G</name>
              <description>Capture/Compare 1 generation

This bit is set by software in order to generate an event, it is automatically cleared by hardware.

If channel CC1 is configured as output:

CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled.

If channel CC1 is configured as input:

The current value of the counter is captured in TIMx_CCR1 register. The CC1IF flag is set, the corresponding interrupt or DMA request is sent if enabled. The CC1OF flag is set if the CC1IF flag was already high.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>A capture/compare event is generated on channel 1:</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>COMG</name>
              <description>Capture/Compare control update generation

This bit can be set by software, it is automatically cleared by hardware.

Note: This bit acts only on channels that have a complementary output.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>When the CCPC bit is set, it is possible to update the CCxE, CCxNE and OCxM bits</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BG</name>
              <description>Break generation

This bit is set by software in order to generate an event, it is automatically cleared by hardware.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No action.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>A break event is generated. MOE bit is cleared and BIF flag is set. Related interrupt or DMA transfer can occur if enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM16_CCMR1</name>
          <displayName>TIM16_CCMR1</displayName>
          <description>TIM16 capture/compare mode register 1 [alternate]</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CC1S</name>
              <description>Capture/Compare 1 selection

This bit-field defines the direction of the channel (input/output) as well as the used input.

Others: Reserved

Note: CC1S bits are writable only when the channel is OFF (CC1E = '0' in TIMx_CCER).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>CC1 channel is configured as output</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>CC1 channel is configured as input, tim_ic1 is mapped on tim_ti1</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IC1PSC</name>
              <description>Input capture 1 prescaler

This bit-field defines the ratio of the prescaler acting on CC1 input (tim_ic1).

The prescaler is reset as soon as CC1E='0' (TIMx_CCER register).</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>no prescaler, capture is done each time an edge is detected on the capture input.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>capture is done once every 2 events</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>capture is done once every 4 events</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>capture is done once every 8 events</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IC1F</name>
              <description>Input capture 1 filter

This bit-field defines the frequency used to sample tim_ti1 input and the length of the digital filter applied to tim_ti1. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No filter, sampling is done at fsubDTS/sub</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>fsubSAMPLING/sub=fsubtim_ker_ck/sub, N=2</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>fsubSAMPLING/sub=fsubtim_ker_ck/sub, N=4</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>fsubSAMPLING/sub=fsubtim_ker_ck/sub, N=8</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/2, N=</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/2, N=8</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x6</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/4, N=6</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/4, N=8</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x8</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/8, N=6</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x9</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/8, N=8</description>
                  <value>0x9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xA</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/16, N=5</description>
                  <value>0xA</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xB</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/16, N=6</description>
                  <value>0xB</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xC</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/16, N=8</description>
                  <value>0xC</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xD</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/32, N=5</description>
                  <value>0xD</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xE</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/32, N=6</description>
                  <value>0xE</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xF</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/32, N=8</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM16_CCMR1_ALTERNATE1</name>
          <displayName>TIM16_CCMR1_ALTERNATE1</displayName>
          <description>TIM16 capture/compare mode register 1 [alternate]</description>
          <alternateRegister>TIM16_CCMR1</alternateRegister>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CC1S</name>
              <description>Capture/Compare 1 selection

This bit-field defines the direction of the channel (input/output) as well as the used input.

Others: Reserved

Note: CC1S bits are writable only when the channel is OFF (CC1E = '0' in TIMx_CCER).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>CC1 channel is configured as output</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>CC1 channel is configured as input, tim_ic1 is mapped on tim_ti1</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OC1FE</name>
              <description>Output Compare 1 fast enable

This bit decreases the latency between a trigger event and a transition on the timer output. It must be used in one-pulse mode (OPM bit set in TIMx_CR1 register), to have the output pulse starting as soon as possible after the starting trigger.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>CC1 behaves normally depending on counter and CCR1 values even when the trigger is ON. The minimum delay to activate CC1 output when an edge occurs on the trigger input is 5 clock cycles.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>An active edge on the trigger input acts like a compare match on CC1 output. Then, tim_ocx is set to the compare level independently of the result of the comparison. Delay to sample the trigger input and to activate CC1 output is reduced to 3 clock cycles. OC1FE acts only if the channel is configured in PWM1 or PWM2 mode.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OC1PE</name>
              <description>Output Compare 1 preload enable

Note: These bits can not be modified as long as LOCK level 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S='00' (the channel is configured in output).</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Preload register on TIMx_CCR1 disabled. TIMx_CCR1 can be written at anytime, the new value is taken in account immediately.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Preload register on TIMx_CCR1 enabled. Read/Write operations access the preload register. TIMx_CCR1 preload value is loaded in the active register at each update event.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OC1M</name>
              <description>OC1M[2:0]: Output Compare 1 mode

These bits define the behavior of the output reference signal tim_oc1ref from which tim_oc1 and tim_oc1n are derived. tim_oc1ref is active high whereas tim_oc1 and tim_oc1n active level depends on CC1P and CC1NP bits.

Others: Reserved

Note: These bits can not be modified as long as LOCK level 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S='00' (the channel is configured in output).

Note: In PWM mode 1 or 2, the tim_oc1ref level changes only when the result of the comparison changes or when the output compare mode switches from 'frozen' mode to 'PWM' mode.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Frozen - The comparison between the output compare register TIMx_CCR1 and the counter TIMx_CNT has no effect on the outputs.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Set channel 1 to active level on match. tim_oc1ref signal is forced high when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>Set channel 1 to inactive level on match. tim_oc1ref signal is forced low when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>Toggle - tim_oc1ref toggles when TIMx_CNT=TIMx_CCR1.</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>Force inactive level - tim_oc1ref is forced low.</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>Force active level - tim_oc1ref is forced high.</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x6</name>
                  <description>PWM mode 1 - Channel 1 is active as long as TIMx_CNTTIMx_CCR1 else inactive.</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7</name>
                  <description>PWM mode 2 - Channel 1 is inactive as long as TIMx_CNTTIMx_CCR1 else active.</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OC1CE</name>
              <description>Output Compare 1 clear enable</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>tim_oc1ref is not affected by the tim_ocref_clr input.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_oc1ref is cleared as soon as a High level is detected on tim_ocref_clr input.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OC1M_1</name>
              <description>OC1M[3]</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM16_CCER</name>
          <displayName>TIM16_CCER</displayName>
          <description>TIM16 capture/compare enable register</description>
          <addressOffset>0x20</addressOffset>
          <size>16</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>CC1E</name>
              <description>Capture/Compare 1 output enable

When CC1 channel is configured as output, the OC1 level depends on MOE, OSSI, OSSR, OIS1, OIS1N and CC1NE bits, regardless of the CC1E bits state. Refer to Table 305 for details.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Capture mode disabled / OC1 is not active (see below)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Capture mode enabled / OC1 signal is output on the corresponding output pin</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CC1P</name>
              <description>Capture/Compare 1 output polarity

When CC1 channel is configured as input, both CC1NP/CC1P bits select the active polarity of TI1FP1 and TI2FP1 for trigger or capture operations.

CC1NP=0, CC1P=0:	non-inverted/rising edge. The circuit is sensitive to TIxFP1 rising edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is not inverted (trigger operation in gated mode or encoder mode).

CC1NP=0, CC1P=1:	inverted/falling edge. The circuit is sensitive to TIxFP1 falling edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is inverted (trigger operation in gated mode or encoder mode).

CC1NP=1, CC1P=1:	non-inverted/both edges/ The circuit is sensitive to both TIxFP1 rising and falling edges (capture or trigger operations in reset, external clock or trigger mode), TIxFP1is not inverted (trigger operation in gated mode). This configuration must not be used in encoder mode.

CC1NP=1, CC1P=0:	this configuration is reserved, it must not be used.

Note: This bit is not writable as soon as LOCK level 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).

Note: On channels that have a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1P active bit takes the new value from the preloaded bit only when a Commutation event is generated.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>OC1 active high (output mode) / Edge sensitivity selection (input mode, see below)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>OC1 active low (output mode) / Edge sensitivity selection (input mode, see below)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CC1NE</name>
              <description>Capture/Compare 1 complementary output enable</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Off - tim_oc1n is not active. tim_oc1n level is then function of MOE, OSSI, OSSR, OIS1, OIS1N and CC1E bits.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>On - tim_oc1n signal is output on the corresponding output pin depending on MOE, OSSI, OSSR, OIS1, OIS1N and CC1E bits.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CC1NP</name>
              <description>Capture/Compare 1 complementary output polarity

CC1 channel configured as output:

CC1 channel configured as input:

This bit is used in conjunction with CC1P to define the polarity of tim_ti1fp1. Refer to the description of CC1P.

Note: This bit is not writable as soon as LOCK level 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S='00' (the channel is configured in output).

Note: On channels that have a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1NP active bit takes the new value from the preloaded bit only when a commutation event is generated.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>tim_oc1n active high</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_oc1n active low</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM16_CNT</name>
          <displayName>TIM16_CNT</displayName>
          <description>TIM16 counter</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNT</name>
              <description>Counter value

Non-dithering mode (DITHEN = 0)

The register holds the counter value.

Dithering mode (DITHEN = 1)

The register only holds the non-dithered part in CNT[15:0]. The fractional part is not available.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UIFCPY</name>
              <description>UIF Copy

This bit is a read-only copy of the UIF bit of the TIMx_ISR register. If the UIFREMAP bit in TIMx_CR1 is reset, bit 31 is reserved.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM16_PSC</name>
          <displayName>TIM16_PSC</displayName>
          <description>TIM16 prescaler</description>
          <addressOffset>0x28</addressOffset>
          <size>16</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>PSC</name>
              <description>Prescaler value

The counter clock frequency (tim_cnt_ck) is equal to fsubtim_psc_ck/sub / (PSC[15:0] + 1).

PSC contains the value to be loaded in the active prescaler register at each update event (including when the counter is cleared through UG bit of TIMx_EGR register or through trigger controller when configured in 'reset mode').</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM16_ARR</name>
          <displayName>TIM16_ARR</displayName>
          <description>TIM16 auto-reload register</description>
          <addressOffset>0x2C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000FFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ARR</name>
              <description>Auto-reload value

ARR is the value to be loaded in the actual auto-reload register.

Refer to the Section 30.3.3: Time-base unit on page 1362 for more details about ARR update and behavior.

The counter is blocked while the auto-reload value is null.

Non-dithering mode (DITHEN = 0)

The register holds the auto-reload value in ARR[15:0]. The ARR[19:16] bits are reset.

Dithering mode (DITHEN = 1)

The register holds the integer part in ARR[19:4]. The ARR[3:0] bitfield contains the dithered part.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>20</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM16_RCR</name>
          <displayName>TIM16_RCR</displayName>
          <description>TIM16 repetition counter register</description>
          <addressOffset>0x30</addressOffset>
          <size>16</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>REP</name>
              <description>Repetition counter reload value

This bitfield defines the update rate of the compare registers (i.e. periodic transfers from preload to active registers) when preload registers are enable. It also defines the update interrupt generation rate, if this interrupt is enable.

When the repetition down-counter reaches zero, an update event is generated and it restarts counting from REP value. As the repetition counter is reloaded with REP value only at the repetition update event UEV, any write to the TIMx_RCR register is not taken in account until the next repetition update event.

It means in PWM mode (REP+1) corresponds to the number of PWM periods in edge-aligned mode:

the number of PWM periods in edge-aligned mode

the number of half PWM period in center-aligned mode</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM16_CCR1</name>
          <displayName>TIM16_CCR1</displayName>
          <description>TIM16 capture/compare register 1</description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CCR1</name>
              <description>Capture/Compare 1 value

If channel CC1 is configured as output:

CCR1 is the value to be loaded in the actual capture/compare 1 register (preload value).

It is loaded permanently if the preload feature is not selected in the TIMx_CCMR1 register (bit OC1PE). Else the preload value is copied in the active capture/compare 1 register when an update event occurs.

The active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on tim_oc1 output.

Non-dithering mode (DITHEN = 0)

The register holds the compare value in CCR1[15:0]. The CCR1[19:16] bits are reset.

Dithering mode (DITHEN = 1)

The register holds the integer part in CCR1[19:4]. The CCR1[3:0] bitfield contains the dithered part.

If channel CC1 is configured as input:

CCR1 is the counter value transferred by the last input capture 1 event (tim_ic1).

Non-dithering mode (DITHEN = 0)

The register holds the capture value in CCR1[15:0]. The CCR1[19:16] bits are reset.

Dithering mode (DITHEN = 1)

The register holds the capture in CCR1[19:4]. The CCR1[3:0] bits are reset.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>20</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM16_BDTR</name>
          <displayName>TIM16_BDTR</displayName>
          <description>TIM16 break and dead-time register</description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DTG</name>
              <description>Dead-time generator setup

This bit-field defines the duration of the dead-time inserted between the complementary outputs. DT correspond to this duration.

DTG[7:5]=0xx = DT=DTG[7:0]x tsubdtg/sub with tsubdtg/sub=tsubDTS/sub

DTG[7:5]=10x = DT=(64+DTG[5:0])xtsubdtg/sub with Tsubdtg/sub=2xtsubDTS/sub

DTG[7:5]=110 = DT=(32+DTG[4:0])xtsubdtg/sub with Tsubdtg/sub=8xtsubDTS/sub

DTG[7:5]=111 = DT=(32+DTG[4:0])xtsubdtg/sub with Tsubdtg/sub=16xtsubDTS/sub

Example if TsubDTS/sub=125ns (8MHz), dead-time possible values are:

0 to 15875 ns by 125 ns steps,

16 s to 31750 ns by 250 ns steps,

32 s to 63 s by 1 s steps,

64 s to 126 s by 2 s steps

Note: This bit-field can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCK</name>
              <description>Lock configuration

These bits offer a write protection against software errors.

Note: The LOCK bits can be written only once after the reset. Once the TIMx_BDTR register has been written, their content is frozen until the next reset.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>LOCK OFF - No bit is write protected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>LOCK Level 1 = DTG bits in TIMx_BDTR register, OISx and OISxN bits in TIMx_CR2 register and BKBID/BKE/BKP/AOE bits in TIMx_BDTR register can no longer be written.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>LOCK Level 2 = LOCK Level 1 + CC Polarity bits (CCxP/CCxNP bits in TIMx_CCER register, as long as the related channel is configured in output through the CCxS bits) as well as OSSR and OSSI bits can no longer be written.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>LOCK Level 3 = LOCK Level 2 + CC Control bits (OCxM and OCxPE bits in TIMx_CCMRx registers, as long as the related channel is configured in output through the CCxS bits) can no longer be written.</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OSSI</name>
              <description>Off-state selection for Idle mode

This bit is used when MOE=0 on channels configured as outputs.

See tim_oc1/tim_oc1n enable description for more details (Section 30.6.8: TIMx capture/compare enable register (TIMx_CCER)(x = 16 to 17) on page 1404).

Note: This bit can not be modified as soon as the LOCK level 2 has been programmed (LOCK bits in TIMx_BDTR register).</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>When inactive, tim_oc1/tim_oc1n outputs are disabled (tim_oc1/tim_oc1n enable output signal=0)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>When inactive, tim_oc1/tim_oc1n outputs are forced first with their idle level as soon as CC1E=1 or CC1NE=1. tim_oc1/tim_oc1n enable output signal=1)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OSSR</name>
              <description>Off-state selection for Run mode

This bit is used when MOE=1 on channels that have a complementary output which are configured as outputs. OSSR is not implemented if no complementary output is implemented in the timer.

See tim_oc1/tim_oc1n enable description for more details (Section 30.6.8: TIMx capture/compare enable register (TIMx_CCER)(x = 16 to 17) on page 1404).

Note: This bit can not be modified as soon as the LOCK level 2 has been programmed (LOCK bits in TIMx_BDTR register).</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>When inactive, tim_oc1/tim_oc1n outputs are disabled (the timer releases the output control which is taken over by the GPIO, which forces a Hi-Z state)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>When inactive, tim_oc1/tim_oc1n outputs are enabled with their inactive level as soon as CC1E=1 or CC1NE=1 (the output is still controlled by the timer).</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BKE</name>
              <description>Break enable

1; Break inputs (tim_brk and tim_sys_brk event) enabled

Note: This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).

Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Break inputs (tim_brk and tim_sys_brk event) disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BKP</name>
              <description>Break polarity

Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).

Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Break input tim_brk is active low</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Break input tim_brk is active high</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AOE</name>
              <description>Automatic output enable

Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>MOE can be set only by software</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>MOE can be set by software or automatically at the next update event (if the tim_brk input is not active)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MOE</name>
              <description>Main output enable

This bit is cleared asynchronously by hardware as soon as the tim_brk input is active. It is set by software or automatically depending on the AOE bit. It is acting only on the channels which are configured in output.

See tim_oc1/tim_oc1n enable description for more details (Section 30.6.8: TIMx capture/compare enable register (TIMx_CCER)(x = 16 to 17) on page 1404).</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>tim_oc1 and tim_oc1n outputs are disabled or forced to idle state depending on the OSSI bit.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_oc1 and tim_oc1n outputs are enabled if their respective enable bits are set (CC1E, CC1NE in TIMx_CCER register)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BKF</name>
              <description>Break filter

This bit-field defines the frequency used to sample tim_brk input and the length of the digital filter applied to tim_brk. The digital filter is made of an event counter in which N events are needed to validate a transition on the output:

This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No filter, tim_brk acts asynchronously</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>fsubSAMPLING/sub=fsubtim_ker_ck/sub, N=2</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>fsubSAMPLING/sub=fsubtim_ker_ck/sub, N=4</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>fsubSAMPLING/sub=fsubtim_ker_ck/sub, N=8</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/2, N=6</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/2, N=8</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x6</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/4, N=6</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/4, N=8</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x8</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/8, N=6</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x9</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/8, N=8</description>
                  <value>0x9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xA</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/16, N=5</description>
                  <value>0xA</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xB</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/16, N=6</description>
                  <value>0xB</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xC</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/16, N=8</description>
                  <value>0xC</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xD</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/32, N=5</description>
                  <value>0xD</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xE</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/32, N=6</description>
                  <value>0xE</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xF</name>
                  <description>fsubSAMPLING/sub=fsubDTS/sub/32, N=8</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BKDSRM</name>
              <description>Break Disarm

This bit is cleared by hardware when no break source is active.

The BKDSRM bit must be set by software to release the bidirectional output control (open-drain output in Hi-Z state) and then be polled it until it is reset by hardware, indicating that the fault condition has disappeared.

Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Break input tim_brk is armed</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Break input tim_brk is disarmed</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BKBID</name>
              <description>Break Bidirectional

In the bidirectional mode (BKBID bit set to 1), the break input is configured both in input mode and in open drain output mode. Any active break event asserts a low logic level on the Break input to indicate an internal break event to external devices.

Note: This bit cannot be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).

Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Break input tim_brk in input mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Break input tim_brk in bidirectional mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM16_DTR2</name>
          <displayName>TIM16_DTR2</displayName>
          <description>TIM16 timer deadtime register 2</description>
          <addressOffset>0x054</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DTGF</name>
              <description>Dead-time falling edge generator setup

This bit-field defines the duration of the dead-time inserted between the complementary outputs, on the falling edge.

DTGF[7:5]=0xx = DTF=DTGF[7:0]x tsubdtg/sub with tsubdtg/sub=tsubDTS/sub.

DTGF[7:5]=10x = DTF=(64+DTGF[5:0])xtsubdtg/sub with Tsubdtg/sub=2xtsubDTS/sub.

DTGF[7:5]=110 = DTF=(32+DTGF[4:0])xtsubdtg/sub with Tsubdtg/sub=8xtsubDTS/sub.

DTGF[7:5]=111 = DTF=(32+DTGF[4:0])xtsubdtg/sub with Tsubdtg/sub=16xtsubDTS/sub.

Example if TsubDTS/sub=125ns (8MHz), dead-time possible values are:

0 to 15875 ns by 125 ns steps,

16 us to 31750 ns by 250 ns steps,

32 us to 63us by 1 us steps,

64 us to 126 us by 2 us steps

Note: This bit-field can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DTAE</name>
              <description>Deadtime asymmetric enable

Note: This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Deadtime on rising and falling edges are identical, and defined with DTG[7:0] register</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Deadtime on rising edge is defined with DTG[7:0] register and deadtime on falling edge is defined with DTGF[7:0] bits.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DTPE</name>
              <description>Deadtime preload enable

Note: This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Deadtime value is not preloaded</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Deadtime value preload is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM16_TISEL</name>
          <displayName>TIM16_TISEL</displayName>
          <description>TIM16 input selection register</description>
          <addressOffset>0x5C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TI1SEL</name>
              <description>selects tim_ti1_in[15:0] input

...

Refer to Section 30.3.2: TIM16/TIM17 pins and internal signals for interconnects list.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>TIMx_CH1 input (tim_ti1_in0)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_ti1_in1</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xF</name>
                  <description>tim_ti1_in15</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM16_AF1</name>
          <displayName>TIM16_AF1</displayName>
          <description>TIM16 alternate function register 1</description>
          <addressOffset>0x060</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BKINE</name>
              <description>TIMx_BKIN input enable

This bit enables the TIMx_BKIN alternate function input for the timer's tim_brk input. TIMx_BKIN input is 'ORed' with the other tim_brk sources.

Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>TIMx_BKIN input disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>TIMx_BKIN input enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BKCMP1E</name>
              <description>tim_brk_cmp1 enable

This bit enables the tim_brk_cmp1 for the timer's tim_brk input. tim_brk_cmp1 output is 'ORed' with the other tim_brk sources.

Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>tim_brk_cmp1 input disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_brk_cmp1 input enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BKCMP2E</name>
              <description>tim_brk_cmp2 enable

This bit enables the tim_brk_cmp2 for the timer's tim_brk input. tim_brk_cmp2 output is 'ORed' with the other tim_brk sources.

Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>tim_brk_cmp2 input disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_brk_cmp2 input enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BKCMP3E</name>
              <description>tim_brk_cmp3 enable

This bit enables the tim_brk_cmp3 for the timer's tim_brk input. tim_brk_cmp3 output is 'ORed' with the other tim_brk sources.

Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>tim_brk_cmp3 input disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_brk_cmp3 input enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BKCMP4E</name>
              <description>tim_brk_cmp4 enable

This bit enables the tim_brk_cmp4 for the timer's tim_brk input. tim_brk_cmp4 output is 'ORed' with the other tim_brk sources.

Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>tim_brk_cmp4 input disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_brk_cmp4 input enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BKCMP5E</name>
              <description>tim_brk_cmp5 enable

This bit enables the tim_brk_cmp5 for the timer's tim_brk input. tim_brk_cmp5 output is 'ORed' with the other tim_brk sources.

Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>tim_brk_cmp5 input disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_brk_cmp5 input enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BKCMP6E</name>
              <description>tim_brk_cmp6 enable

This bit enables the tim_brk_cmp6 for the timer's tim_brk input. tim_brk_cmp6 output is 'ORed' with the other tim_brk sources.

Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>tim_brk_cmp6 input disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_brk_cmp6 input enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BKCMP7E</name>
              <description>tim_brk_cmp7 enable

This bit enables the tim_brk_cmp7 for the timer's tim_brk input. tim_brk_cmp7 output is 'ORed' with the other tim_brk sources.

Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>tim_brk_cmp7 input disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_brk_cmp7 input enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BKCMP8E</name>
              <description>tim_brk_cmp8 enable

This bit enables the tim_brk_cmp8 for the timer's tim_brk input. mdf_brkx output is 'ORed' with the other tim_brk sources.

Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>tim_brk_cmp8 input disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_brk_cmp8 input enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BKINP</name>
              <description>TIMx_BKIN input polarity

This bit selects the TIMx_BKIN alternate function input sensitivity. It must be programmed together with the BKP polarity bit.

Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>TIMx_BKIN input is active high</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>TIMx_BKIN input is active low</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BKCMP1P</name>
              <description>tim_brk_cmp1 input polarity

This bit selects the tim_brk_cmp1 input sensitivity. It must be programmed together with the BKP polarity bit.

Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>tim_brk_cmp1 input is active high</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_brk_cmp1 input is active low</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BKCMP2P</name>
              <description>tim_brk_cmp2 input polarity

This bit selects the tim_brk_cmp2 input sensitivity. It must be programmed together with the BKP polarity bit.

Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>tim_brk_cmp2 input is active high</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_brk_cmp2 input is active low</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BKCMP3P</name>
              <description>tim_brk_cmp3 input polarity

This bit selects the tim_brk_cmp3 input sensitivity. It must be programmed together with the BKP polarity bit.

Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>tim_brk_cmp3 input is active high</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_brk_cmp3 input is active low</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BKCMP4P</name>
              <description>tim_brk_cmp4 input polarity

This bit selects the tim_brk_cmp4 input sensitivity. It must be programmed together with the BKP polarity bit.

Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>tim_brk_cmp4 input is active high</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_brk_cmp4 input is active low</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM16_AF2</name>
          <displayName>TIM16_AF2</displayName>
          <description>TIM16 alternate function register 2</description>
          <addressOffset>0x064</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OCRSEL</name>
              <description>tim_ocref_clr source selection

These bits select the tim_ocref_clr input source.

Refer to Section 30.3.2: TIM16/TIM17 pins and internal signals for product specific implementation.

Note: These bits can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>tim_ocref_clr0</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>tim_ocref_clr1</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>tim_ocref_clr2</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>tim_ocref_clr3</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>tim_ocref_clr4</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>tim_ocref_clr5</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x6</name>
                  <description>tim_ocref_clr6</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7</name>
                  <description>tim_ocref_clr7</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM16_OR1</name>
          <displayName>TIM16_OR1</displayName>
          <description>TIM16 option register 1</description>
          <addressOffset>0x68</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HSE32EN</name>
              <description>HSE Divided by 32 enable

This bit enables the HSE divider by 32 for the tim_ti1_in3. See Table 296: Interconnect to the tim_ti1 input multiplexer for details.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>HSE divided by 32 disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>HSE divided by 32 enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM16_DCR</name>
          <displayName>TIM16_DCR</displayName>
          <description>TIM16 DMA control register</description>
          <addressOffset>0x3DC</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DBA</name>
              <description>DMA base address

This 5-bit field defines the base-address for DMA transfers (when read/write access are done through the TIMx_DMAR address). DBA is defined as an offset starting from the address of the TIMx_CR1 register.

Example:

...

Example: Let us consider the following transfer: DBL = 7 transfers and DBA = TIMx_CR1. In this case the transfer is done to/from 7 registers starting from the TIMx_CR1 address.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>TIMx_CR1,</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>TIMx_CR2,</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>TIMx_SMCR,</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DBL</name>
              <description>DMA burst length

This 5-bit field defines the length of DMA transfers (the timer recognizes a burst transfer when a read or a write access is done to the TIMx_DMAR address), i.e. the number of transfers. Transfers can be in half-words or in bytes (see example below).

...</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>1 transfer,</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>2 transfers,</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>3 transfers,</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x11</name>
                  <description>18 transfers.</description>
                  <value>0x11</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DBSS</name>
              <description>DMA burst source selection

This bitfield defines the interrupt source that triggers the DMA burst transfers (the timer recognizes a burst transfer when a read or a write access is done to the TIMx_DMAR address).

Other: reserved</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Update</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>CC1</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>TIM16_DMAR</name>
          <displayName>TIM16_DMAR</displayName>
          <description>TIM16/TIM17 DMA address for full transfer</description>
          <addressOffset>0x3E0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMAB</name>
              <description>DMA register for burst accesses

A read or write operation to the DMAR register accesses the register located at the address

(TIMx_CR1 address) + (DBA + DMA index) x 4 

where TIMx_CR1 address is the address of the control register 1, DBA is the DMA base address configured in TIMx_DCR register, DMA index is automatically controlled by the DMA transfer, and ranges from 0 to DBL (DBL configured in TIMx_DCR).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>TSC</name>
      <description>Touch sensing controller</description>
      <groupName>TSC</groupName>
      <baseAddress>0x40024000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x400</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>TSC</name>
        <description>TSC global interrupt</description>
        <value>57</value>
      </interrupt>
      <registers>
        <register>
          <name>TSC_CR</name>
          <displayName>TSC_CR</displayName>
          <description>TSC control register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TSCE</name>
              <description>Touch sensing controller enable
This bit is set and cleared by software to enable/disable the touch sensing controller.
Note: When the touch sensing controller is disabled, TSC registers settings have no effect.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Touch sensing controller disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Touch sensing controller enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>START</name>
              <description>Start a new acquisition
This bit is set by software to start a new acquisition. It is cleared by hardware as soon as the acquisition is complete or by software to cancel the ongoing acquisition.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Acquisition not started</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Start a new acquisition</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AM</name>
              <description>Acquisition mode
This bit is set and cleared by software to select the acquisition mode.
Note: This bit must not be modified when an acquisition is ongoing.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Normal acquisition mode (acquisition starts as soon as START bit is set)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Synchronized acquisition mode (acquisition starts if START bit is set and when the selected signal is detected on the SYNC input pin)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SYNCPOL</name>
              <description>Synchronization pin polarity
This bit is set and cleared by software to select the polarity of the synchronization input pin.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Falling edge only</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Rising edge and high level</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IODEF</name>
              <description>I/O Default mode
This bit is set and cleared by software. It defines the configuration of all the TSC I/Os when there is no ongoing acquisition. When there is an ongoing acquisition, it defines the configuration of all unused I/Os (not defined as sampling capacitor I/O or as channel I/O).
Note: This bit must not be modified when an acquisition is ongoing.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>I/Os are forced to output push-pull low</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>I/Os are in input floating</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MCV</name>
              <description>Max count value
These bits are set and cleared by software. They define the maximum number of charge transfer pulses that can be generated before a max count error is generated.
Note: These bits must not be modified when an acquisition is ongoing.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>255</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>511</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>1023</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>2047</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>4095</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>8191</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x6</name>
                  <description>16383</description>
                  <value>0x6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PGPSC</name>
              <description>Pulse generator prescaler
These bits are set and cleared by software.They select the AHB clock divider used to generate the pulse generator clock (PGCLK).
Note: These bits must not be modified when an acquisition is ongoing.
Note: Some configurations are forbidden. Refer to the Section21.3.4: Charge transfer acquisition sequence for details.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>fsubHCLK/sub</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>fsubHCLK/sub /2</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>fsubHCLK/sub /4</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>fsubHCLK/sub /8</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>fsubHCLK/sub /16</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>fsubHCLK/sub /32</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x6</name>
                  <description>fsubHCLK/sub /64</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7</name>
                  <description>fsubHCLK/sub /128</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SSPSC</name>
              <description>Spread spectrum prescaler
This bit is set and cleared by software. It selects the AHB clock divider used to generate the spread spectrum clock (SSCLK).
Note: This bit must not be modified when an acquisition is ongoing.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>fsubHCLK/sub</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>fsubHCLK/sub /2</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SSE</name>
              <description>Spread spectrum enable
This bit is set and cleared by software to enable/disable the spread spectrum feature.
Note: This bit must not be modified when an acquisition is ongoing.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Spread spectrum disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Spread spectrum enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SSD</name>
              <description>Spread spectrum deviation
These bits are set and cleared by software. They define the spread spectrum deviation which consists in adding a variable number of periods of the SSCLK clock to the charge transfer pulse high state.
...
Note: These bits must not be modified when an acquisition is ongoing.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>1x tsubSSCLK/sub</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>2x tsubSSCLK/sub</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7F</name>
                  <description>128x tsubSSCLK/sub</description>
                  <value>0x7F</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CTPL</name>
              <description>Charge transfer pulse low
These bits are set and cleared by software. They define the duration of the low state of the charge transfer pulse (transfer of charge from CsubX/sub to CsubS/sub).
...
Note: These bits must not be modified when an acquisition is ongoing.
Note: Some configurations are forbidden. Refer to the Section21.3.4: Charge transfer acquisition sequence for details.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>1x tsubPGCLK/sub</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>2x tsubPGCLK/sub</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xF</name>
                  <description>16x tsubPGCLK/sub</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CTPH</name>
              <description>Charge transfer pulse high
These bits are set and cleared by software. They define the duration of the high state of the charge transfer pulse (charge of CsubX/sub).
...
Note: These bits must not be modified when an acquisition is ongoing.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>1x tsubPGCLK/sub</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>2x tsubPGCLK/sub</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xF</name>
                  <description>16x tsubPGCLK/sub</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>TSC_IER</name>
          <displayName>TSC_IER</displayName>
          <description>TSC interrupt enable register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EOAIE</name>
              <description>End of acquisition interrupt enable
This bit is set and cleared by software to enable/disable the end of acquisition interrupt.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>End of acquisition interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>End of acquisition interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MCEIE</name>
              <description>Max count error interrupt enable
This bit is set and cleared by software to enable/disable the max count error interrupt.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Max count error interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Max count error interrupt enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>TSC_ICR</name>
          <displayName>TSC_ICR</displayName>
          <description>TSC interrupt clear register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EOAIC</name>
              <description>End of acquisition interrupt clear
This bit is set by software to clear the end of acquisition flag and it is cleared by hardware when the flag is reset. Writing a '0' has no effect.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Clears the corresponding EOAF of the TSC_ISR register</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MCEIC</name>
              <description>Max count error interrupt clear
This bit is set by software to clear the max count error flag and it is cleared by hardware when the flag is reset. Writing a '0' has no effect.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Clears the corresponding MCEF of the TSC_ISR register</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>TSC_ISR</name>
          <displayName>TSC_ISR</displayName>
          <description>TSC interrupt status register</description>
          <addressOffset>0x0C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EOAF</name>
              <description>End of acquisition flag
This bit is set by hardware when the acquisition of all enabled group is complete (all GxS bits of all enabled analog I/O groups are set or when a max count error is detected). It is cleared by software writing 1 to the bit EOAIC of the TSC_ICR register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Acquisition is ongoing or not started</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Acquisition is complete</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MCEF</name>
              <description>Max count error flag
This bit is set by hardware as soon as an analog I/O group counter reaches the max count value specified. It is cleared by software writing 1 to the bit MCEIC of the TSC_ICR register.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No max count error (MCE) detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Max count error (MCE) detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>TSC_IOHCR</name>
          <displayName>TSC_IOHCR</displayName>
          <description>TSC I/O hysteresis control register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>G1_IO1</name>
              <description>Gx_IOy Schmitt trigger hysteresis mode, x = 8 to 1, y = 4 to 1.
These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.
Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy Schmitt trigger hysteresis disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy Schmitt trigger hysteresis enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G1_IO2</name>
              <description>Gx_IOy Schmitt trigger hysteresis mode, x = 8 to 1, y = 4 to 1.
These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.
Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy Schmitt trigger hysteresis disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy Schmitt trigger hysteresis enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G1_IO3</name>
              <description>Gx_IOy Schmitt trigger hysteresis mode, x = 8 to 1, y = 4 to 1.
These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.
Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy Schmitt trigger hysteresis disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy Schmitt trigger hysteresis enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G1_IO4</name>
              <description>Gx_IOy Schmitt trigger hysteresis mode, x = 8 to 1, y = 4 to 1.
These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.
Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy Schmitt trigger hysteresis disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy Schmitt trigger hysteresis enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G2_IO1</name>
              <description>Gx_IOy Schmitt trigger hysteresis mode, x = 8 to 1, y = 4 to 1.
These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.
Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy Schmitt trigger hysteresis disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy Schmitt trigger hysteresis enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G2_IO2</name>
              <description>Gx_IOy Schmitt trigger hysteresis mode, x = 8 to 1, y = 4 to 1.
These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.
Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy Schmitt trigger hysteresis disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy Schmitt trigger hysteresis enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G2_IO3</name>
              <description>Gx_IOy Schmitt trigger hysteresis mode, x = 8 to 1, y = 4 to 1.
These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.
Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy Schmitt trigger hysteresis disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy Schmitt trigger hysteresis enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G2_IO4</name>
              <description>Gx_IOy Schmitt trigger hysteresis mode, x = 8 to 1, y = 4 to 1.
These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.
Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy Schmitt trigger hysteresis disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy Schmitt trigger hysteresis enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G3_IO1</name>
              <description>Gx_IOy Schmitt trigger hysteresis mode, x = 8 to 1, y = 4 to 1.
These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.
Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy Schmitt trigger hysteresis disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy Schmitt trigger hysteresis enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G3_IO2</name>
              <description>Gx_IOy Schmitt trigger hysteresis mode, x = 8 to 1, y = 4 to 1.
These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.
Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy Schmitt trigger hysteresis disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy Schmitt trigger hysteresis enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G3_IO3</name>
              <description>Gx_IOy Schmitt trigger hysteresis mode, x = 8 to 1, y = 4 to 1.
These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.
Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy Schmitt trigger hysteresis disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy Schmitt trigger hysteresis enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G3_IO4</name>
              <description>Gx_IOy Schmitt trigger hysteresis mode, x = 8 to 1, y = 4 to 1.
These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.
Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy Schmitt trigger hysteresis disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy Schmitt trigger hysteresis enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G4_IO1</name>
              <description>Gx_IOy Schmitt trigger hysteresis mode, x = 8 to 1, y = 4 to 1.
These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.
Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy Schmitt trigger hysteresis disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy Schmitt trigger hysteresis enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G4_IO2</name>
              <description>Gx_IOy Schmitt trigger hysteresis mode, x = 8 to 1, y = 4 to 1.
These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.
Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy Schmitt trigger hysteresis disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy Schmitt trigger hysteresis enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G4_IO3</name>
              <description>Gx_IOy Schmitt trigger hysteresis mode, x = 8 to 1, y = 4 to 1.
These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.
Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy Schmitt trigger hysteresis disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy Schmitt trigger hysteresis enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G4_IO4</name>
              <description>Gx_IOy Schmitt trigger hysteresis mode, x = 8 to 1, y = 4 to 1.
These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.
Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy Schmitt trigger hysteresis disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy Schmitt trigger hysteresis enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G5_IO1</name>
              <description>Gx_IOy Schmitt trigger hysteresis mode, x = 8 to 1, y = 4 to 1.
These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.
Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy Schmitt trigger hysteresis disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy Schmitt trigger hysteresis enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G5_IO2</name>
              <description>Gx_IOy Schmitt trigger hysteresis mode, x = 8 to 1, y = 4 to 1.
These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.
Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy Schmitt trigger hysteresis disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy Schmitt trigger hysteresis enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G5_IO3</name>
              <description>Gx_IOy Schmitt trigger hysteresis mode, x = 8 to 1, y = 4 to 1.
These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.
Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy Schmitt trigger hysteresis disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy Schmitt trigger hysteresis enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G5_IO4</name>
              <description>Gx_IOy Schmitt trigger hysteresis mode, x = 8 to 1, y = 4 to 1.
These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.
Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy Schmitt trigger hysteresis disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy Schmitt trigger hysteresis enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G6_IO1</name>
              <description>Gx_IOy Schmitt trigger hysteresis mode, x = 8 to 1, y = 4 to 1.
These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.
Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy Schmitt trigger hysteresis disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy Schmitt trigger hysteresis enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G6_IO2</name>
              <description>Gx_IOy Schmitt trigger hysteresis mode, x = 8 to 1, y = 4 to 1.
These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.
Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy Schmitt trigger hysteresis disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy Schmitt trigger hysteresis enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G6_IO3</name>
              <description>Gx_IOy Schmitt trigger hysteresis mode, x = 8 to 1, y = 4 to 1.
These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.
Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy Schmitt trigger hysteresis disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy Schmitt trigger hysteresis enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G6_IO4</name>
              <description>Gx_IOy Schmitt trigger hysteresis mode, x = 8 to 1, y = 4 to 1.
These bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.
Note: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers).</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy Schmitt trigger hysteresis disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy Schmitt trigger hysteresis enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>TSC_IOASCR</name>
          <displayName>TSC_IOASCR</displayName>
          <description>TSC I/O analog switch control register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>G1_IO1</name>
              <description>Gx_IOy analog switch enable
These bits are set and cleared by software to enable/disable the Gx_IOy analog switch.
Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy analog switch disabled (opened)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy analog switch enabled (closed)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G1_IO2</name>
              <description>Gx_IOy analog switch enable
These bits are set and cleared by software to enable/disable the Gx_IOy analog switch.
Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy analog switch disabled (opened)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy analog switch enabled (closed)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G1_IO3</name>
              <description>Gx_IOy analog switch enable
These bits are set and cleared by software to enable/disable the Gx_IOy analog switch.
Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy analog switch disabled (opened)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy analog switch enabled (closed)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G1_IO4</name>
              <description>Gx_IOy analog switch enable
These bits are set and cleared by software to enable/disable the Gx_IOy analog switch.
Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy analog switch disabled (opened)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy analog switch enabled (closed)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G2_IO1</name>
              <description>Gx_IOy analog switch enable
These bits are set and cleared by software to enable/disable the Gx_IOy analog switch.
Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy analog switch disabled (opened)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy analog switch enabled (closed)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G2_IO2</name>
              <description>Gx_IOy analog switch enable
These bits are set and cleared by software to enable/disable the Gx_IOy analog switch.
Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy analog switch disabled (opened)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy analog switch enabled (closed)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G2_IO3</name>
              <description>Gx_IOy analog switch enable
These bits are set and cleared by software to enable/disable the Gx_IOy analog switch.
Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy analog switch disabled (opened)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy analog switch enabled (closed)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G2_IO4</name>
              <description>Gx_IOy analog switch enable
These bits are set and cleared by software to enable/disable the Gx_IOy analog switch.
Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy analog switch disabled (opened)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy analog switch enabled (closed)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G3_IO1</name>
              <description>Gx_IOy analog switch enable
These bits are set and cleared by software to enable/disable the Gx_IOy analog switch.
Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy analog switch disabled (opened)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy analog switch enabled (closed)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G3_IO2</name>
              <description>Gx_IOy analog switch enable
These bits are set and cleared by software to enable/disable the Gx_IOy analog switch.
Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy analog switch disabled (opened)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy analog switch enabled (closed)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G3_IO3</name>
              <description>Gx_IOy analog switch enable
These bits are set and cleared by software to enable/disable the Gx_IOy analog switch.
Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy analog switch disabled (opened)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy analog switch enabled (closed)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G3_IO4</name>
              <description>Gx_IOy analog switch enable
These bits are set and cleared by software to enable/disable the Gx_IOy analog switch.
Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy analog switch disabled (opened)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy analog switch enabled (closed)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G4_IO1</name>
              <description>Gx_IOy analog switch enable
These bits are set and cleared by software to enable/disable the Gx_IOy analog switch.
Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy analog switch disabled (opened)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy analog switch enabled (closed)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G4_IO2</name>
              <description>Gx_IOy analog switch enable
These bits are set and cleared by software to enable/disable the Gx_IOy analog switch.
Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy analog switch disabled (opened)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy analog switch enabled (closed)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G4_IO3</name>
              <description>Gx_IOy analog switch enable
These bits are set and cleared by software to enable/disable the Gx_IOy analog switch.
Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy analog switch disabled (opened)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy analog switch enabled (closed)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G4_IO4</name>
              <description>Gx_IOy analog switch enable
These bits are set and cleared by software to enable/disable the Gx_IOy analog switch.
Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy analog switch disabled (opened)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy analog switch enabled (closed)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G5_IO1</name>
              <description>Gx_IOy analog switch enable
These bits are set and cleared by software to enable/disable the Gx_IOy analog switch.
Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy analog switch disabled (opened)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy analog switch enabled (closed)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G5_IO2</name>
              <description>Gx_IOy analog switch enable
These bits are set and cleared by software to enable/disable the Gx_IOy analog switch.
Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy analog switch disabled (opened)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy analog switch enabled (closed)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G5_IO3</name>
              <description>Gx_IOy analog switch enable
These bits are set and cleared by software to enable/disable the Gx_IOy analog switch.
Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy analog switch disabled (opened)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy analog switch enabled (closed)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G5_IO4</name>
              <description>Gx_IOy analog switch enable
These bits are set and cleared by software to enable/disable the Gx_IOy analog switch.
Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy analog switch disabled (opened)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy analog switch enabled (closed)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G6_IO1</name>
              <description>Gx_IOy analog switch enable
These bits are set and cleared by software to enable/disable the Gx_IOy analog switch.
Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy analog switch disabled (opened)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy analog switch enabled (closed)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G6_IO2</name>
              <description>Gx_IOy analog switch enable
These bits are set and cleared by software to enable/disable the Gx_IOy analog switch.
Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy analog switch disabled (opened)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy analog switch enabled (closed)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G6_IO3</name>
              <description>Gx_IOy analog switch enable
These bits are set and cleared by software to enable/disable the Gx_IOy analog switch.
Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy analog switch disabled (opened)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy analog switch enabled (closed)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G6_IO4</name>
              <description>Gx_IOy analog switch enable
These bits are set and cleared by software to enable/disable the Gx_IOy analog switch.
Note: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers).</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy analog switch disabled (opened)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy analog switch enabled (closed)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>TSC_IOSCR</name>
          <displayName>TSC_IOSCR</displayName>
          <description>TSC I/O sampling control register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>G1_IO1</name>
              <description>Gx_IOy sampling mode
These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.
Note: These bits must not be modified when an acquisition is ongoing.
Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy unused</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy used as sampling capacitor</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G1_IO2</name>
              <description>Gx_IOy sampling mode
These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.
Note: These bits must not be modified when an acquisition is ongoing.
Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy unused</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy used as sampling capacitor</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G1_IO3</name>
              <description>Gx_IOy sampling mode
These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.
Note: These bits must not be modified when an acquisition is ongoing.
Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy unused</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy used as sampling capacitor</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G1_IO4</name>
              <description>Gx_IOy sampling mode
These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.
Note: These bits must not be modified when an acquisition is ongoing.
Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy unused</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy used as sampling capacitor</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G2_IO1</name>
              <description>Gx_IOy sampling mode
These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.
Note: These bits must not be modified when an acquisition is ongoing.
Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy unused</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy used as sampling capacitor</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G2_IO2</name>
              <description>Gx_IOy sampling mode
These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.
Note: These bits must not be modified when an acquisition is ongoing.
Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy unused</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy used as sampling capacitor</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G2_IO3</name>
              <description>Gx_IOy sampling mode
These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.
Note: These bits must not be modified when an acquisition is ongoing.
Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy unused</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy used as sampling capacitor</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G2_IO4</name>
              <description>Gx_IOy sampling mode
These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.
Note: These bits must not be modified when an acquisition is ongoing.
Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy unused</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy used as sampling capacitor</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G3_IO1</name>
              <description>Gx_IOy sampling mode
These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.
Note: These bits must not be modified when an acquisition is ongoing.
Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy unused</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy used as sampling capacitor</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G3_IO2</name>
              <description>Gx_IOy sampling mode
These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.
Note: These bits must not be modified when an acquisition is ongoing.
Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy unused</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy used as sampling capacitor</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G3_IO3</name>
              <description>Gx_IOy sampling mode
These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.
Note: These bits must not be modified when an acquisition is ongoing.
Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy unused</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy used as sampling capacitor</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G3_IO4</name>
              <description>Gx_IOy sampling mode
These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.
Note: These bits must not be modified when an acquisition is ongoing.
Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy unused</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy used as sampling capacitor</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G4_IO1</name>
              <description>Gx_IOy sampling mode
These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.
Note: These bits must not be modified when an acquisition is ongoing.
Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy unused</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy used as sampling capacitor</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G4_IO2</name>
              <description>Gx_IOy sampling mode
These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.
Note: These bits must not be modified when an acquisition is ongoing.
Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy unused</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy used as sampling capacitor</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G4_IO3</name>
              <description>Gx_IOy sampling mode
These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.
Note: These bits must not be modified when an acquisition is ongoing.
Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy unused</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy used as sampling capacitor</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G4_IO4</name>
              <description>Gx_IOy sampling mode
These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.
Note: These bits must not be modified when an acquisition is ongoing.
Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy unused</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy used as sampling capacitor</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G5_IO1</name>
              <description>Gx_IOy sampling mode
These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.
Note: These bits must not be modified when an acquisition is ongoing.
Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy unused</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy used as sampling capacitor</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G5_IO2</name>
              <description>Gx_IOy sampling mode
These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.
Note: These bits must not be modified when an acquisition is ongoing.
Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy unused</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy used as sampling capacitor</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G5_IO3</name>
              <description>Gx_IOy sampling mode
These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.
Note: These bits must not be modified when an acquisition is ongoing.
Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy unused</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy used as sampling capacitor</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G5_IO4</name>
              <description>Gx_IOy sampling mode
These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.
Note: These bits must not be modified when an acquisition is ongoing.
Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy unused</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy used as sampling capacitor</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G6_IO1</name>
              <description>Gx_IOy sampling mode
These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.
Note: These bits must not be modified when an acquisition is ongoing.
Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy unused</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy used as sampling capacitor</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G6_IO2</name>
              <description>Gx_IOy sampling mode
These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.
Note: These bits must not be modified when an acquisition is ongoing.
Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy unused</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy used as sampling capacitor</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G6_IO3</name>
              <description>Gx_IOy sampling mode
These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.
Note: These bits must not be modified when an acquisition is ongoing.
Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy unused</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy used as sampling capacitor</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G6_IO4</name>
              <description>Gx_IOy sampling mode
These bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.
Note: These bits must not be modified when an acquisition is ongoing.
Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy unused</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy used as sampling capacitor</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>TSC_IOCCR</name>
          <displayName>TSC_IOCCR</displayName>
          <description>TSC I/O channel control register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>G1_IO1</name>
              <description>Gx_IOy channel mode
These bits are set and cleared by software to configure the Gx_IOy as a channel I/O.
Note: These bits must not be modified when an acquisition is ongoing.
Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy unused</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy used as channel</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G1_IO2</name>
              <description>Gx_IOy channel mode
These bits are set and cleared by software to configure the Gx_IOy as a channel I/O.
Note: These bits must not be modified when an acquisition is ongoing.
Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy unused</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy used as channel</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G1_IO3</name>
              <description>Gx_IOy channel mode
These bits are set and cleared by software to configure the Gx_IOy as a channel I/O.
Note: These bits must not be modified when an acquisition is ongoing.
Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy unused</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy used as channel</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G1_IO4</name>
              <description>Gx_IOy channel mode
These bits are set and cleared by software to configure the Gx_IOy as a channel I/O.
Note: These bits must not be modified when an acquisition is ongoing.
Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy unused</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy used as channel</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G2_IO1</name>
              <description>Gx_IOy channel mode
These bits are set and cleared by software to configure the Gx_IOy as a channel I/O.
Note: These bits must not be modified when an acquisition is ongoing.
Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy unused</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy used as channel</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G2_IO2</name>
              <description>Gx_IOy channel mode
These bits are set and cleared by software to configure the Gx_IOy as a channel I/O.
Note: These bits must not be modified when an acquisition is ongoing.
Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy unused</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy used as channel</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G2_IO3</name>
              <description>Gx_IOy channel mode
These bits are set and cleared by software to configure the Gx_IOy as a channel I/O.
Note: These bits must not be modified when an acquisition is ongoing.
Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy unused</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy used as channel</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G2_IO4</name>
              <description>Gx_IOy channel mode
These bits are set and cleared by software to configure the Gx_IOy as a channel I/O.
Note: These bits must not be modified when an acquisition is ongoing.
Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy unused</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy used as channel</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G3_IO1</name>
              <description>Gx_IOy channel mode
These bits are set and cleared by software to configure the Gx_IOy as a channel I/O.
Note: These bits must not be modified when an acquisition is ongoing.
Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy unused</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy used as channel</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G3_IO2</name>
              <description>Gx_IOy channel mode
These bits are set and cleared by software to configure the Gx_IOy as a channel I/O.
Note: These bits must not be modified when an acquisition is ongoing.
Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy unused</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy used as channel</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G3_IO3</name>
              <description>Gx_IOy channel mode
These bits are set and cleared by software to configure the Gx_IOy as a channel I/O.
Note: These bits must not be modified when an acquisition is ongoing.
Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy unused</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy used as channel</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G3_IO4</name>
              <description>Gx_IOy channel mode
These bits are set and cleared by software to configure the Gx_IOy as a channel I/O.
Note: These bits must not be modified when an acquisition is ongoing.
Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy unused</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy used as channel</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G4_IO1</name>
              <description>Gx_IOy channel mode
These bits are set and cleared by software to configure the Gx_IOy as a channel I/O.
Note: These bits must not be modified when an acquisition is ongoing.
Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy unused</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy used as channel</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G4_IO2</name>
              <description>Gx_IOy channel mode
These bits are set and cleared by software to configure the Gx_IOy as a channel I/O.
Note: These bits must not be modified when an acquisition is ongoing.
Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy unused</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy used as channel</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G4_IO3</name>
              <description>Gx_IOy channel mode
These bits are set and cleared by software to configure the Gx_IOy as a channel I/O.
Note: These bits must not be modified when an acquisition is ongoing.
Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy unused</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy used as channel</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G4_IO4</name>
              <description>Gx_IOy channel mode
These bits are set and cleared by software to configure the Gx_IOy as a channel I/O.
Note: These bits must not be modified when an acquisition is ongoing.
Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy unused</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy used as channel</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G5_IO1</name>
              <description>Gx_IOy channel mode
These bits are set and cleared by software to configure the Gx_IOy as a channel I/O.
Note: These bits must not be modified when an acquisition is ongoing.
Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy unused</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy used as channel</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G5_IO2</name>
              <description>Gx_IOy channel mode
These bits are set and cleared by software to configure the Gx_IOy as a channel I/O.
Note: These bits must not be modified when an acquisition is ongoing.
Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy unused</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy used as channel</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G5_IO3</name>
              <description>Gx_IOy channel mode
These bits are set and cleared by software to configure the Gx_IOy as a channel I/O.
Note: These bits must not be modified when an acquisition is ongoing.
Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy unused</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy used as channel</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G5_IO4</name>
              <description>Gx_IOy channel mode
These bits are set and cleared by software to configure the Gx_IOy as a channel I/O.
Note: These bits must not be modified when an acquisition is ongoing.
Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy unused</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy used as channel</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G6_IO1</name>
              <description>Gx_IOy channel mode
These bits are set and cleared by software to configure the Gx_IOy as a channel I/O.
Note: These bits must not be modified when an acquisition is ongoing.
Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy unused</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy used as channel</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G6_IO2</name>
              <description>Gx_IOy channel mode
These bits are set and cleared by software to configure the Gx_IOy as a channel I/O.
Note: These bits must not be modified when an acquisition is ongoing.
Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy unused</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy used as channel</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G6_IO3</name>
              <description>Gx_IOy channel mode
These bits are set and cleared by software to configure the Gx_IOy as a channel I/O.
Note: These bits must not be modified when an acquisition is ongoing.
Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy unused</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy used as channel</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G6_IO4</name>
              <description>Gx_IOy channel mode
These bits are set and cleared by software to configure the Gx_IOy as a channel I/O.
Note: These bits must not be modified when an acquisition is ongoing.
Note: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Gx_IOy unused</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Gx_IOy used as channel</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>TSC_IOGCSR</name>
          <displayName>TSC_IOGCSR</displayName>
          <description>TSC I/O group control status register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>G1E</name>
              <description>Analog I/O group x enable
These bits are set and cleared by software to enable/disable the acquisition (counter is counting) on the corresponding analog I/O group x.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Acquisition on analog I/O group x disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Acquisition on analog I/O group x enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G2E</name>
              <description>Analog I/O group x enable
These bits are set and cleared by software to enable/disable the acquisition (counter is counting) on the corresponding analog I/O group x.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Acquisition on analog I/O group x disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Acquisition on analog I/O group x enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G3E</name>
              <description>Analog I/O group x enable
These bits are set and cleared by software to enable/disable the acquisition (counter is counting) on the corresponding analog I/O group x.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Acquisition on analog I/O group x disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Acquisition on analog I/O group x enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G4E</name>
              <description>Analog I/O group x enable
These bits are set and cleared by software to enable/disable the acquisition (counter is counting) on the corresponding analog I/O group x.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Acquisition on analog I/O group x disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Acquisition on analog I/O group x enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G5E</name>
              <description>Analog I/O group x enable
These bits are set and cleared by software to enable/disable the acquisition (counter is counting) on the corresponding analog I/O group x.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Acquisition on analog I/O group x disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Acquisition on analog I/O group x enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G6E</name>
              <description>Analog I/O group x enable
These bits are set and cleared by software to enable/disable the acquisition (counter is counting) on the corresponding analog I/O group x.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Acquisition on analog I/O group x disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Acquisition on analog I/O group x enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G1S</name>
              <description>Analog I/O group x status
These bits are set by hardware when the acquisition on the corresponding enabled analog I/O group x is complete. They are cleared by hardware when a new acquisition is started.
Note: When a max count error is detected the remaining GxS bits of the enabled analog I/O groups are not set.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Acquisition on analog I/O group x is ongoing or not started</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Acquisition on analog I/O group x is complete</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G2S</name>
              <description>Analog I/O group x status
These bits are set by hardware when the acquisition on the corresponding enabled analog I/O group x is complete. They are cleared by hardware when a new acquisition is started.
Note: When a max count error is detected the remaining GxS bits of the enabled analog I/O groups are not set.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Acquisition on analog I/O group x is ongoing or not started</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Acquisition on analog I/O group x is complete</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G3S</name>
              <description>Analog I/O group x status
These bits are set by hardware when the acquisition on the corresponding enabled analog I/O group x is complete. They are cleared by hardware when a new acquisition is started.
Note: When a max count error is detected the remaining GxS bits of the enabled analog I/O groups are not set.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Acquisition on analog I/O group x is ongoing or not started</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Acquisition on analog I/O group x is complete</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G4S</name>
              <description>Analog I/O group x status
These bits are set by hardware when the acquisition on the corresponding enabled analog I/O group x is complete. They are cleared by hardware when a new acquisition is started.
Note: When a max count error is detected the remaining GxS bits of the enabled analog I/O groups are not set.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Acquisition on analog I/O group x is ongoing or not started</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Acquisition on analog I/O group x is complete</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G5S</name>
              <description>Analog I/O group x status
These bits are set by hardware when the acquisition on the corresponding enabled analog I/O group x is complete. They are cleared by hardware when a new acquisition is started.
Note: When a max count error is detected the remaining GxS bits of the enabled analog I/O groups are not set.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Acquisition on analog I/O group x is ongoing or not started</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Acquisition on analog I/O group x is complete</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>G6S</name>
              <description>Analog I/O group x status
These bits are set by hardware when the acquisition on the corresponding enabled analog I/O group x is complete. They are cleared by hardware when a new acquisition is started.
Note: When a max count error is detected the remaining GxS bits of the enabled analog I/O groups are not set.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Acquisition on analog I/O group x is ongoing or not started</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Acquisition on analog I/O group x is complete</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>TSC_IOG1CR</name>
          <displayName>TSC_IOG1CR</displayName>
          <description>TSC I/O group 1 counter register</description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNT</name>
              <description>Counter value
These bits represent the number of charge transfer cycles generated on the analog I/O group x to complete its acquisition (voltage across CsubS/sub has reached the threshold).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>14</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TSC_IOG2CR</name>
          <displayName>TSC_IOG2CR</displayName>
          <description>TSC I/O group 2 counter register</description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNT</name>
              <description>Counter value
These bits represent the number of charge transfer cycles generated on the analog I/O group x to complete its acquisition (voltage across CsubS/sub has reached the threshold).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>14</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TSC_IOG3CR</name>
          <displayName>TSC_IOG3CR</displayName>
          <description>TSC I/O group 3 counter register</description>
          <addressOffset>0x3C</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNT</name>
              <description>Counter value
These bits represent the number of charge transfer cycles generated on the analog I/O group x to complete its acquisition (voltage across CsubS/sub has reached the threshold).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>14</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TSC_IOG4CR</name>
          <displayName>TSC_IOG4CR</displayName>
          <description>TSC I/O group 4 counter register</description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNT</name>
              <description>Counter value
These bits represent the number of charge transfer cycles generated on the analog I/O group x to complete its acquisition (voltage across CsubS/sub has reached the threshold).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>14</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TSC_IOG5CR</name>
          <displayName>TSC_IOG5CR</displayName>
          <description>TSC I/O group 5 counter register</description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNT</name>
              <description>Counter value
These bits represent the number of charge transfer cycles generated on the analog I/O group x to complete its acquisition (voltage across CsubS/sub has reached the threshold).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>14</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TSC_IOG6CR</name>
          <displayName>TSC_IOG6CR</displayName>
          <description>TSC I/O group 6 counter register</description>
          <addressOffset>0x48</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNT</name>
              <description>Counter value
These bits represent the number of charge transfer cycles generated on the analog I/O group x to complete its acquisition (voltage across CsubS/sub has reached the threshold).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>14</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>USART1</name>
      <description>USART register block</description>
      <groupName>USART</groupName>
      <baseAddress>0x40013800</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x400</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>USART1</name>
        <description>USART1 global interrupt</description>
        <value>46</value>
      </interrupt>
      <registers>
        <register>
          <name>USART_CR1</name>
          <displayName>USART_CR1</displayName>
          <description>USART control register 1 [alternate]</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>UE</name>
              <description>USART enable

When this bit is cleared, the USART prescalers and outputs are stopped immediately, and all current operations are discarded. The USART configuration is kept, but all the USART_ISR status flags are reset. This bit is set and cleared by software.

Note: To enter low-power mode without generating errors on the line, the TE bit must be previously reset and the software must wait for the TC bit in the USART_ISR to be set before resetting the UE bit. 

Note: The DMA requests are also reset when UE = 0 so the DMA channel must be disabled before resetting the UE bit.

Note: In Smartcard mode, (SCEN = 1), the CK is always available when CLKEN = 1, regardless of the UE bit value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>USART prescaler and outputs disabled, low-power mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>USART enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UESM</name>
              <description>USART enable in low-power mode 

When this bit is cleared, the USART cannot request its kernel clock and is not functional in low-power mode.

When this bit is set, the USART can wake up the MCU from low-power mode.

This bit is set and cleared by software.

Note: The UESM bit must be set at the initialization phase. 

Note: If the USART does not support the wakeup from low-power mode, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>USART not functional in low-power mode.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>USART functional in low-power mode.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RE</name>
              <description>Receiver enable

This bit enables the receiver. It is set and cleared by software.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Receiver is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Receiver is enabled and begins searching for a start bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TE</name>
              <description>Transmitter enable

This bit enables the transmitter. When the Autonomous mode is not used, TE bit is set and cleared by software. When the Autonomous mode is used, TE bit becomes a status bit, which is set and cleared by hardware. 

Note: During transmission, a low pulse on the TE bit (0 followed by 1) sends a preamble (idle line) after the current word, except in Smartcard mode. In order to generate an idle character, the TE must not be immediately written to 1. To ensure the required duration, the software can poll the TEACK bit in the USART_ISR register.

Note: In Smartcard mode, when TE is set, there is a 1 bit-time delay before the transmission starts.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Transmitter is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Transmitter is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IDLEIE</name>
              <description>IDLE interrupt enable

This bit is set and cleared by software.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Interrupt inhibited</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>USART interrupt generated whenever IDLE=1 in the USART_ISR register</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXFNEIE</name>
              <description>RXFIFO not empty interrupt enable

This bit is set and cleared by software.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Interrupt inhibited</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>USART interrupt generated whenever ORE=1 or RXFNE=1 in the USART_ISR register</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TCIE</name>
              <description>Transmission complete interrupt enable

This bit is set and cleared by software.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Interrupt inhibited</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>USART interrupt generated whenever TC=1 in the USART_ISR register</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXFNFIE</name>
              <description>TXFIFO not full interrupt enable

This bit is set and cleared by software.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Interrupt inhibited</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>USART interrupt generated whenever TXFNF =1 in the USART_ISR register</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PEIE</name>
              <description>PE interrupt enable

This bit is set and cleared by software.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Interrupt inhibited</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>USART interrupt generated whenever PE=1 in the USART_ISR register</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PS</name>
              <description>Parity selection

This bit selects the odd or even parity when the parity generation/detection is enabled (PCE bit set). It is set and cleared by software. The parity is selected after the current byte.

This bitfield can only be written when the USART is disabled (UE=0).</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Even parity</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Odd parity</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PCE</name>
              <description>Parity control enable

This bit selects the hardware parity control (generation and detection). When the parity control is enabled, the computed parity is inserted at the MSB position (9th bit if M=1; 8th bit if M=0) and the parity is checked on the received data. This bit is set and cleared by software. Once it is set, PCE is active after the current byte (in reception and in transmission).

This bitfield can only be written when the USART is disabled (UE=0).</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Parity control disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Parity control enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAKE</name>
              <description>Receiver wakeup method

This bit determines the USART wakeup method from Mute mode. It is set or cleared by software.

This bitfield can only be written when the USART is disabled (UE=0).</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Idle line</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Address mark</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>M0</name>
              <description>Word length

This bit is used in conjunction with bit 28 (M1) to determine the word length. It is set or cleared by software (refer to bit 28 (M1)description).

This bit can only be written when the USART is disabled (UE=0).</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MME</name>
              <description>Mute mode enable

This bit enables the USART Mute mode function. When set, the USART can switch between active and Mute mode, as defined by the WAKE bit. It is set and cleared by software.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Receiver in Active mode permanently</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Receiver can switch between Mute mode and Active mode.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMIE</name>
              <description>Character match interrupt enable

This bit is set and cleared by software.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Interrupt inhibited</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>USART interrupt generated when the CMF bit is set in the USART_ISR register.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OVER8</name>
              <description>Oversampling mode

This bit can only be written when the USART is disabled (UE=0).

Note: In LIN, IrDA and Smartcard modes, this bit must be kept cleared.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Oversampling by 16</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Oversampling by 8</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DEDT</name>
              <description>Driver Enable deassertion time

This 5-bit value defines the time between the end of the last stop bit, in a transmitted message, and the de-activation of the DE (Driver Enable) signal. It is expressed in sample time units (1/8 or 1/16 bit time, depending on the oversampling rate).

If the USART_TDR register is written during the DEDT time, the new data is transmitted only when the DEDT and DEAT times have both elapsed.

This bitfield can only be written when the USART is disabled (UE=0).

Note: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DEAT</name>
              <description>Driver Enable assertion time

This 5-bit value defines the time between the activation of the DE (Driver Enable) signal and the beginning of the start bit. It is expressed in sample time units (1/8 or 1/16 bit time, depending on the oversampling rate). 

This bitfield can only be written when the USART is disabled (UE=0).

Note: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RTOIE</name>
              <description>Receiver timeout interrupt enable

This bit is set and cleared by software.

Note: If the USART does not support the Receiver timeout feature, this bit is reserved and must be kept at reset value. Section 78.4: USART implementation on page 4565.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Interrupt inhibited</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>USART interrupt generated when the RTOF bit is set in the USART_ISR register.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EOBIE</name>
              <description>End of Block interrupt enable

This bit is set and cleared by software.

Note: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Interrupt inhibited</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>USART interrupt generated when the EOBF flag is set in the USART_ISR register</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>M1</name>
              <description>Word length

This bit must be used in conjunction with bit 12 (M0) to determine the word length. It is set or cleared by software.

M[1:0] = 00: 1 start bit, 8 Data bits, n Stop bit

M[1:0] = 01: 1 start bit, 9 Data bits, n Stop bit

M[1:0] = 10: 1 start bit, 7 Data bits, n Stop bit

This bit can only be written when the USART is disabled (UE=0).

Note: In 7-bits data length mode, the Smartcard mode, LIN master mode and auto baud rate (0x7F and 0x55 frames detection) are not supported.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FIFOEN</name>
              <description>FIFO mode enable

This bit is set and cleared by software.

This bitfield can only be written when the USART is disabled (UE=0).

Note: FIFO mode can be used on standard UART communication, in SPI Master/Slave mode and in Smartcard modes only. It must not be enabled in IrDA and LIN modes.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>FIFO mode is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>FIFO mode is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXFEIE</name>
              <description>TXFIFO empty interrupt enable

This bit is set and cleared by software.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Interrupt inhibited</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>USART interrupt generated when TXFE=1 in the USART_ISR register</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXFFIE</name>
              <description>RXFIFO Full interrupt enable

This bit is set and cleared by software.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Interrupt inhibited</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>USART interrupt generated when RXFF=1 in the USART_ISR register</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>USART_CR1_ALTERNATE1</name>
          <displayName>USART_CR1_ALTERNATE1</displayName>
          <description>USART control register 1 [alternate]</description>
          <alternateRegister>USART_CR1</alternateRegister>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>UE</name>
              <description>USART enable

When this bit is cleared, the USART prescalers and outputs are stopped immediately, and all current operations are discarded. The USART configuration is kept, but all the USART_ISR status flags are reset. This bit is set and cleared by software.

Note: To enter low-power mode without generating errors on the line, the TE bit must be previously reset and the software must wait for the TC bit in the USART_ISR to be set before resetting the UE bit. 

Note: The DMA requests are also reset when UE = 0 so the DMA channel must be disabled before resetting the UE bit.

Note: In Smartcard mode, (SCEN = 1), the CK is always available when CLKEN = 1, regardless of the UE bit value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>USART prescaler and outputs disabled, low-power mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>USART enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UESM</name>
              <description>USART enable in low-power mode 

When this bit is cleared, the USART cannot request its kernel clock and is not functional in low-power mode.

When this bit is set, the USART can wake up the MCU from low-power mode.

This bit is set and cleared by software.

Note: The UESM bit must be set at the initialization phase. 

Note: If the USART does not support the wakeup from low-power mode, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>USART not functional in low-power mode.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>USART functional in low-power mode.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RE</name>
              <description>Receiver enable

This bit enables the receiver. It is set and cleared by software.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Receiver is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Receiver is enabled and begins searching for a start bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TE</name>
              <description>Transmitter enable

This bit enables the transmitter. When the Autonomous mode is not used, TE bit is set and cleared by software. When the Autonomous mode is used, TE bit becomes a status bit, which is set and cleared by hardware. 

Note: During transmission, a low pulse on the TE bit (0 followed by 1) sends a preamble (idle line) after the current word, except in Smartcard mode. In order to generate an idle character, the TE must not be immediately written to 1. To ensure the required duration, the software can poll the TEACK bit in the USART_ISR register.

Note: In Smartcard mode, when TE is set, there is a 1 bit-time delay before the transmission starts.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Transmitter is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Transmitter is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IDLEIE</name>
              <description>IDLE interrupt enable

This bit is set and cleared by software.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Interrupt inhibited</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>USART interrupt generated whenever IDLE=1 in the USART_ISR register</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXNEIE</name>
              <description>Receive data register not empty

This bit is set and cleared by software.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Interrupt inhibited</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>USART interrupt generated whenever ORE=1 or RXNE=1 in the USART_ISR register</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TCIE</name>
              <description>Transmission complete interrupt enable

This bit is set and cleared by software.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Interrupt inhibited</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>USART interrupt generated whenever TC=1 in the USART_ISR register</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXEIE</name>
              <description>Transmit data register empty

This bit is set and cleared by software.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Interrupt inhibited</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>USART interrupt generated whenever TXE =1 in the USART_ISR register</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PEIE</name>
              <description>PE interrupt enable

This bit is set and cleared by software.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Interrupt inhibited</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>USART interrupt generated whenever PE=1 in the USART_ISR register</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PS</name>
              <description>Parity selection

This bit selects the odd or even parity when the parity generation/detection is enabled (PCE bit set). It is set and cleared by software. The parity is selected after the current byte.

This bitfield can only be written when the USART is disabled (UE=0).</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Even parity</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Odd parity</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PCE</name>
              <description>Parity control enable

This bit selects the hardware parity control (generation and detection). When the parity control is enabled, the computed parity is inserted at the MSB position (9th bit if M=1; 8th bit if M=0) and the parity is checked on the received data. This bit is set and cleared by software. Once it is set, PCE is active after the current byte (in reception and in transmission).

This bitfield can only be written when the USART is disabled (UE=0).</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Parity control disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Parity control enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAKE</name>
              <description>Receiver wakeup method

This bit determines the USART wakeup method from Mute mode. It is set or cleared by software.

This bitfield can only be written when the USART is disabled (UE=0).</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Idle line</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Address mark</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>M0</name>
              <description>Word length

This bit is used in conjunction with bit 28 (M1) to determine the word length. It is set or cleared by software (refer to bit 28 (M1)description).

This bit can only be written when the USART is disabled (UE=0).</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MME</name>
              <description>Mute mode enable

This bit enables the USART Mute mode function. When set, the USART can switch between active and Mute mode, as defined by the WAKE bit. It is set and cleared by software.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Receiver in Active mode permanently</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Receiver can switch between Mute mode and Active mode.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMIE</name>
              <description>Character match interrupt enable

This bit is set and cleared by software.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Interrupt inhibited</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>USART interrupt generated when the CMF bit is set in the USART_ISR register.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OVER8</name>
              <description>Oversampling mode

This bit can only be written when the USART is disabled (UE=0).

Note: In LIN, IrDA and Smartcard modes, this bit must be kept cleared.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Oversampling by 16</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Oversampling by 8</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DEDT</name>
              <description>Driver Enable deassertion time

This 5-bit value defines the time between the end of the last stop bit, in a transmitted message, and the de-activation of the DE (Driver Enable) signal. It is expressed in sample time units (1/8 or 1/16 bit time, depending on the oversampling rate).

If the USART_TDR register is written during the DEDT time, the new data is transmitted only when the DEDT and DEAT times have both elapsed.

This bitfield can only be written when the USART is disabled (UE=0).

Note: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DEAT</name>
              <description>Driver Enable assertion time

This 5-bit value defines the time between the activation of the DE (Driver Enable) signal and the beginning of the start bit. It is expressed in sample time units (1/8 or 1/16 bit time, depending on the oversampling rate). 

This bitfield can only be written when the USART is disabled (UE=0).

Note: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RTOIE</name>
              <description>Receiver timeout interrupt enable

This bit is set and cleared by software.

Note: If the USART does not support the Receiver timeout feature, this bit is reserved and must be kept at reset value. Section 78.4: USART implementation on page 4565.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Interrupt inhibited</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>USART interrupt generated when the RTOF bit is set in the USART_ISR register.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EOBIE</name>
              <description>End of Block interrupt enable

This bit is set and cleared by software.

Note: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Interrupt inhibited</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>USART interrupt generated when the EOBF flag is set in the USART_ISR register</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>M1</name>
              <description>Word length

This bit must be used in conjunction with bit 12 (M0) to determine the word length. It is set or cleared by software.

M[1:0] = 00: 1 start bit, 8 Data bits, n Stop bit

M[1:0] = 01: 1 start bit, 9 Data bits, n Stop bit

M[1:0] = 10: 1 start bit, 7 Data bits, n Stop bit

This bit can only be written when the USART is disabled (UE=0).

Note: In 7-bits data length mode, the Smartcard mode, LIN master mode and auto baud rate (0x7F and 0x55 frames detection) are not supported.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FIFOEN</name>
              <description>FIFO mode enable

This bit is set and cleared by software.

This bitfield can only be written when the USART is disabled (UE=0).

Note: FIFO mode can be used on standard UART communication, in SPI Master/Slave mode and in Smartcard modes only. It must not be enabled in IrDA and LIN modes.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>FIFO mode is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>FIFO mode is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>USART_CR2</name>
          <displayName>USART_CR2</displayName>
          <description>USART control register 2</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SLVEN</name>
              <description>Synchronous Slave mode enable

When the SLVEN bit is set, the Synchronous slave mode is enabled.

Note: When SPI slave mode is not supported, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Slave mode disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Slave mode enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIS_NSS</name>
              <description>When the DIS_NSS bit is set, the NSS pin input is ignored.

Note: When SPI slave mode is not supported, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>SPI slave selection depends on NSS input pin.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>SPI slave is always selected and NSS input pin is ignored.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADDM7</name>
              <description>7-bit Address Detection/4-bit Address Detection

This bit is for selection between 4-bit address detection or 7-bit address detection. 

This bit can only be written when the USART is disabled (UE=0)

Note: In 7-bit and 9-bit data modes, the address detection is done on 6-bit and 8-bit address (ADD[5:0] and ADD[7:0]) respectively.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>4-bit address detection</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>7-bit address detection (in 8-bit data mode)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LBDL</name>
              <description>LIN break detection length

This bit is for selection between 11 bit or 10 bit break detection.

This bit can only be written when the USART is disabled (UE=0).

Note: If LIN mode is not supported, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>10-bit break detection</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>11-bit break detection</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LBDIE</name>
              <description>LIN break detection interrupt enable

Break interrupt mask (break detection using break delimiter).

Note: If LIN mode is not supported, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Interrupt is inhibited</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>An interrupt is generated whenever LBDF=1 in the USART_ISR register</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LBCL</name>
              <description>Last bit clock pulse

This bit is used to select whether the clock pulse associated with the last data bit transmitted (MSB) has to be output on the CK pin in Synchronous mode. 

The last bit is the 7th or 8th or 9th data bit transmitted depending on the 7 or 8 or 9 bit format selected by the M bit in the USART_CR1 register.

This bit can only be written when the USART is disabled (UE=0).

Note: If Synchronous mode is not supported, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>The clock pulse of the last data bit is not output to the CK pin</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The clock pulse of the last data bit is output to the CK pin</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CPHA</name>
              <description>Clock phase

This bit is used to select the phase of the clock output on the CK pin in Synchronous mode. It works in conjunction with the CPOL bit to produce the desired clock/data relationship (see Figure 933 and Figure 934)

This bit can only be written when the USART is disabled (UE=0).

Note: If Synchronous mode is not supported, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>The first clock transition is the first data capture edge</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The second clock transition is the first data capture edge</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CPOL</name>
              <description>Clock polarity

This bit enables the user to select the polarity of the clock output on the CK pin in Synchronous mode. It works in conjunction with the CPHA bit to produce the desired clock/data relationship 

This bit can only be written when the USART is disabled (UE=0).

Note: If Synchronous mode is not supported, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Steady low value on CK pin outside transmission window</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Steady high value on CK pin outside transmission window</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLKEN</name>
              <description>Clock enable

This bit enables the user to enable the CK pin.

This bit can only be written when the USART is disabled (UE=0).

Note: If neither Synchronous mode nor Smartcard mode is supported, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565.

In Smartcard mode, in order to provide correctly the CK clock to the smartcard, the steps below must be respected:

UE = 0

SCEN = 1

GTPR configuration

CLKEN= 1

Note: UE = 1</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>CK pin disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>CK pin enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>STOP</name>
              <description>stop bits

These bits are used for programming the stop bits.

This bitfield can only be written when the USART is disabled (UE=0).</description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>1 stop bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>0.5 stop bit.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>2 stop bits</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>1.5 stop bits</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LINEN</name>
              <description>LIN mode enable

This bit is set and cleared by software.

The LIN mode enables the capability to send LIN synchronous breaks (13 low bits) using the SBKRQ bit in the USART_CR1 register, and to detect LIN Sync breaks.

This bitfield can only be written when the USART is disabled (UE=0).

Note: If the USART does not support LIN mode, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>LIN mode disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>LIN mode enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SWAP</name>
              <description>Swap TX/RX pins

This bit is set and cleared by software.

This bitfield can only be written when the USART is disabled (UE=0).</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>TX/RX pins are used as defined in standard pinout</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>The TX and RX pins functions are swapped. This enables to work in the case of a cross-wired connection to another UART.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXINV</name>
              <description>RX pin active level inversion

This bit is set and cleared by software.

This enables the use of an external inverter on the RX line. 

This bitfield can only be written when the USART is disabled (UE=0).</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>RX pin signal works using the standard logic levels (VsubDD/sub =1/idle, Gnd=0/mark)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>RX pin signal values are inverted. ((VsubDD/sub =0/mark, Gnd=1/idle).</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXINV</name>
              <description>TX pin active level inversion

This bit is set and cleared by software.

This enables the use of an external inverter on the TX line. 

This bitfield can only be written when the USART is disabled (UE=0).</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>TX pin signal works using the standard logic levels (VsubDD/sub =1/idle, Gnd=0/mark)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>TX pin signal values are inverted. ((VsubDD/sub =0/mark, Gnd=1/idle).</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DATAINV</name>
              <description>Binary data inversion

This bit is set and cleared by software.

This bitfield can only be written when the USART is disabled (UE=0).</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Logical data from the data register are send/received in positive/direct logic. (1=H, 0=L)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Logical data from the data register are send/received in negative/inverse logic. (1=L, 0=H). The parity bit is also inverted.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MSBFIRST</name>
              <description>Most significant bit first

This bit is set and cleared by software.

This bitfield can only be written when the USART is disabled (UE=0).</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>data is transmitted/received with data bit 0 first, following the start bit.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>data is transmitted/received with the MSB (bit 7/8) first, following the start bit.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ABREN</name>
              <description>Auto baud rate enable

This bit is set and cleared by software.

Note: If the USART does not support the auto baud rate feature, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Auto baud rate detection is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Auto baud rate detection is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ABRMOD</name>
              <description>Auto baud rate mode

These bits are set and cleared by software.

This bitfield can only be written when ABREN = 0 or the USART is disabled (UE=0).

Note: If DATAINV=1 and/or MSBFIRST=1 the patterns must be the same on the line, for example 0xAA for MSBFIRST)

Note: If the USART does not support the auto baud rate feature, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Measurement of the start bit is used to detect the baud rate.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Falling edge to falling edge measurement (the received frame must start with a single bit = 1 - Frame = Start10xxxxxx)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>0x7F frame detection.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>0x55 frame detection</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RTOEN</name>
              <description>Receiver timeout enable

This bit is set and cleared by software.

When this feature is enabled, the RTOF flag in the USART_ISR register is set if the RX line is idle (no reception) for the duration programmed in the RTOR (receiver timeout register).

Note: If the USART does not support the Receiver timeout feature, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Receiver timeout feature disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Receiver timeout feature enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADD</name>
              <description>Address of the USART node 

These bits give the address of the USART node in Mute mode or a character code to be recognized in low-power or Run mode:

In Mute mode: they are used in multiprocessor communication to wakeup from Mute mode with 4-bit/7-bit address mark detection. The MSB of the character sent by the transmitter should be equal to 1. In 4-bit address mark detection, only ADD[3:0] bits are used.

In low-power mode: they are used for wake up from low-power mode on character match.

When a character, received during low-power mode, corresponds to the character programmed through ADD[7:0] bitfield, the CMF flag is set and wakes up the device from low-power mode if the corresponding interrupt is enabled by setting CMIE bit.

In Run mode with Mute mode inactive (for example, end-of-block detection in ModBus protocol): the whole received character (8 bits) is compared to ADD[7:0] value and CMF flag is set on match. An interrupt is generated if the CMIE bit is set.

These bits can only be written when the reception is disabled (RE = 0) or when the USART is disabled (UE = 0).</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>USART_CR3</name>
          <displayName>USART_CR3</displayName>
          <description>USART control register 3</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EIE</name>
              <description>Error interrupt enable

Error Interrupt Enable Bit is required to enable interrupt generation in case of a framing error, overrun error noise flag or SPI slave underrun error (FE=1 or ORE=1 or NE=1or UDR = 1 in the USART_ISR register).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Interrupt inhibited</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>interrupt generated when FE=1 or ORE=1 or NE=1 or UDR = 1 (in SPI slave mode) in the USART_ISR register.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IREN</name>
              <description>IrDA mode enable

This bit is set and cleared by software.

This bit can only be written when the USART is disabled (UE=0).

Note: If IrDA mode is not supported, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>IrDA disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>IrDA enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IRLP</name>
              <description>IrDA low-power

This bit is used for selecting between normal and low-power IrDA modes

This bit can only be written when the USART is disabled (UE=0).

Note: If IrDA mode is not supported, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Normal mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Low-power mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HDSEL</name>
              <description>Half-duplex selection

Selection of Single-wire Half-duplex mode 

This bit can only be written when the USART is disabled (UE=0).</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Half-duplex mode is not selected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Half-duplex mode is selected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NACK</name>
              <description>Smartcard NACK enable

This bitfield can only be written when the USART is disabled (UE=0).

Note: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>NACK transmission in case of parity error is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>NACK transmission during parity error is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SCEN</name>
              <description>Smartcard mode enable

This bit is used for enabling Smartcard mode.

This bitfield can only be written when the USART is disabled (UE=0).

Note: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Smartcard mode disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Smartcard mode enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DMAR</name>
              <description>DMA enable receiver

This bit is set/reset by software</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>DMA mode is enabled for reception</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>DMA mode is disabled for reception</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DMAT</name>
              <description>DMA enable transmitter

This bit is set/reset by software</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>DMA mode is enabled for transmission</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>DMA mode is disabled for transmission</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RTSE</name>
              <description>RTS enable

This bit can only be written when the USART is disabled (UE=0).

Note: If the hardware flow control feature is not supported, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>RTS hardware flow control disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>RTS output enabled, data is only requested when there is space in the receive buffer. The transmission of data is expected to cease after the current character has been transmitted. The RTS output is deasserted (pulled to 0) when data can be received.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CTSE</name>
              <description>CTS enable

This bit can only be written when the USART is disabled (UE=0)

Note: If the hardware flow control feature is not supported, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>CTS hardware flow control disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>CTS mode enabled, data is only transmitted when the CTS input is deasserted (tied to 0). If the CTS input is asserted while data is being transmitted, then the transmission is completed before stopping.If data is written into the data register while CTS is asserted, the transmission is postponed until CTS is deasserted.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CTSIE</name>
              <description>CTS interrupt enable

Note: If the hardware flow control feature is not supported, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Interrupt is inhibited</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>An interrupt is generated whenever CTSIF=1 in the USART_ISR register</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ONEBIT</name>
              <description>One sample bit method enable

This bit enables the user to select the sample method. When the one sample bit method is selected the noise detection flag (NE) is disabled.

This bit can only be written when the USART is disabled (UE=0).</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Three sample bit method</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>One sample bit method</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OVRDIS</name>
              <description>Overrun Disable

This bit is used to disable the receive overrun detection. 

the ORE flag is not set and the new received data overwrites the previous content of the USART_RDR register. When FIFO mode is enabled, the RXFIFO is bypassed and data are written directly in USART_RDR register. Even when FIFO management is enabled, the RXNE flag is to be used.

This bit can only be written when the USART is disabled (UE=0).

Note: This control bit enables checking the communication flow w/o reading the data</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Overrun Error Flag, ORE, is set when received data is not read before receiving new data.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Overrun functionality is disabled. If new data is received while the RXNE flag is still set</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DDRE</name>
              <description>DMA Disable on Reception Error

This bit can only be written when the USART is disabled (UE=0).

Note: The reception errors are: parity error, framing error or noise error.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>DMA is not disabled in case of reception error. The corresponding error flag is set but RXNE is kept 0 preventing from overrun. As a consequence, the DMA request is not asserted, so the erroneous data is not transferred (no DMA request), but next correct received data is transferred. (used for Smartcard mode)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>DMA is disabled following a reception error. The corresponding error flag is set, as well as RXNE. The DMA request is masked until the error flag is cleared. This means that the software must first disable the DMA request (DMAR = 0) or clear RXNE(RXFNE is case FIFO mode is enabled) before clearing the error flag.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DEM</name>
              <description>Driver enable mode 

This bit enables the user to activate the external transceiver control, through the DE signal. 

This bit can only be written when the USART is disabled (UE=0).

Note: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Section 78.4: USART implementation on page 4565.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>DE function is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>DE function is enabled. The DE signal is output on the RTS pin.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DEP</name>
              <description>Driver enable polarity selection

This bit can only be written when the USART is disabled (UE=0).

Note: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>DE signal is active high.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>DE signal is active low.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SCARCNT</name>
              <description>Smartcard auto-retry count

This bitfield specifies the number of retries for transmission and reception in Smartcard mode.

In Transmission mode, it specifies the number of automatic retransmission retries, before generating a transmission error (FE bit set).

In Reception mode, it specifies the number or erroneous reception trials, before generating a reception error (RXNE/RXFNE and PE bits set).

This bitfield must be programmed only when the USART is disabled (UE=0).

When the USART is enabled (UE=1), this bitfield may only be written to 0x0, in order to stop retransmission. 

0x1 to 0x7: number of automatic retransmission attempts (before signaling error)

Note: If Smartcard mode is not supported, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>retransmission disabled - No automatic retransmission in Transmission mode.</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXFTIE</name>
              <description>TXFIFO threshold interrupt enable

This bit is set and cleared by software.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Interrupt inhibited</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>USART interrupt generated when TXFIFO reaches the threshold programmed in TXFTCFG.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TCBGTIE</name>
              <description>Transmission Complete before guard time, interrupt enable

This bit is set and cleared by software.

Note: If the USART does not support the Smartcard mode, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Interrupt inhibited</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>USART interrupt generated whenever TCBGT=1 in the USART_ISR register</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXFTCFG</name>
              <description>Receive FIFO threshold configuration

Remaining combinations: Reserved</description>
              <bitOffset>25</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Receive FIFO reaches 1/8 of its depth</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Receive FIFO reaches 1/4 of its depth</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>Receive FIFO reaches 1/2 of its depth</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>Receive FIFO reaches 3/4 of its depth</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>Receive FIFO reaches 7/8 of its depth</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>Receive FIFO becomes full</description>
                  <value>0x5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXFTIE</name>
              <description>RXFIFO threshold interrupt enable

This bit is set and cleared by software.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Interrupt inhibited</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>USART interrupt generated when Receive FIFO reaches the threshold programmed in RXFTCFG.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXFTCFG</name>
              <description>TXFIFO threshold configuration

Remaining combinations: Reserved</description>
              <bitOffset>29</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>TXFIFO reaches 1/8 of its depth</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>TXFIFO reaches 1/4 of its depth</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>TXFIFO reaches 1/2 of its depth</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>TXFIFO reaches 3/4 of its depth</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>TXFIFO reaches 7/8 of its depth</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>TXFIFO becomes empty</description>
                  <value>0x5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>USART_BRR</name>
          <displayName>USART_BRR</displayName>
          <description>USART baud rate register</description>
          <addressOffset>0x0C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BRR</name>
              <description>USART baud rate

BRR[15:4]

BRR[15:4] correspond to USARTDIV[15:4]

BRR[3:0]

When OVER8 = 0, BRR[3:0] = USARTDIV[3:0].

When OVER8 = 1:

BRR[2:0] = USARTDIV[3:0] shifted 1 bit to the right.

BRR[3] must be kept cleared.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>USART_GTPR</name>
          <displayName>USART_GTPR</displayName>
          <description>USART guard time and prescaler register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PSC</name>
              <description>Prescaler value

PSC[7:0] = IrDA Normal and Low-power baud rate

This bitfield is used for programming the prescaler for dividing the USART source clock to achieve the low-power frequency:

The source clock is divided by the value given in the register (8 significant bits):

... 

PSC[4:0]: Prescaler value

This bitfield is used for programming the prescaler for dividing the USART source clock to provide the Smartcard clock.

The value given in the register (5 significant bits) is multiplied by 2 to give the division factor of the source clock frequency:

... 

This bitfield can only be written when the USART is disabled (UE=0).

Note: Bits [7:5] must be kept cleared if Smartcard mode is used.

Note: This bitfield is reserved and forced by hardware to 0 when the Smartcard and IrDA modes are not supported. Refer to Section 78.4: USART implementation on page 4565.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0_IRDA_LOW_POWER_AND_NORMAL_IRDA_MODE</name>
                  <description>Reserved - do not program this value</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1_IRDA_LOW_POWER_AND_NORMAL_IRDA_MODE</name>
                  <description>divides the source clock by 1</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2_IRDA_LOW_POWER_AND_NORMAL_IRDA_MODE</name>
                  <description>divides the source clock by 2</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3_SMARTCARD_MODE</name>
                  <description>divides the source clock by 6</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>GT</name>
              <description>Guard time value

This bitfield is used to program the Guard time value in terms of number of baud clock periods. 

This is used in Smartcard mode. The Transmission Complete flag is set after this guard time value.

This bitfield can only be written when the USART is disabled (UE=0).

Note: If Smartcard mode is not supported, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>USART_RTOR</name>
          <displayName>USART_RTOR</displayName>
          <description>USART receiver timeout register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RTO</name>
              <description>Receiver timeout value

This bitfield gives the Receiver timeout value in terms of number of bit duration.

In Standard mode, the RTOF flag is set if, after the last received character, no new start bit is detected for more than the RTO value.

In Smartcard mode, this value is used to implement the CWT and BWT. See Smartcard chapter for more details. In the standard, the CWT/BWT measurement is done starting from the start bit of the last received character.

Note: This value must only be programmed once per received character.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BLEN</name>
              <description>Block Length 

This bitfield gives the Block length in Smartcard T=1 Reception. Its value equals the number of information characters + the length of the Epilogue Field (1-LEC/2-CRC) - 1.

Examples: 

BLEN = 0 - 0 information characters + LEC

BLEN = 1 - 0 information characters + CRC

BLEN = 255 - 254 information characters + CRC (total 256 characters))

In Smartcard mode, the Block length counter is reset when TXE=0 (TXFE = 0 in case FIFO mode is enabled).

This bitfield can be used also in other modes. In this case, the Block length counter is reset when RE=0 (receiver disabled) and/or when the EOBCF bit is written to 1. 

Note: This value can be programmed after the start of the block reception (using the data from the LEN character in the Prologue Field). It must be programmed only once per received block.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>USART_RQR</name>
          <displayName>USART_RQR</displayName>
          <description>USART request register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ABRRQ</name>
              <description>Auto baud rate request

Writing 1 to this bit resets the ABRF and ABRE flags in the USART_ISR and requests an automatic baud rate measurement on the next received data frame. 

Note: If the USART does not support the auto baud rate feature, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SBKRQ</name>
              <description>Send break request

Writing 1 to this bit sets the SBKF flag and request to send a BREAK on the line, as soon as the transmit machine is available.

Note: When the application needs to send the break character following all previously inserted data, including the ones not yet transmitted, the software should wait for the TXE flag assertion before setting the SBKRQ bit.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>MMRQ</name>
              <description>Mute mode request

Writing 1 to this bit puts the USART in Mute mode and resets the RWU flag.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>RXFRQ</name>
              <description>Receive data flush request

Writing 1 to this bit empties the entire receive FIFO i.e. clears the bit RXFNE.

This enables to discard the received data without reading them, and avoid an overrun condition.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>TXFRQ</name>
              <description>Transmit data flush request

When FIFO mode is disabled, writing 1 to this bit sets the TXE flag. This enables to discard the transmit data. This bit must be used only in Smartcard mode, when data have not been sent due to errors (NACK) and the FE flag is active in the USART_ISR register. If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value.

When FIFO is enabled, TXFRQ bit is set to flush the whole FIFO. This sets the TXFE flag (Transmit FIFO empty, bit 23 in the USART_ISR register). Flushing the Transmit FIFO is supported in both UART and Smartcard modes. 

Note: In FIFO mode, the TXFNF flag is reset during the flush request until TxFIFO is empty in order to ensure that no data are written in the data register.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>USART_ISR</name>
          <displayName>USART_ISR</displayName>
          <description>USART interrupt and status register [alternate]</description>
          <addressOffset>0x1C</addressOffset>
          <size>0x20</size>
          <access>read-only</access>
          <resetValue>0x000000C0</resetValue>
          <resetMask>0xF00FFFFF</resetMask>
          <fields>
            <field>
              <name>PE</name>
              <description>Parity error

This bit is set by hardware when a parity error occurs in Reception mode. It is cleared by software, writing 1 to the PECF in the USART_ICR register. 

An interrupt is generated if PEIE = 1 in the USART_CR1 register.

Note: This error is associated with the character in the USART_RDR.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No parity error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Parity error</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FE</name>
              <description>Framing error

This bit is set by hardware when a de-synchronization, excessive noise or a break character is detected. It is cleared by software, writing 1 to the FECF bit in the USART_ICR register.

When transmitting data in Smartcard mode, this bit is set when the maximum number of transmit attempts is reached without success (the card NACKs the data frame).

An interrupt is generated if EIE = 1 in the USART_CR1 register.

Note: This error is associated with the character in the USART_RDR.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No Framing error is detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Framing error or break character is detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NE</name>
              <description>Noise detection flag

This bit is set by hardware when noise is detected on a received frame. It is cleared by software, writing 1 to the NFCF bit in the USART_ICR register.

Note: This bit does not generate an interrupt as it appears at the same time as the RXFNE bit which itself generates an interrupt. An interrupt is generated when the NE flag is set during multi buffer communication if the EIE bit is set.

Note: When the line is noise-free, the NE flag can be disabled by programming the ONEBIT bit to 1 to increase the USART tolerance to deviations (Refer to Section 78.5.9: Tolerance of the USART receiver to clock deviation on page 4584).

Note: This error is associated with the character in the USART_RDR.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No noise is detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Noise is detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ORE</name>
              <description>Overrun error

This bit is set by hardware when the data currently being received in the shift register is

ready to be transferred into the USART_RDR register while RXFF = 1. It is cleared by a software, writing 1 to the ORECF, in the USART_ICR register.

An interrupt is generated if RXFNEIE=1 or EIE = 1 in the USART_CR1 register.

Note: When this bit is set, the USART_RDR register content is not lost but the shift register is overwritten. An interrupt is generated if the ORE flag is set during multi buffer communication if the EIE bit is set.

Note: This bit is permanently forced to 0 (no overrun detection) when the bit OVRDIS is set in the USART_CR3 register.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No overrun error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Overrun error is detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IDLE</name>
              <description>Idle line detected

This bit is set by hardware when an Idle Line is detected. An interrupt is generated if IDLEIE=1 in the USART_CR1 register. It is cleared by software, writing 1 to the IDLECF in the USART_ICR register. 

Note: The IDLE bit is not set again until the RXFNE bit has been set (i.e. a new idle line occurs).

Note: If Mute mode is enabled (MME=1), IDLE is set if the USART is not mute (RWU=0), whatever the Mute mode selected by the WAKE bit. If RWU=1, IDLE is not set.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No Idle line is detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Idle line is detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXFNE</name>
              <description>RXFIFO not empty

RXFNE bit is set by hardware when the RXFIFO is not empty, meaning that data can be read from the USART_RDR register. Every read operation from the USART_RDR frees a location in the RXFIFO. 

RXFNE is cleared when the RXFIFO is empty. The RXFNE flag can also be cleared by writing 1 to the RXFRQ in the USART_RQR register. 

An interrupt is generated if RXFNEIE=1 in the USART_CR1 register.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Data is not received</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Received data is ready to be read.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TC</name>
              <description>Transmission complete

This bit indicates that the last data written in the USART_TDR has been transmitted out of the shift register. The TC flag behaves as follows:

When TDN = 0, the TC flag is set when the transmission of a frame containing data is complete and when TXE/TXFE is set.

When TDN is equal to the number of data in the TXFIFO, the TC flag is set when TXFIFO is empty and TDN is reached.

When TDN is greater than the number of data in the TXFIFO, TC remains cleared until the TXFIFO is filled again to reach the programmed number of data to be transferred. 

When TDN is less than the number of data in the TXFIFO, TC is set when TDN is reached even if the TXFIFO is not empty.

An interrupt is generated if TCIE=1 in the USART_CR1 register.

TC bit is cleared by software by writing 1 to the TCCF in the USART_ICR register or by writing to the USART_TDR register.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TXFNF</name>
              <description>TXFIFO not full

TXFNF is set by hardware when TXFIFO is not full meaning that data can be written in the USART_TDR. Every write operation to the USART_TDR places the data in the TXFIFO. This flag remains set until the TXFIFO is full. When the TXFIFO is full, this flag is cleared indicating that data can not be written into the USART_TDR. 

An interrupt is generated if the TXFNFIE bit =1 in the USART_CR1 register. 

Note: The TXFNF is kept reset during the flush request until TXFIFO is empty. After sending the flush request (by setting TXFRQ bit), the flag TXFNF should be checked prior to writing in TXFIFO (TXFNF and TXFE is set at the same time).

Note: This bit is used during single buffer transmission.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Transmit FIFO is full</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Transmit FIFO is not full</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LBDF</name>
              <description>LIN break detection flag

This bit is set by hardware when the LIN break is detected. It is cleared by software, by writing 1 to the LBDCF in the USART_ICR. 

An interrupt is generated if LBDIE = 1 in the USART_CR2 register.

Note: If the USART does not support LIN mode, this bit is reserved and kept at reset value. Refer to Section 78.4: USART implementation on page 4565.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>LIN Break not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>LIN break detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CTSIF</name>
              <description>CTS interrupt flag

This bit is set by hardware when the CTS input toggles, if the CTSE bit is set. It is cleared by software, by writing 1 to the CTSCF bit in the USART_ICR register. 

An interrupt is generated if CTSIE=1 in the USART_CR3 register.

Note: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No change occurred on the CTS status line</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>A change occurred on the CTS status line</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CTS</name>
              <description>CTS flag

This bit is set/reset by hardware. It is an inverted copy of the status of the CTS input pin. 

Note: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>CTS line set</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>CTS line reset</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RTOF</name>
              <description>Receiver timeout

This bit is set by hardware when the timeout value, programmed in the RTOR register has lapsed, without any communication. It is cleared by software, writing 1 to the RTOCF bit in the USART_ICR register. 

An interrupt is generated if RTOIE=1 in the USART_CR2 register.

In Smartcard mode, the timeout corresponds to the CWT or BWT timings.

Note: If a time equal to the value programmed in RTOR register separates 2 characters, RTOF is not set. If this time exceeds this value + 2 sample times (2/16 or 2/8, depending on the oversampling method), RTOF flag is set.

Note: The counter counts even if RE = 0 but RTOF is set only when RE = 1. If the timeout has already elapsed when RE is set, then RTOF is set.

Note: If the USART does not support the Receiver timeout feature, this bit is reserved and kept at reset value.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Timeout value not reached</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Timeout value reached without any data reception</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EOBF</name>
              <description>End of block flag

This bit is set by hardware when a complete block has been received (for example T=1 Smartcard mode). The detection is done when the number of received bytes (from the start of the block, including the prologue) is equal or greater than BLEN + 4.

An interrupt is generated if EOBIE = 1 in the USART_CR1 register.

It is cleared by software, writing 1 to EOBCF in the USART_ICR register.

Note: If Smartcard mode is not supported, this bit is reserved and kept at reset value. Refer to Section 78.4: USART implementation on page 4565.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>End of Block not reached</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>End of Block (number of characters) reached</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UDR</name>
              <description>SPI slave underrun error flag

In Slave transmission mode, this flag is set when the first clock pulse for data transmission appears while the software has not yet loaded any value into USART_TDR. This flag is reset by setting UDRCF bit in the USART_ICR register.

Note: If the USART does not support the SPI slave mode, this bit is reserved and kept at reset value. Refer to Section 78.4: USART implementation on page 4565.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No underrun error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>underrun error</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ABRE</name>
              <description>Auto baud rate error

This bit is set by hardware if the baud rate measurement failed (baud rate out of range or character comparison failed)

It is cleared by software, by writing 1 to the ABRRQ bit in the USART_RQR register. 

Note: If the USART does not support the auto baud rate feature, this bit is reserved and kept at reset value.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ABRF</name>
              <description>Auto baud rate flag

This bit is set by hardware when the automatic baud rate has been set (RXFNE is also set, generating an interrupt if RXFNEIE = 1) or when the auto baud rate operation was completed without success (ABRE=1) (ABRE, RXFNE and FE are also set in this case)

It is cleared by software, in order to request a new auto baud rate detection, by writing 1 to the ABRRQ in the USART_RQR register. 

Note: If the USART does not support the auto baud rate feature, this bit is reserved and kept at reset value.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BUSY</name>
              <description>Busy flag

This bit is set and reset by hardware. It is active when a communication is ongoing on the RX line (successful start bit detected). It is reset at the end of the reception (successful or not).</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>USART is idle (no reception)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reception on going</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMF</name>
              <description>Character match flag

This bit is set by hardware, when a the character defined by ADD[7:0] is received. It is cleared by software, writing 1 to the CMCF in the USART_ICR register. 

An interrupt is generated if CMIE=1in the USART_CR1 register.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No Character match detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Character match detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SBKF</name>
              <description>Send break flag

This bit indicates that a send break character was requested. It is set by software, by writing 1 to the SBKRQ bit in the USART_CR3 register. It is automatically reset by hardware during the stop bit of break transmission.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No break character transmitted</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Break character transmitted</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RWU</name>
              <description>Receiver wakeup from Mute mode

This bit indicates if the USART is in Mute mode. It is cleared/set by hardware when a wakeup/mute sequence is recognized. The Mute mode control sequence (address or IDLE) is selected by the WAKE bit in the USART_CR1 register.

When wakeup on IDLE mode is selected, this bit can only be set by software, writing 1 to the MMRQ bit in the USART_RQR register. 

Note: If the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to Section 78.4: USART implementation on page 4565.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Receiver in Active mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Receiver in Mute mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TEACK</name>
              <description>Transmit enable acknowledge flag 

This bit is set/reset by hardware, when the Transmit Enable value is taken into account by the USART. 

It can be used when an idle frame request is generated by writing TE=0, followed by TE=1 in the USART_CR1 register, in order to respect the TE=0 minimum period.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>REACK</name>
              <description>Receive enable acknowledge flag 

This bit is set/reset by hardware, when the Receive Enable value is taken into account by the USART. 

It can be used to verify that the USART is ready for reception before entering low-power mode.

Note: If the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to Section 78.4: USART implementation on page 4565.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TXFE</name>
              <description>TXFIFO Empty

This bit is set by hardware when TXFIFO is Empty. When the TXFIFO contains at least one data, this flag is cleared. The TXFE flag can also be set by writing 1 to the bit TXFRQ (bit 4) in the USART_RQR register.

An interrupt is generated if the TXFEIE bit =1 (bit 30) in the USART_CR1 register.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>TXFIFO not empty.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>TXFIFO empty.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXFF</name>
              <description>RXFIFO Full

This bit is set by hardware when the number of received data corresponds to RXFIFO size + 1 (RXFIFO full + 1 data in the USART_RDR register. 

An interrupt is generated if the RXFFIE bit =1 in the USART_CR1 register.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>RXFIFO not full.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>RXFIFO Full.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TCBGT</name>
              <description>Transmission complete before guard time flag

This bit is set when the last data written in the USART_TDR has been transmitted correctly out of the shift register. 

It is set by hardware in Smartcard mode, if the transmission of a frame containing data is complete and if the smartcard did not send back any NACK. An interrupt is generated if TCBGTIE=1 in the USART_CR3 register. 

This bit is cleared by software, by writing 1 to the TCBGTCF in the USART_ICR register or by a write to the USART_TDR register.

Note: If the USART does not support the Smartcard mode, this bit is reserved and kept at reset value. If the USART supports the Smartcard mode and the Smartcard mode is enabled, the TCBGT reset value is 1. Refer to Section 78.4: USART implementation on page 4565.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Transmission is not complete or transmission is complete unsuccessfully (i.e. a NACK is received from the card)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Transmission is complete successfully (before Guard time completion and there is no NACK from the smart card).</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXFT</name>
              <description>RXFIFO threshold flag

This bit is set by hardware when the threshold programmed in RXFTCFG in USART_CR3 register is reached. This means that there are (RXFTCFG - 1) data in the Receive FIFO and one data in the USART_RDR register. An interrupt is generated if the RXFTIE bit =1 (bit 27) in the USART_CR3 register. 

Note: When the RXFTCFG threshold is configured to 101, RXFT flag is set if 16 data are available i.e. 15 data in the RXFIFO and 1 data in the USART_RDR. Consequently, the 17th received data does not cause an overrun error. The overrun error occurs after receiving the 18th data.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Receive FIFO does not reach the programmed threshold.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Receive FIFO reached the programmed threshold.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXFT</name>
              <description>TXFIFO threshold flag

This bit is set by hardware when the TXFIFO reaches the threshold programmed in TXFTCFG of USART_CR3 register i.e. the TXFIFO contains TXFTCFG empty locations. An interrupt is generated if the TXFTIE bit =1 (bit 31) in the USART_CR3 register.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>TXFIFO does not reach the programmed threshold.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>TXFIFO reached the programmed threshold.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>USART_ISR_ALTERNATE1</name>
          <displayName>USART_ISR_ALTERNATE1</displayName>
          <description>USART interrupt and status register [alternate]</description>
          <alternateRegister>USART_ISR</alternateRegister>
          <addressOffset>0x1C</addressOffset>
          <size>0x20</size>
          <access>read-only</access>
          <resetValue>0x000000C0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PE</name>
              <description>Parity error

This bit is set by hardware when a parity error occurs in Reception mode. It is cleared by software, writing 1 to the PECF in the USART_ICR register. 

An interrupt is generated if PEIE = 1 in the USART_CR1 register.

Note: This error is associated with the character in the USART_RDR.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No parity error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Parity error</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FE</name>
              <description>Framing error

This bit is set by hardware when a de-synchronization, excessive noise or a break character is detected. It is cleared by software, writing 1 to the FECF bit in the USART_ICR register.

When transmitting data in Smartcard mode, this bit is set when the maximum number of transmit attempts is reached without success (the card NACKs the data frame).

An interrupt is generated if EIE = 1 in the USART_CR1 register.

Note: This error is associated with the character in the USART_RDR.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No Framing error is detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Framing error or break character is detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NE</name>
              <description>Noise detection flag

This bit is set by hardware when noise is detected on a received frame. It is cleared by software, writing 1 to the NFCF bit in the USART_ICR register.

Note: This bit does not generate an interrupt as it appears at the same time as the RXNE bit which itself generates an interrupt. An interrupt is generated when the NE flag is set during multi buffer communication if the EIE bit is set.

Note: When the line is noise-free, the NE flag can be disabled by programming the ONEBIT bit to 1 to increase the USART tolerance to deviations (Refer to Section 78.5.9: Tolerance of the USART receiver to clock deviation on page 4584).

Note: This error is associated with the character in the USART_RDR.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No noise is detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Noise is detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ORE</name>
              <description>Overrun error

This bit is set by hardware when the data currently being received in the shift register is

ready to be transferred into the USART_RDR register while RXNE=1. It is cleared by a software, writing 1 to the ORECF, in the USART_ICR register.

An interrupt is generated if RXNEIE=1 or EIE = 1 in the USART_CR1 register.

Note: When this bit is set, the USART_RDR register content is not lost but the shift register is overwritten. An interrupt is generated if the ORE flag is set during multi buffer communication if the EIE bit is set.

Note: This bit is permanently forced to 0 (no overrun detection) when the bit OVRDIS is set in the USART_CR3 register.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No overrun error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Overrun error is detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IDLE</name>
              <description>Idle line detected

This bit is set by hardware when an Idle Line is detected. An interrupt is generated if IDLEIE=1 in the USART_CR1 register. It is cleared by software, writing 1 to the IDLECF in the USART_ICR register. 

Note: The IDLE bit is not set again until the RXNE bit has been set (i.e. a new idle line occurs).

Note: If Mute mode is enabled (MME=1), IDLE is set if the USART is not mute (RWU=0), whatever the Mute mode selected by the WAKE bit. If RWU=1, IDLE is not set.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No Idle line is detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Idle line is detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXNE</name>
              <description>Read data register not empty

RXNE bit is set by hardware when the content of the USART_RDR shift register has been transferred to the USART_RDR register. It is cleared by reading from the USART_RDR register. The RXNE flag can also be cleared by writing 1 to the RXFRQ in the USART_RQR register.

An interrupt is generated if RXNEIE=1 in the USART_CR1 register.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Data is not received</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Received data is ready to be read.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TC</name>
              <description>Transmission complete

This bit indicates that the last data written in the USART_TDR has been transmitted out of the shift register. The TC flag is set when the transmission of a frame containing data is complete and when TXE is set.

An interrupt is generated if TCIE=1 in the USART_CR1 register.

TC bit is cleared by software by writing 1 to the TCCF in the USART_ICR register or by writing to the USART_TDR register.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TXE</name>
              <description>Transmit data register empty

TXE is set by hardware when the content of the USART_TDR register has been transferred into the shift register. It is cleared by writing to the USART_TDR register. The TXE flag can also be set by writing 1 to the TXFRQ in the USART_RQR register, in order to discard the data (only in Smartcard T=0 mode, in case of transmission failure).

An interrupt is generated if the TXEIE bit =1 in the USART_CR1 register.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Data register full</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Data register full</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LBDF</name>
              <description>LIN break detection flag

This bit is set by hardware when the LIN break is detected. It is cleared by software, by writing 1 to the LBDCF in the USART_ICR. 

An interrupt is generated if LBDIE = 1 in the USART_CR2 register.

Note: If the USART does not support LIN mode, this bit is reserved and kept at reset value. Refer to Section 78.4: USART implementation on page 4565.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>LIN Break not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>LIN break detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CTSIF</name>
              <description>CTS interrupt flag

This bit is set by hardware when the CTS input toggles, if the CTSE bit is set. It is cleared by software, by writing 1 to the CTSCF bit in the USART_ICR register. 

An interrupt is generated if CTSIE=1 in the USART_CR3 register.

Note: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No change occurred on the CTS status line</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>A change occurred on the CTS status line</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CTS</name>
              <description>CTS flag

This bit is set/reset by hardware. It is an inverted copy of the status of the CTS input pin. 

Note: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>CTS line set</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>CTS line reset</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RTOF</name>
              <description>Receiver timeout

This bit is set by hardware when the timeout value, programmed in the RTOR register has lapsed, without any communication. It is cleared by software, writing 1 to the RTOCF bit in the USART_ICR register. 

An interrupt is generated if RTOIE=1 in the USART_CR2 register.

In Smartcard mode, the timeout corresponds to the CWT or BWT timings.

Note: If a time equal to the value programmed in RTOR register separates 2 characters, RTOF is not set. If this time exceeds this value + 2 sample times (2/16 or 2/8, depending on the oversampling method), RTOF flag is set.

Note: The counter counts even if RE = 0 but RTOF is set only when RE = 1. If the timeout has already elapsed when RE is set, then RTOF is set.

Note: If the USART does not support the Receiver timeout feature, this bit is reserved and kept at reset value.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Timeout value not reached</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Timeout value reached without any data reception</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EOBF</name>
              <description>End of block flag

This bit is set by hardware when a complete block has been received (for example T=1 Smartcard mode). The detection is done when the number of received bytes (from the start of the block, including the prologue) is equal or greater than BLEN + 4.

An interrupt is generated if EOBIE = 1 in the USART_CR1 register.

It is cleared by software, writing 1 to EOBCF in the USART_ICR register.

Note: If Smartcard mode is not supported, this bit is reserved and kept at reset value. Refer to Section 78.4: USART implementation on page 4565.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>End of Block not reached</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>End of Block (number of characters) reached</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UDR</name>
              <description>SPI slave underrun error flag

In Slave transmission mode, this flag is set when the first clock pulse for data transmission appears while the software has not yet loaded any value into USART_TDR. This flag is reset by setting UDRCF bit in the USART_ICR register.

Note: If the USART does not support the SPI slave mode, this bit is reserved and kept at reset value. Refer to Section 78.4: USART implementation on page 4565.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No underrun error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>underrun error</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ABRE</name>
              <description>Auto baud rate error

This bit is set by hardware if the baud rate measurement failed (baud rate out of range or character comparison failed)

It is cleared by software, by writing 1 to the ABRRQ bit in the USART_RQR register. 

Note: If the USART does not support the auto baud rate feature, this bit is reserved and kept at reset value.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ABRF</name>
              <description>Auto baud rate flag

This bit is set by hardware when the automatic baud rate has been set (RXNE is also set, generating an interrupt if RXNEIE = 1) or when the auto baud rate operation was completed without success (ABRE=1) (ABRE, RXNE and FE are also set in this case)

It is cleared by software, in order to request a new auto baud rate detection, by writing 1 to the ABRRQ in the USART_RQR register. 

Note: If the USART does not support the auto baud rate feature, this bit is reserved and kept at reset value.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BUSY</name>
              <description>Busy flag

This bit is set and reset by hardware. It is active when a communication is ongoing on the RX line (successful start bit detected). It is reset at the end of the reception (successful or not).</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>USART is idle (no reception)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Reception on going</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMF</name>
              <description>Character match flag

This bit is set by hardware, when a the character defined by ADD[7:0] is received. It is cleared by software, writing 1 to the CMCF in the USART_ICR register. 

An interrupt is generated if CMIE=1in the USART_CR1 register.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No Character match detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Character match detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SBKF</name>
              <description>Send break flag

This bit indicates that a send break character was requested. It is set by software, by writing 1 to the SBKRQ bit in the USART_CR3 register. It is automatically reset by hardware during the stop bit of break transmission.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>No break character transmitted</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Break character transmitted</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RWU</name>
              <description>Receiver wakeup from Mute mode

This bit indicates if the USART is in Mute mode. It is cleared/set by hardware when a wakeup/mute sequence is recognized. The Mute mode control sequence (address or IDLE) is selected by the WAKE bit in the USART_CR1 register.

When wakeup on IDLE mode is selected, this bit can only be set by software, writing 1 to the MMRQ bit in the USART_RQR register. 

Note: If the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to Section 78.4: USART implementation on page 4565.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Receiver in Active mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Receiver in Mute mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TEACK</name>
              <description>Transmit enable acknowledge flag 

This bit is set/reset by hardware, when the Transmit Enable value is taken into account by the USART. 

It can be used when an idle frame request is generated by writing TE=0, followed by TE=1 in the USART_CR1 register, in order to respect the TE=0 minimum period.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>REACK</name>
              <description>Receive enable acknowledge flag 

This bit is set/reset by hardware, when the Receive Enable value is taken into account by the USART. 

It can be used to verify that the USART is ready for reception before entering low-power mode.

Note: If the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to Section 78.4: USART implementation on page 4565.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TCBGT</name>
              <description>Transmission complete before guard time flag

This bit is set when the last data written in the USART_TDR has been transmitted correctly out of the shift register. 

It is set by hardware in Smartcard mode, if the transmission of a frame containing data is complete and if the smartcard did not send back any NACK. An interrupt is generated if TCBGTIE=1 in the USART_CR3 register. 

This bit is cleared by software, by writing 1 to the TCBGTCF in the USART_ICR register or by a write to the USART_TDR register.

Note: If the USART does not support the Smartcard mode, this bit is reserved and kept at reset value. If the USART supports the Smartcard mode and the Smartcard mode is enabled, the TCBGT reset value is 1. Refer to Section 78.4: USART implementation on page 4565.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Transmission is not complete or transmission is complete unsuccessfully (i.e. a NACK is received from the card)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Transmission is complete successfully (before Guard time completion and there is no NACK from the smart card).</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>USART_ICR</name>
          <displayName>USART_ICR</displayName>
          <description>USART interrupt flag clear register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PECF</name>
              <description>Parity error clear flag

Writing 1 to this bit clears the PE flag in the USART_ISR register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>FECF</name>
              <description>Framing error clear flag

Writing 1 to this bit clears the FE flag in the USART_ISR register.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>NECF</name>
              <description>Noise detected clear flag

Writing 1 to this bit clears the NE flag in the USART_ISR register.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ORECF</name>
              <description>Overrun error clear flag

Writing 1 to this bit clears the ORE flag in the USART_ISR register.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>IDLECF</name>
              <description>Idle line detected clear flag

Writing 1 to this bit clears the IDLE flag in the USART_ISR register.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>TXFECF</name>
              <description>TXFIFO empty clear flag

Writing 1 to this bit clears the TXFE flag in the USART_ISR register.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>TCCF</name>
              <description>Transmission complete clear flag

Writing 1 to this bit clears the TC flag in the USART_ISR register.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>TCBGTCF</name>
              <description>Transmission complete before Guard time clear flag

Writing 1 to this bit clears the TCBGT flag in the USART_ISR register.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>LBDCF</name>
              <description>LIN break detection clear flag

Writing 1 to this bit clears the LBDF flag in the USART_ISR register.

Note: If LIN mode is not supported, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CTSCF</name>
              <description>CTS clear flag

Writing 1 to this bit clears the CTSIF flag in the USART_ISR register.

Note: If the hardware flow control feature is not supported, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>RTOCF</name>
              <description>Receiver timeout clear flag

Writing 1 to this bit clears the RTOF flag in the USART_ISR register.

Note: If the USART does not support the Receiver timeout feature, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>EOBCF</name>
              <description>End of block clear flag

Writing 1 to this bit clears the EOBF flag in the USART_ISR register.

Note: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>UDRCF</name>
              <description>SPI slave underrun clear flag

Writing 1 to this bit clears the UDRF flag in the USART_ISR register.

Note: If the USART does not support SPI slave mode, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CMCF</name>
              <description>Character match clear flag

Writing 1 to this bit clears the CMF flag in the USART_ISR register.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>USART_RDR</name>
          <displayName>USART_RDR</displayName>
          <description>USART receive data register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDR</name>
              <description>Receive data value

Contains the received data character.

The RDR register provides the parallel interface between the input shift register and the internal bus (see Figure 927).

When receiving with the parity enabled, the value read in the MSB bit is the received parity bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>USART_TDR</name>
          <displayName>USART_TDR</displayName>
          <description>USART transmit data register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TDR</name>
              <description>Transmit data value

Contains the data character to be transmitted.

The USART_TDR register provides the parallel interface between the internal bus and the output shift register (see Figure 927).

When transmitting with the parity enabled (PCE bit set to 1 in the USART_CR1 register), the value written in the MSB (bit 7 or bit 8 depending on the data length) has no effect because it is replaced by the parity.

Note: This register must be written only when TXE/TXFNF=1.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>USART_PRESC</name>
          <displayName>USART_PRESC</displayName>
          <description>USART prescaler register</description>
          <addressOffset>0x2C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRESCALER</name>
              <description>Clock prescaler

The USART input clock can be divided by a prescaler factor:

Remaining combinations: Reserved

Note: When PRESCALER is programmed with a value different of the allowed ones, programmed prescaler value is equal to 1011 i.e. input clock divided by 256.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>input clock not divided</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>input clock divided by 2</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>input clock divided by 4</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>input clock divided by 6</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>input clock divided by 8</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>input clock divided by 10</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x6</name>
                  <description>input clock divided by 12</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7</name>
                  <description>input clock divided by 16</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x8</name>
                  <description>input clock divided by 32</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x9</name>
                  <description>input clock divided by 64</description>
                  <value>0x9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xA</name>
                  <description>input clock divided by 128</description>
                  <value>0xA</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xB</name>
                  <description>input clock divided by 256</description>
                  <value>0xB</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>USART_AUTOCR</name>
          <displayName>USART_AUTOCR</displayName>
          <description>USART Autonomous mode control register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x80000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TDN</name>
              <description>TDN transmission data number

This bitfield enables the programming of the number of data to be transmitted. It can be written only when UE is cleared in USART_CR1.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIGPOL</name>
              <description>Trigger polarity bit

This bitfield can be written only when the UE bit is cleared in USART_CR1 register.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Trigger active on rising edge</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Trigger active on falling edge</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TRIGEN</name>
              <description>Trigger enable bit 

Note: This bitfield can be written only when the UE bit of USART_CR1 register is cleared. 

Note: When a trigger is detected, TE is set to 1 in USART_CR1 and the data transfer is launched.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Trigger disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Trigger enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IDLEDIS</name>
              <description>Idle frame transmission disable bit after enabling the transmitter

Note: This bitfield can be written only when the UE bit of USART_CR1 register is cleared.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Idle frame sent after enabling the transmitter (TE = 1 in USART_CR1)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Idle frame not sent after enabling the transmitter</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TRIGSEL</name>
              <description>Trigger selection bits 

Refer to Description of USART interconnections.

This bitfield can be written only when the UE bit is cleared in USART_CR1 register.

...

Note: This bitfield can be written only when the UE bit of USART_CR1 register is cleared.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>usart_trg0 selected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>usart_trg1 selected</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0xF</name>
                  <description>usart_trg15 selected</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>WWDG</name>
      <description>System window watchdog</description>
      <groupName>WWDG</groupName>
      <baseAddress>0x40002C00</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x400</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>WWDG</name>
        <description>Window Watchdog interrupt</description>
        <value>0</value>
      </interrupt>
      <registers>
        <register>
          <name>WWDG_CR</name>
          <displayName>WWDG_CR</displayName>
          <description>WWDG control register</description>
          <addressOffset>0x000</addressOffset>
          <size>0x20</size>
          <resetValue>0x0000007F</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>T</name>
              <description>7-bit counter (MSB to LSB)
These bits contain the value of the watchdog counter, decremented every
(4096 x 2supWDGTB[2:0]/sup) PCLK cycles. A reset is produced when it is decremented from 0x40 to 0x3F (T6 becomes cleared).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WDGA</name>
              <description>Activation bit 
This bit is set by software and only cleared by hardware after a reset. When WDGA = 1, the watchdog can generate a reset.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>Watchdog disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>Watchdog enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>WWDG_CFR</name>
          <displayName>WWDG_CFR</displayName>
          <description>WWDG configuration register</description>
          <addressOffset>0x004</addressOffset>
          <size>0x20</size>
          <resetValue>0x0000007F</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>W</name>
              <description>7-bit window value
These bits contain the window value to be compared with the down-counter.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EWI</name>
              <description>Early wakeup interrupt
When set, an interrupt occurs whenever the counter reaches the value 0x40. This interrupt is only cleared by hardware after a reset.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WDGTB</name>
              <description>Timer base
The timebase of the prescaler can be modified as follows:</description>
              <bitOffset>11</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>B_0x0</name>
                  <description>CK counter clock (PCLK div 4096) div 1</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x1</name>
                  <description>CK counter clock (PCLK div 4096) div 2</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x2</name>
                  <description>CK counter clock (PCLK div 4096) div 4</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x3</name>
                  <description>CK counter clock (PCLK div 4096) div 8</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x4</name>
                  <description>CK counter clock (PCLK div 4096) div 16</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x5</name>
                  <description>CK counter clock (PCLK div 4096) div 32</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x6</name>
                  <description>CK counter clock (PCLK div 4096) div 64</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>B_0x7</name>
                  <description>CK counter clock (PCLK div 4096) div 128</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>WWDG_SR</name>
          <displayName>WWDG_SR</displayName>
          <description>WWDG status register</description>
          <addressOffset>0x008</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EWIF</name>
              <description>Early wakeup interrupt flag
This bit is set by hardware when the counter has reached the value 0x40. It must be cleared by software by writing 0. Writing 1 has no effect. This bit is also set if the interrupt is not enabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
  </peripherals>
</device>
